(this.nativeLog || function(s) {console.log(s)})('START ALI WEEX-HTML5: 0.2.24 BUILD 20160615');
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(152);


/***/ },
/* 1 */,
/* 2 */,
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(process, global, module) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */
	
	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }
	
	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }
	
	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }
	
	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }
	
	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;
	
	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }
	
	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }
	
	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }
	
	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
	
	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';
	
	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // see https://github.com/cujojs/when/issues/410 for details
	      return function() {
	        process.nextTick(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }
	
	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });
	
	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }
	
	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }
	
	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }
	
	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];
	
	        callback(arg);
	
	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }
	
	      lib$es6$promise$asap$$len = 0;
	    }
	
	    function lib$es6$promise$asap$$attemptVertx() {
	      try {
	        var r = require;
	        var vertx = __webpack_require__(6);
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }
	
	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }
	    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	      var parent = this;
	
	      var child = new this.constructor(lib$es6$promise$$internal$$noop);
	
	      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	        lib$es6$promise$$internal$$makePromise(child);
	      }
	
	      var state = parent._state;
	
	      if (state) {
	        var callback = arguments[state - 1];
	        lib$es6$promise$asap$$asap(function(){
	          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	        });
	      } else {
	        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	      }
	
	      return child;
	    }
	    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }
	
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);
	
	    function lib$es6$promise$$internal$$noop() {}
	
	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;
	
	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$selfFulfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }
	
	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }
	
	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;
	
	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }
	
	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }
	
	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	      if (maybeThenable.constructor === promise.constructor &&
	          then === lib$es6$promise$then$$default &&
	          constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }
	
	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }
	
	      lib$es6$promise$$internal$$publish(promise);
	    }
	
	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	
	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;
	
	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }
	
	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;
	
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }
	
	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;
	
	      parent._onerror = null;
	
	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;
	
	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }
	
	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;
	
	      if (subscribers.length === 0) { return; }
	
	      var child, callback, detail = promise._result;
	
	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];
	
	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }
	
	      promise._subscribers.length = 0;
	    }
	
	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }
	
	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();
	
	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }
	
	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;
	
	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);
	
	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }
	
	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }
	
	      } else {
	        value = detail;
	        succeeded = true;
	      }
	
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }
	
	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }
	
	    var lib$es6$promise$$internal$$id = 0;
	    function lib$es6$promise$$internal$$nextId() {
	      return lib$es6$promise$$internal$$id++;
	    }
	
	    function lib$es6$promise$$internal$$makePromise(promise) {
	      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	      promise._state = undefined;
	      promise._result = undefined;
	      promise._subscribers = [];
	    }
	
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;
	
	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        return new Constructor(function(resolve, reject) {
	          reject(new TypeError('You must pass an array to race.'));
	        });
	      } else {
	        return new Constructor(function(resolve, reject) {
	          var length = entries.length;
	          for (var i = 0; i < length; i++) {
	            Constructor.resolve(entries[i]).then(resolve, reject);
	          }
	        });
	      }
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;
	
	
	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }
	
	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }
	
	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.
	
	      Terminology
	      -----------
	
	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.
	
	      A promise can be in one of three states: pending, fulfilled, or rejected.
	
	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.
	
	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.
	
	
	      Basic Usage:
	      ------------
	
	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);
	
	        // on failure
	        reject(reason);
	      });
	
	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Advanced Usage:
	      ---------------
	
	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.
	
	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();
	
	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();
	
	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }
	
	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```
	
	      Unlike callbacks, promises are great composable primitives.
	
	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON
	
	        return values;
	      });
	      ```
	
	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	      this._result = this._state = undefined;
	      this._subscribers = [];
	
	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	      }
	    }
	
	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;
	
	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,
	
	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	
	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	
	      Chaining
	      --------
	
	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	
	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	
	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	
	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	
	      Assimilation
	      ------------
	
	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	
	      If the assimliated promise rejects, then the downstream promise will also reject.
	
	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	
	      Simple Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var result;
	
	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	
	      Advanced Example
	      --------------
	
	      Synchronous Example
	
	      ```javascript
	      var author, books;
	
	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	
	      Errback Example
	
	      ```js
	
	      function foundBooks(books) {
	
	      }
	
	      function failure(reason) {
	
	      }
	
	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	
	      Promise Example;
	
	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: lib$es6$promise$then$$default,
	
	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	
	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	
	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	
	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	
	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      this._instanceConstructor = Constructor;
	      this.promise = new Constructor(lib$es6$promise$$internal$$noop);
	
	      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	        lib$es6$promise$$internal$$makePromise(this.promise);
	      }
	
	      if (lib$es6$promise$utils$$isArray(input)) {
	        this._input     = input;
	        this.length     = input.length;
	        this._remaining = input.length;
	
	        this._result = new Array(this.length);
	
	        if (this.length === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        } else {
	          this.length = this.length || 0;
	          this._enumerate();
	          if (this._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	      }
	    }
	
	    function lib$es6$promise$enumerator$$validationError() {
	      return new Error('Array Methods must be provided an Array');
	    }
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var length  = this.length;
	      var input   = this._input;
	
	      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        this._eachEntry(input[i], i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var c = this._instanceConstructor;
	      var resolve = c.resolve;
	
	      if (resolve === lib$es6$promise$promise$resolve$$default) {
	        var then = lib$es6$promise$$internal$$getThen(entry);
	
	        if (then === lib$es6$promise$then$$default &&
	            entry._state !== lib$es6$promise$$internal$$PENDING) {
	          this._settledAt(entry._state, i, entry._result);
	        } else if (typeof then !== 'function') {
	          this._remaining--;
	          this._result[i] = entry;
	        } else if (c === lib$es6$promise$promise$$default) {
	          var promise = new c(lib$es6$promise$$internal$$noop);
	          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	          this._willSettleAt(promise, i);
	        } else {
	          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);
	        }
	      } else {
	        this._willSettleAt(resolve(entry), i);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var promise = this.promise;
	
	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        this._remaining--;
	
	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          this._result[i] = value;
	        }
	      }
	
	      if (this._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, this._result);
	      }
	    };
	
	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;
	
	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;
	
	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }
	
	      var P = local.Promise;
	
	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }
	
	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;
	
	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };
	
	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(7)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }
	
	    lib$es6$promise$polyfill$$default();
	}).call(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), (function() { return this; }()), __webpack_require__(5)(module)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	
	// import open source version of weex-html5
	// var weex = require('weex-html5')
	var weex = __webpack_require__(9)
	
	// extend loader
	var loadByMtop = __webpack_require__(127).loadByMtop
	
	var apis = __webpack_require__(128)
	weex.install(apis)
	
	var components = __webpack_require__(141)
	weex.install(components)
	
	// register loaders
	weex.registerLoader('loadByMtop', loadByMtop)
	
	global.weex = weex
	module.exports = weex
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	
	__webpack_require__(10)
	
	__webpack_require__(14)
	var config = __webpack_require__(16)
	var Loader = __webpack_require__(18)
	var utils = __webpack_require__(17)
	var protocol = __webpack_require__(19)
	var ComponentManager = __webpack_require__(20)
	var Component = __webpack_require__(27)
	var Sender = __webpack_require__(31)
	var receiver = __webpack_require__(32)
	
	// Components and apis.
	var components = __webpack_require__(33)
	var api = __webpack_require__(92)
	__webpack_require__(126)
	__webpack_require__(104)
	
	var WEAPP_STYLE_ID = 'weapp-style'
	
	var DEFAULT_DESIGN_WIDTH = 750
	var DEFAULT_SCALE = window.innerWidth / DEFAULT_DESIGN_WIDTH
	var DEFAULT_ROOT_ID = 'weex'
	var DEFAULT_JSONP_CALLBACK_NAME = 'weexJsonpCallback'
	
	window.WXEnvironment = {
	  weexVersion: config.weexVersion,
	  appName: lib.env.aliapp ? lib.env.aliapp.appname : null,
	  appVersion: lib.env.aliapp ? lib.env.aliapp.version.val : null,
	  platform: 'Web',
	  osName: lib.env.browser ? lib.env.browser.name : null,
	  osVersion: lib.env.browser ? lib.env.browser.version.val : null,
	  deviceWidth: DEFAULT_DESIGN_WIDTH,
	  deviceHeight: window.innerHeight / DEFAULT_SCALE
	}
	
	var _instanceMap = {}
	var _downgrades = {}
	
	var downgradable = ['list', 'scroller']
	
	; (function initializeWithUrlParams() {
	
	  var params = lib.httpurl(location.href).params
	  for (var k in params) {
	    // Get global _downgrades from url's params.
	    var match = k.match(/downgrade_(\w+)/)
	    if (!match || !match[1]) {
	      continue
	    }
	    if (params[k] !== true && params[k] !== 'true') {
	      continue
	    }
	    var downk = match[1]
	    if (downk && (downgradable.indexOf(downk) !== -1)) {
	      _downgrades[downk] = true
	    }
	  }
	
	  // set global 'debug' config to true if there's a debug flag in current url.
	  var debug = params['debug']
	  if (debug === true || debug === 'true') {
	    config.debug = true
	  }
	
	})()
	
	__webpack_require__(15).init()
	
	function Weex(options) {
	
	  if (!(this instanceof Weex)) {
	    return new Weex(options)
	  }
	
	  // Width of the root container. Default is window.innerWidth.
	  this.width = options.width || window.innerWidth
	  this.bundleUrl = options.bundleUrl || location.href
	  this.instanceId = options.appId
	  this.rootId = options.rootId || (DEFAULT_ROOT_ID + utils.getRandom(10))
	  this.designWidth = options.designWidth || DEFAULT_DESIGN_WIDTH
	  this.jsonpCallback = options.jsonpCallback || DEFAULT_JSONP_CALLBACK_NAME
	  this.source = options.source
	  this.loader = options.loader
	  this.embed = options.embed ? true : false
	
	  this.data = options.data
	
	  this.initDowngrades(options.downgrade)
	  this.initScale()
	  this.initComponentManager()
	  this.initBridge()
	  Weex.addInstance(this)
	
	  protocol.injectWeexInstance(this)
	
	  this.loadBundle(function (err, appCode) {
	    if (!err) {
	      this.createApp(config, appCode)
	    } else {
	      console.error('load bundle err:', err)
	    }
	  }.bind(this))
	
	}
	
	Weex.init = function (options) {
	  if (utils.isArray(options)) {
	    options.forEach(function (config) {
	      new Weex(config)
	    })
	  } else if (
	      Object.prototype.toString.call(options).slice(8, -1) === 'Object'
	    ) {
	    new Weex(options)
	  }
	}
	
	Weex.addInstance = function (instance) {
	  _instanceMap[instance.instanceId] = instance
	}
	
	Weex.getInstance = function (instanceId) {
	  return _instanceMap[instanceId]
	}
	
	Weex.prototype = {
	
	  initDowngrades: function (dg) {
	    this.downgrades = utils.extend({}, _downgrades)
	    // Get downgrade component type from user's specification
	    // in weex's init options.
	    if (!utils.isArray(dg)) {
	      return
	    }
	    for (var i = 0, l = dg.length; i < l; i++) {
	      var downk = dg[i]
	      if (downgradable.indexOf(downk) !== -1) {
	        this.downgrades[downk] = true
	      }
	    }
	  },
	
	  initBridge: function () {
	    receiver.init(this)
	    this.sender = new Sender(this)
	  },
	
	  loadBundle: function (cb) {
	    Loader.load({
	      jsonpCallback: this.jsonpCallback,
	      source: this.source,
	      loader: this.loader
	    }, cb)
	  },
	
	  createApp: function (config, appCode) {
	    var root = document.querySelector('#' + this.rootId)
	    if (!root) {
	      root = document.createElement('div')
	      root.id = this.rootId
	      document.body.appendChild(root)
	    }
	
	    var promise = window.createInstance(
	      this.instanceId
	      , appCode
	      , {
	        bundleUrl: this.bundleUrl,
	        debug: config.debug
	      }
	      , this.data
	    )
	
	    if (Promise && promise instanceof Promise) {
	      promise.then(function () {
	        // Weex._instances[this.instanceId] = this.root
	      }.bind(this)).catch(function (err) {
	        if (err && config.debug) {
	          console.error(err)
	        }
	      })
	    }
	
	    // Do not destroy instance here, because in most browser
	    // press back button to back to this page will not refresh
	    // the window and the instance will not be recreated then.
	    // window.addEventListener('beforeunload', function (e) {
	    // })
	
	  },
	
	  initScale: function () {
	    this.scale = this.width / this.designWidth
	  },
	
	  initComponentManager: function () {
	    this._componentManager = new ComponentManager(this)
	  },
	
	  getComponentManager: function () {
	    return this._componentManager
	  },
	
	  getRoot: function () {
	    return document.querySelector('#' + this.rootId)
	  }
	}
	
	Weex.appendStyle = function (css) {
	  utils.appendStyle(css, WEAPP_STYLE_ID)
	},
	
	// Register a new component with the specified name.
	Weex.registerComponent = function (name, comp) {
	  ComponentManager.registerComponent(name, comp)
	},
	
	// Register a new api module.
	// If the module already exists, just add methods from the
	// new module to the old one.
	Weex.registerApiModule = function (name, module, meta) {
	  if (!protocol.apiModule[name]) {
	    protocol.apiModule[name] = module
	  } else {
	    for (var key in module) {
	      if (module.hasOwnProperty(key)) {
	        protocol.apiModule[name][key] = module[key]
	      }
	    }
	  }
	  // register API module's meta info to jsframework
	  if (meta) {
	    protocol.setApiModuleMeta(meta)
	    window.registerModules(protocol.getApiModuleMeta(name), true)
	  }
	},
	
	// Register a new api method for the specified module.
	// opts:
	//  - args: type of arguments the API method takes such
	//    as ['string', 'function']
	Weex.registerApi = function (moduleName, name, method, args) {
	  if (typeof method !== 'function') {
	    return
	  }
	  if (!protocol.apiModule[moduleName]) {
	    protocol.apiModule[moduleName] = {}
	    protocol._meta[moduleName] = []
	  }
	  protocol.apiModule[moduleName][name] = method
	  if (!args) {
	    return
	  }
	  // register API meta info to jsframework
	  protocol.setApiMeta(moduleName, {
	    name: name,
	    args: args
	  })
	  window.registerModules(protocol.getApiModuleMeta(moduleName, meta), true)
	},
	
	// Register a new weex-bundle-loader.
	Weex.registerLoader = function (name, loaderFunc) {
	  Loader.registerLoader(name, loaderFunc)
	}
	
	// To install components and plugins.
	Weex.install = function (mod) {
	  mod.init(Weex)
	}
	
	Weex.stopTheWorld = function () {
	  for (var instanceId in _instanceMap) {
	    if (_instanceMap.hasOwnProperty(instanceId)) {
	      window.destroyInstance(instanceId)
	    }
	  }
	}
	
	(function startRefreshController() {
	  if (location.search.indexOf('hot-reload_controller') === -1)  {
	    return
	  }
	  if (!window.WebSocket) {
	    console.info('auto refresh need WebSocket support')
	    return
	  }
	  var host = location.hostname
	  var port = 8082
	  var client = new WebSocket('ws://' + host + ':' + port + '/',
	    'echo-protocol'
	  )
	  client.onerror = function () {
	    console.log('refresh controller websocket connection error')
	  }
	  client.onmessage = function (e) {
	    console.log('Received: \'' + e.data + '\'')
	    if (e.data  === 'refresh') {
	      location.reload()
	    }
	  }
	}())
	
	// Weex.install(require('weex-components'))
	Weex.install(components)
	Weex.install(api)
	
	Weex.Component = Component
	Weex.ComponentManager = ComponentManager
	Weex.utils = utils
	Weex.config = config
	
	global.weex = Weex
	module.exports = Weex
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(11);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./base.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./base.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, "* {\n  margin: 0;\n  padding: 0;\n  text-size-adjust: none;\n}\n\nul, ol {\n  list-style: none;\n}\n", ""]);
	
	// exports


/***/ },
/* 12 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(15)
	
	if (!window.Promise) {
	  logger.warn('native Promise is missing, using polyfill instead.')
	  __webpack_require__(3)
	}

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var config = __webpack_require__(16)
	var utils = __webpack_require__(17)
	
	var _initialized = false
	
	var logger = {
	  log: function () {},
	  warn: function () {},
	  error: function () {}
	}
	
	function hijack(k) {
	  if (utils.isArray(k)) {
	    k.forEach(function (key) {
	      hijack(key)
	    })
	  } else {
	    if (console[k]) {
	      logger[k] = function () {
	        console[k].apply(
	          console,
	          ['[h5-render]'].concat(Array.prototype.slice.call(arguments, 0))
	        )
	      }
	    }
	  }
	}
	
	logger.init = function () {
	  if (_initialized) {
	    return
	  }
	  _initialized = true
	  if (config.debug && console) {
	    hijack(['log', 'warn', 'error'])
	  }
	}
	
	module.exports = logger

/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict'
	
	var config = {
	
	  weexVersion: '0.5.0',
	
	  debug: false
	
	}
	
	module.exports = config

/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict'
	
	var WEAPP_STYLE_ID = 'weapp-style'
	
	var _isWebpSupported = false
	
	; (function isSupportWebp() {
	  try {
	    var webP = new Image()
	    webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdA'
	              + 'SoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA'
	    webP.onload = function () {
	      if (webP.height === 2) {
	        _isWebpSupported = true
	      }
	    }
	  } catch (e) {
	    // do nothing.
	  }
	})()
	
	function extend(to, from) {
	  for (var key in from) {
	    to[key] = from[key]
	  }
	  return to
	}
	
	function isArray(arr) {
	  return Array.isArray
	    ? Array.isArray(arr)
	    : (Object.prototype.toString.call(arr) === '[object Array]')
	}
	
	function appendStyle(css, styleId, replace) {
	  var style = document.getElementById(styleId)
	  if (style && replace) {
	    style.parentNode.removeChild(style)
	    style = null
	  }
	  if (!style) {
	    style = document.createElement('style')
	    style.type = 'text/css'
	    styleId && (style.id = styleId)
	    document.getElementsByTagName('head')[0].appendChild(style)
	  }
	  style.appendChild(document.createTextNode(css))
	}
	
	function getUniqueFromArray(arr) {
	  if (!isArray(arr)) {
	    return []
	  }
	  var res = []
	  var unique = {}
	  var val
	  for (var i = 0, l = arr.length; i < l; i++) {
	    val = arr[i]
	    if (unique[val]) {
	      continue
	    }
	    unique[val] = true
	    res.push(val)
	  }
	  return res
	}
	
	function transitionize(element, props) {
	  var transitions = []
	  for (var key in props) {
	    transitions.push(key + ' ' + props[key])
	  }
	  element.style.transition = transitions.join(', ')
	  element.style.webkitTransition = transitions.join(', ')
	}
	
	function detectWebp() {
	  return _isWebpSupported
	}
	
	function getRandom(num) {
	  var _defaultNum = 10
	  if (typeof num !== 'number' || num <= 0) {
	    num = _defaultNum
	  }
	  var _max = Math.pow(10, num)
	  return Math.floor(Date.now() + Math.random() * _max) % _max
	}
	
	function getRgb(color) {
	  var match
	  color = color + ''
	  if (match = color.match(/#(\d{2})(\d{2})(\d{2})/)) {
	    return {
	      r: parseInt(match[1], 16),
	      g: parseInt(match[2], 16),
	      b: parseInt(match[3], 16)
	    }
	  }
	  if (match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/)) {
	    return {
	      r: parseInt(match[1]),
	      g: parseInt(match[2]),
	      b: parseInt(match[3])
	    }
	  }
	}
	
	// direction: 'l' | 'r', default is 'r'
	// num: how many times to loop, should be a positive integer
	function loopArray(arr, num, direction) {
	  if (!isArray(arr)) {
	    return
	  }
	  var isLeft = (direction + '').toLowerCase() === 'l'
	  var len = arr.length
	  num = num % len
	  if (num < 0) {
	    num = -num
	    isLeft = !isLeft
	  }
	  if (num === 0) {
	    return arr
	  }
	  var res, lp, rp
	  if (isLeft) {
	    lp = arr.slice(0, num)
	    rp = arr.slice(num)
	  } else {
	    lp = arr.slice(0, len - num)
	    rp = arr.slice(len - num)
	  }
	  return rp.concat(lp)
	}
	
	// pad a integer number with zeros on the left.
	// example: fillInt(12, 3) -> '012'
	// - num: the number to pad
	// - len: the specified length
	function leftPad(num, len) {
	  if (len <= 0) {
	    return num
	  }
	  var numLen = (num + '').length
	  if (numLen >= len) {
	    return num
	  }
	  return new Array(len - numLen + 1).join('0') + num
	}
	
	// get DateStr with specified separator like '2016-06-03'
	function getDateStr(separator) {
	  var dt = new Date()
	  var y = dt.getFullYear()
	  var m = leftPad(dt.getMonth() + 1, 2)
	  var d = leftPad(dt.getDate(), 2)
	  return [y, m, d].join(separator || '')
	}
	
	module.exports = {
	  extend: extend,
	  isArray: isArray,
	  appendStyle: appendStyle,
	  getUniqueFromArray: getUniqueFromArray,
	  transitionize: transitionize,
	  detectWebp: detectWebp,
	  getRandom: getRandom,
	  getRgb: getRgb,
	  loopArray: loopArray,
	  leftPad: leftPad,
	  getDateStr: getDateStr
	}

/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict'
	
	function loadByXHR(config, callback) {
	  if (!config.source) {
	    callback(new Error('xhr loader: missing config.source.'))
	  }
	  var xhr = new XMLHttpRequest()
	  xhr.open('GET', config.source)
	  xhr.onload = function () {
	    callback(null, this.responseText)
	  }
	  xhr.onerror = function (error) {
	    callback(error)
	  }
	  xhr.send()
	}
	
	function loadByJsonp(config, callback) {
	  if (!config.source) {
	    callback(new Error('jsonp loader: missing config.source.'))
	  }
	  var callbackName = config.jsonpCallback || 'weexJsonpCallback'
	  window[callbackName] = function (code) {
	    if (code) {
	      callback(null, code)
	    } else {
	      callback(new Error('load by jsonp error'))
	    }
	  }
	  var script = document.createElement('script')
	  script.src = decodeURIComponent(config.source)
	  script.type = 'text/javascript'
	  document.body.appendChild(script)
	}
	
	function loadBySourceCode(config, callback) {
	  // src is the jsbundle.
	  // no need to fetch from anywhere.
	  if (config.source) {
	    callback(null, config.source)
	  } else {
	    callback(new Error('source code laoder: missing config.source.'))
	  }
	}
	
	var callbackMap = {
	  xhr: loadByXHR,
	  jsonp: loadByJsonp,
	  source: loadBySourceCode
	}
	
	function load(options, callback) {
	  var loadFn = callbackMap[options.loader]
	  loadFn(options, callback)
	}
	
	function registerLoader(name, loaderFunc) {
	  if (typeof loaderFunc === 'function') {
	    callbackMap[name] = loaderFunc
	  }
	}
	
	module.exports = {
	  load: load,
	  registerLoader: registerLoader
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var extend = __webpack_require__(17).extend
	var isArray = __webpack_require__(17).isArray
	var ComponentManager = __webpack_require__(20)
	
	// for jsframework to register modules.
	var _registerModules = function (config) {
	  if (isArray(config)) {
	    for (var i = 0, l = config.length; i < l; i++) {
	      window.registerModules(config[i])
	    }
	  } else {
	    window.registerModules(config)
	  }
	}
	
	var protocol = {
	
	  // weex instances
	  _instances: {},
	
	  // api meta info
	  _meta: {},
	
	  // Weex.registerApiModule used this to register and access apiModules.
	  apiModule: {},
	
	  injectWeexInstance: function (instance) {
	    this._instances[instance.instanceId] = instance
	  },
	
	  getWeexInstance: function (instanceId) {
	    return this._instances[instanceId]
	  },
	
	  // get the api method meta info array for the module.
	  getApiModuleMeta: function (moduleName) {
	    var metaObj = {}
	    metaObj[moduleName] = this._meta[moduleName]
	    return metaObj
	  },
	
	  // Set meta info for a api module.
	  // If there is a same named api, just replace it.
	  // opts:
	  // - metaObj: meta object like
	  // {
	  //    dom: [{
	  //      name: 'addElement',
	  //      args: ['string', 'object']
	  //    }]
	  // }
	  setApiModuleMeta: function (metaObj) {
	    var moduleName
	    for (var k in metaObj) {
	      if (metaObj.hasOwnProperty(k)) {
	        moduleName = k
	      }
	    }
	    var metaArray = this._meta[moduleName]
	    if (!metaArray) {
	      this._meta[moduleName] = metaObj[moduleName]
	    } else {
	      var nameObj = {}
	      metaObj[moduleName].forEach(function (api) {
	        nameObj[api.name] = api
	      })
	      metaArray.forEach(function (api, i) {
	        if (nameObj[api.name]) {
	          metaArray[i] = nameObj[api.name]
	          delete nameObj[api.name]
	        }
	      })
	      for (var k in metaObj) {
	        if (metaObj.hasOwnProperty(k)) {
	          metaArray.push(metaObj[k])
	        }
	      }
	    }
	    this._meta[moduleName] = metaObj[moduleName]
	  },
	
	  // Set meta info for a single api.
	  // opts:
	  //  - moduleName: api module name.
	  //  - meta: a meta object like:
	  //  {
	  //    name: 'addElement',
	  //    args: ['string', 'object']
	  //  }
	  setApiMeta: function (moduleName, meta) {
	    var metaArray = this._meta[moduleName]
	    if (!metaArray) {
	      this._meta[moduleName] = [meta]
	    } else {
	      var metaIdx = -1
	      metaArray.forEach(function (api, i) {
	        if (meta.name === name) {
	          metaIdx = i
	        }
	      })
	      if (metaIdx !== -1) {
	        metaArray[metaIdx] = meta
	      } else {
	        metaArray.push(meta)
	      }
	    }
	  }
	}
	
	_registerModules([{
	  modal: [{
	    name: 'toast',
	    args: ['object', 'function']
	  }, {
	    name: 'alert',
	    args: ['object', 'function']
	  }, {
	    name: 'confirm',
	    args: ['object', 'function']
	  }, {
	    name: 'prompt',
	    args: ['object', 'function']
	  }]
	}, {
	  animation: [{
	    name: 'transition',
	    args: ['string', 'object', 'function']
	  }]
	}])
	
	module.exports = protocol


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var config = __webpack_require__(16)
	var FrameUpdater = __webpack_require__(21)
	var AppearWatcher = __webpack_require__(22)
	var utils = __webpack_require__(17)
	var LazyLoad = __webpack_require__(23)
	var animation = __webpack_require__(26)
	
	var RENDERING_INDENT = 800
	
	var _instanceMap = {}
	var typeMap = {}
	var scrollableTypes = [
	  'scroller',
	  'hscroller',
	  'vscroller',
	  'list',
	  'hlist',
	  'vlist'
	]
	
	function ComponentManager(instance) {
	  this.instanceId = instance.instanceId
	  this.weexInstance = instance
	  this.componentMap = {}
	  _instanceMap[this.instanceId] = this
	}
	
	ComponentManager.getInstance = function (instanceId) {
	  return _instanceMap[instanceId]
	}
	
	ComponentManager.getWeexInstance = function (instanceId) {
	  return _instanceMap[instanceId].weexInstance
	}
	
	ComponentManager.registerComponent = function (type, definition) {
	  typeMap[type] = definition
	}
	
	ComponentManager.getScrollableTypes = function () {
	  return scrollableTypes
	}
	
	ComponentManager.prototype = {
	
	  // Fire a event 'renderbegin'/'renderend' on body element.
	  rendering: function () {
	    function _renderingEnd() {
	      // get weex instance root
	      window.dispatchEvent(new Event('renderend'))
	      this._renderingTimer = null
	    }
	    if (this._renderingTimer) {
	      clearTimeout(this._renderingTimer)
	      this._renderingTimer = setTimeout(
	        _renderingEnd.bind(this),
	        RENDERING_INDENT
	      )
	    } else {
	      window.dispatchEvent(new Event('renderbegin'))
	      this._renderingTimer = setTimeout(
	        _renderingEnd.bind(this),
	        RENDERING_INDENT
	      )
	    }
	  },
	
	  getElementByRef: function (ref) {
	    return this.componentMap[ref]
	  },
	
	  removeElementByRef: function (ref) {
	    var cmp
	    var self = this
	    if (!ref || !(cmp = this.componentMap[ref])) {
	      return
	    }
	    // remove from this.componentMap cursively
	    (function _removeCursively(_ref) {
	      var child = self.componentMap[_ref]
	      var listeners = child._listeners
	      var children = child.data.children
	      if (children && children.length) {
	        for (var i = 0, l = children.length; i < l; i++) {
	          _removeCursively(children[i].ref)
	        }
	      }
	      // remove events from _ref component
	      if (listeners) {
	        for (var type in listeners) {
	          child.node.removeEventListener(type, listeners[type])
	        }
	      }
	      delete child._listeners
	      delete child.node._listeners
	      // remove _ref component
	      delete self.componentMap[_ref]
	    })(ref)
	
	  },
	
	  createElement: function (data, nodeType) {
	    var ComponentType = typeMap[data.type]
	    if (!ComponentType) {
	      ComponentType = typeMap['container']
	    }
	
	    var ref = data.ref
	    var component = new ComponentType(data, nodeType)
	
	    this.componentMap[ref] = component
	    component.node.setAttribute('data-ref', ref)
	
	    return component
	  },
	
	  /**
	   * createBody: generate root component
	   * @param  {object} element
	   */
	  createBody: function (element) {
	
	    // TODO: creatbody on document.body
	    // no need to create a extra div
	    var root, body, nodeType
	    if (this.componentMap['_root']) {
	      return
	    }
	
	    nodeType = element.type
	    element.type = 'root'
	    element.rootId = this.weexInstance.rootId
	    element.ref = '_root'
	
	    var root = this.createElement(element, nodeType)
	    body = document.querySelector('#' + this.weexInstance.rootId)
	          || document.body
	    body.appendChild(root.node)
	    root._appended = true
	  },
	
	  appendChild: function (parentRef, data) {
	    var parent = this.componentMap[parentRef]
	
	    if (this.componentMap[data.ref] || !parent) {
	      return
	    }
	
	    if (parentRef === '_root' && !parent) {
	      parent = this.createElement({
	        type: 'root',
	        rootId: this.weexInstance.rootId,
	        ref: '_root'
	      })
	      parent._appended = true
	    }
	
	    var child = parent.appendChild(data)
	
	    // In some parent component the implementation of method
	    // appendChild didn't return the component at all, therefor
	    // child maybe a undefined object.
	    if (child) {
	      child.parentRef = parentRef
	    }
	
	    if (child && parent._appended) {
	      this.handleAppend(child)
	    }
	  },
	
	  appendChildren: function (ref, elements) {
	    for (var i = 0; i < elements.length; i++) {
	      this.appendChild(ref, elements[i])
	    }
	  },
	
	  removeElement: function (ref) {
	    var component = this.componentMap[ref]
	
	    // fire event for rendering dom on body elment.
	    this.rendering()
	
	    if (component && component.parentRef) {
	      var parent = this.componentMap[component.parentRef]
	      component.onRemove && component.onRemove()
	      parent.removeChild(component)
	    } else {
	      console.warn('ref: ', ref)
	    }
	  },
	
	  moveElement: function (ref, parentRef, index) {
	    var component = this.componentMap[ref]
	    var newParent = this.componentMap[parentRef]
	    var oldParentRef = component.parentRef
	    var children, before, i, l
	    if (!component || !newParent) {
	      console.warn('ref: ', ref)
	      return
	    }
	
	    // fire event for rendering.
	    this.rendering()
	
	    if (index < -1) {
	      index = -1
	      console.warn('index cannot be less than -1.')
	    }
	
	    children = newParent.data.children
	    if (children
	        && children.length
	        && index !== -1
	        && index < children.length) {
	      before = this.componentMap[newParent.data.children[index].ref]
	    }
	
	    // remove from oldParent.data.children
	    if (oldParentRef && this.componentMap[oldParentRef]) {
	      children = this.componentMap[oldParentRef].data.children
	      if (children && children.length) {
	        for (i = 0, l = children.length; i < l; i++) {
	          if (children[i].ref === ref) {
	            break
	          }
	        }
	        if (l > i) {
	          children.splice(i, 1)
	        }
	      }
	    }
	
	    newParent.insertBefore(component, before)
	
	    component.onMove && component.onMove(parentRef, index)
	
	  },
	
	  insertBefore: function (ref, data) {
	    var child, before, parent
	    before = this.componentMap[ref]
	    child = this.componentMap[data.ref]
	    before && (parent = this.componentMap[before.parentRef])
	    if (child || !parent || !before) {
	      return
	    }
	
	    child = this.createElement(data)
	    if (child) {
	      child.parentRef = before.parentRef
	      parent.insertBefore(child, before)
	    } else {
	      return
	    }
	
	    if (this.componentMap[before.parentRef]._appended) {
	      this.handleAppend(child)
	    }
	  },
	
	  /**
	   * addElement
	   * If index is larget than any child's index, the
	   * element will be appended behind.
	   * @param {string} parentRef
	   * @param {obj} element (data of the component)
	   * @param {number} index
	   */
	  addElement: function (parentRef, element, index) {
	    var parent, children, before
	
	    // fire event for rendering dom on body elment.
	    this.rendering()
	
	    parent = this.componentMap[parentRef]
	    if (!parent) {
	      return
	    }
	    children = parent.data.children
	    // -1 means append as the last.
	    if (index < -1) {
	      index = -1
	      console.warn('index cannot be less than -1.')
	    }
	    if (children && children.length
	        && children.length > index
	        && index !== -1) {
	      this.insertBefore(children[index].ref, element)
	    } else {
	      this.appendChild(parentRef, element)
	    }
	  },
	
	  clearChildren: function (ref) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.node.innerHTML = ''
	      if (component.data) {
	        component.data.children = null
	      }
	    }
	  },
	
	  addEvent: function (ref, type) {
	    var component
	    if (typeof ref === 'string' || typeof ref === 'number') {
	      component = this.componentMap[ref]
	    } else if (Object.prototype.toString.call(ref).slice(8, -1) === 'Object') {
	      component = ref
	      ref = component.data.ref
	    }
	    if (component && component.node) {
	      var sender = this.weexInstance.sender
	      var listener = sender.fireEvent.bind(sender, ref, type)
	      var listeners = component._listeners
	      component.node.addEventListener(type, listener, false, false)
	      if (!listeners) {
	        listeners = component._listeners = {}
	        component.node._listeners = {}
	      }
	      listeners[type] = listener
	      component.node._listeners[type] = listener
	    }
	  },
	
	  removeEvent: function (ref, type) {
	    var component = this.componentMap[ref]
	    var listener = component._listeners[type]
	    if (component && listener) {
	      component.node.removeEventListener(type, listener)
	      component._listeners[type] = null
	      component.node._listeners[type] = null
	    }
	  },
	
	  updateAttrs: function (ref, attr) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.updateAttrs(attr)
	      if (component.data.type === 'image' && attr.src) {
	        LazyLoad.startIfNeeded(component)
	      }
	    }
	  },
	
	  updateStyle: function (ref, style) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.updateStyle(style)
	    }
	  },
	
	  updateFullAttrs: function (ref, attr) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.clearAttr()
	      component.updateAttrs(attr)
	      if (component.data.type === 'image' && attr.src) {
	        LazyLoad.startIfNeeded(component)
	      }
	    }
	  },
	
	  updateFullStyle: function (ref, style) {
	    var component = this.componentMap[ref]
	    if (component) {
	      component.clearStyle()
	      component.updateStyle(style)
	    }
	  },
	
	  handleAppend: function (component) {
	    component._appended = true
	    component.onAppend && component.onAppend()
	
	    // invoke onAppend on children recursively
	    var children = component.data.children
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = this.componentMap[children[i].ref]
	        if (child) {
	          this.handleAppend(child)
	        }
	      }
	    }
	
	    // watch appear/disappear of the component if needed
	    AppearWatcher.watchIfNeeded(component)
	
	    // do lazyload if needed
	    LazyLoad.startIfNeeded(component)
	  },
	
	  transition: function (ref, config, callback) {
	    var component = this.componentMap[ref]
	    animation.transitionOnce(component, config, callback)
	  },
	
	  renderFinish: function () {
	    FrameUpdater.pause()
	  }
	}
	
	module.exports = ComponentManager


/***/ },
/* 21 */
/***/ function(module, exports) {

	'use strict'
	
	var raf = window.requestAnimationFrame ||
	          window.webkitRequestAnimationFrame ||
	          function (calllback) {
	            setTimeout(calllback, 16)
	          }
	
	var rafId
	var observers = []
	var paused = false
	
	var FrameUpdater = {
	  start: function () {
	    if (rafId) {
	      return
	    }
	
	    rafId = raf(function runLoop() {
	      if (!paused) {
	        for (var i = 0; i < observers.length; i++) {
	          observers[i]()
	        }
	        raf(runLoop)
	      }
	    })
	  },
	
	  isActive: function () {
	    return !paused
	  },
	
	  pause: function () {
	    paused = true
	    rafId = undefined
	  },
	
	  resume: function () {
	    paused = false
	    this.start()
	  },
	
	  addUpdateObserver: function (observeMethod) {
	    observers.push(observeMethod)
	  }
	}
	
	module.exports = FrameUpdater


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var utils = __webpack_require__(17)
	
	var componentsInScroller = []
	var componentsOutOfScroller = []
	var listened = false
	var direction = 'up'
	var scrollY = 0
	
	var AppearWatcher = {
	  watchIfNeeded: function (component) {
	    if (needWatch(component)) {
	      if (component.isInScrollable()) {
	        componentsInScroller.push(component)
	      } else {
	        componentsOutOfScroller.push(component)
	      }
	      if (!listened) {
	        listened = true
	        // var handler = throttle(onScroll, 25)
	        var handler = throttle(onScroll, 100)
	        window.addEventListener('scroll', handler, false)
	      }
	    }
	  }
	}
	
	function needWatch(component) {
	  var events = component.data.event
	  if (events
	      && (events.indexOf('appear') != -1
	        || events.indexOf('disappear') != -1)) {
	    return true
	  }
	  return false
	}
	
	function onScroll(e) {
	  // If the scroll event is dispatched from a scrollable component
	  // implemented through scrollerjs, then the appear/disappear events
	  // should be treated specially by handleScrollerScroll.
	  if (e.originalType === 'scrolling') {
	    handleScrollerScroll(e)
	  } else {
	    handleWindowScroll()
	  }
	}
	
	function handleScrollerScroll(e) {
	  var cmps = componentsInScroller
	  var len = cmps.length
	  direction = e.direction
	  for (var i = 0; i < len; i++) {
	    var component = cmps[i]
	    var appear = isComponentInScrollerAppear(component)
	    if (appear && !component._appear) {
	      component._appear = true
	      fireEvent(component, 'appear')
	    } else if (!appear && component._appear) {
	      component._appear = false
	      fireEvent(component, 'disappear')
	    }
	  }
	}
	
	function handleWindowScroll() {
	  var y = window.scrollY
	  direction = y >= scrollY ? 'up' : 'down'
	  scrollY = y
	
	  var len = componentsOutOfScroller.length
	  if (len === 0) {
	    return
	  }
	  for (var i = 0; i < len; i++) {
	    var component = componentsOutOfScroller[i]
	    var appear = isComponentInWindow(component)
	    if (appear && !component._appear) {
	      component._appear = true
	      fireEvent(component, 'appear')
	    } else if (!appear && component._appear) {
	      component._appear = false
	      fireEvent(component, 'disappear')
	    }
	  }
	}
	
	function isComponentInScrollerAppear(component) {
	  var parentScroller = component._parentScroller
	  var cmpRect = component.node.getBoundingClientRect()
	  if (!isComponentInWindow(component)) {
	    return false
	  }
	  while (parentScroller) {
	    var parentRect = parentScroller.node.getBoundingClientRect()
	    if (!(cmpRect.right > parentRect.left
	        && cmpRect.left < parentRect.right
	        && cmpRect.bottom > parentRect.top
	        && cmpRect.top < parentRect.bottom)) {
	      return false
	    }
	    parentScroller = parentScroller._parentScroller
	  }
	  return true
	}
	
	function isComponentInWindow(component) {
	  var rect = component.node.getBoundingClientRect()
	  return rect.right > 0 && rect.left < window.innerWidth &&
	         rect.bottom > 0 && rect.top < window.innerHeight
	}
	
	function fireEvent(component, type) {
	  var evt = document.createEvent('HTMLEvents')
	  var data = { direction: direction }
	  evt.initEvent(type, false, false)
	  evt.data = data
	  utils.extend(evt, data)
	  component.node.dispatchEvent(evt)
	}
	
	function throttle(func, wait) {
	  var context, args, result
	  var timeout = null
	  var previous = 0
	  var later = function () {
	    previous = Date.now()
	    timeout = null
	    result = func.apply(context, args)
	  }
	  return function () {
	    var now = Date.now()
	    var remaining = wait - (now - previous)
	    context = this
	    args = arguments
	    if (remaining <= 0) {
	      clearTimeout(timeout)
	      timeout = null
	      previous = now
	      result = func.apply(context, args)
	    } else if (!timeout) {
	      timeout = setTimeout(later, remaining)
	    }
	    return result
	  }
	}
	
	module.exports = AppearWatcher

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(24)
	
	var lazyloadTimer
	
	var LazyLoad = {
	  makeImageLazy: function (image, src) {
	    image.removeAttribute('img-src')
	    image.removeAttribute('i-lazy-src')
	    image.removeAttribute('src')
	    image.setAttribute('img-src', src)
	    // should replace 'src' with 'img-src'. but for now lib.img.fire is
	    // not working for the situation that the appear event has been
	    // already triggered.
	    // image.setAttribute('src', src)
	    // image.setAttribute('img-src', src)
	    this.fire()
	  },
	
	  // we don't know when all image are appended
	  // just use setTimeout to do delay lazyload
	  //
	  // -- actually everytime we add a element or update styles,
	  // the component manager will call startIfNeed to fire
	  // lazyload once again in the handleAppend function. so there
	  // is no way that any image element can miss it. See source
	  // code in componentMangager.js.
	  startIfNeeded: function (component) {
	    var that = this
	    if (component.data.type === 'image') {
	      if (!lazyloadTimer) {
	        lazyloadTimer = setTimeout(function () {
	          that.fire()
	          clearTimeout(lazyloadTimer)
	          lazyloadTimer = null
	        }, 16)
	      }
	    }
	  },
	
	  loadIfNeeded: function (elementScope) {
	    var notPreProcessed = elementScope.querySelectorAll('[img-src]')
	    var that = this
	    // image elements which have attribute 'i-lazy-src' were elements
	    // that had been preprocessed by lib-img-core, but not loaded yet, and
	    // must be loaded when 'appear' events were fired. It turns out the
	    // 'appear' event was not fired correctly in the css-translate-transition
	    // situation, so 'i-lazy-src' must be checked and lazyload must be
	    // fired manually.
	    var preProcessed = elementScope.querySelectorAll('[i-lazy-src]')
	    if (notPreProcessed.length > 0 || preProcessed.length > 0) {
	      that.fire()
	    }
	  },
	
	  // fire lazyload.
	  fire: function () {
	    lib.img.fire()
	  }
	
	}
	
	module.exports = LazyLoad


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"undefined"==typeof window&&(window={ctrl:{},lib:{}}),!window.ctrl&&(window.ctrl={}),!window.lib&&(window.lib={}),function(t,i){function e(t,i){i&&("IMG"==t.nodeName.toUpperCase()?t.setAttribute("src",i):t.style.backgroundImage='url("'+i+'")')}function a(){r=i.appear.init({cls:"imgtmp",once:!0,x:o.lazyWidth,y:o.lazyHeight,onAppear:function(t){var i=this;e(i,i.getAttribute("i-lazy-src")),i.removeAttribute("i-lazy-src")}})}__webpack_require__(25);var r,A={},o={dataSrc:"img-src",lazyHeight:0,lazyWidth:0};A.logConfig=function(){console.log("lib-img Config\n",o)},A.fire=function(){r||a();var t="i_"+Date.now()%1e5,i=document.querySelectorAll("["+o.dataSrc+"]");[].forEach.call(i,function(i){"false"==i.dataset.lazy&&"true"!=i.dataset.lazy?e(i,processSrc(i,i.getAttribute(o.dataSrc))):(i.classList.add(t),i.setAttribute("i-lazy-src",i.getAttribute(o.dataSrc))),i.removeAttribute(o.dataSrc)}),r.bind("."+t),r.fire()},A.defaultSrc="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==",i.img=A,module.exports=A}(window,window.lib||(window.lib={}));

/***/ },
/* 25 */
/***/ function(module, exports) {

	"undefined"==typeof window&&(window={ctrl:{},lib:{}}),!window.ctrl&&(window.ctrl={}),!window.lib&&(window.lib={}),function(n,e){function i(){d=w.createEvent("HTMLEvents"),v=w.createEvent("HTMLEvents"),d.initEvent("_appear",!1,!0),v.initEvent("_disappear",!1,!0)}function a(t,n){var e,i,a,s=(Date.now(),0),o=null,r=function(){s=Date.now(),o=null,t.apply(e,i)};return function(){var l=Date.now();e=this,i=arguments;var c=n-(l-s);return 0>=c||c>=n?(clearTimeout(o),o=null,a=t.apply(e,i)):null==o&&(o=setTimeout(r,c)),a}}function s(n,e){var n,i,a,s;if(n)return e||(e={x:0,y:0}),n!=window?(n=n.getBoundingClientRect(),i=n.left,t=n.top,a=n.right,s=n.bottom):(i=0,t=0,a=i+n.innerWidth,s=t+n.innerHeight),{left:i,top:t,right:a+e.x,bottom:s+e.y}}function o(t,n){var e=n.right>t.left&&n.left<t.right,i=n.bottom>t.top&&n.top<t.bottom;return e&&i}function r(t,n){var e="none",i=t.left-n.left,a=t.top-n.top;return 0==a&&(e=0!=i?i>0?"left":"right":"none"),0==i&&(e=0!=a?a>0?"up":"down":"none"),e}function l(t,n){for(var e in n)n.hasOwnProperty(e)&&(t[e]=n[e]);return t}function c(){var t=this,n=a(function(){f.apply(t,arguments)},this.options.wait);this.__handle&&(this.container.removeEventListener("scroll",this.__handle),this.__handle=null),this.__handle=n,this.container.addEventListener("scroll",n,!1),this.container.addEventListener("resize",function(n){f.apply(t,arguments)},!1),this.container.addEventListener("animationEnd",function(){f.apply(t,arguments)},!1),this.container.addEventListener("webkitAnimationEnd",function(){f.apply(t,arguments)},!1),this.container.addEventListener("transitionend",function(){f.apply(t,arguments)},!1)}function p(t){var n=this,e=this.options.container;if("string"==typeof e?this.container=w.querySelector(e):this.container=e,this.container==window)var i=w.querySelectorAll(t);else var i=this.container.querySelectorAll(t);var i=[].slice.call(i,null);return i=i.filter(function(t){return"1"==t.dataset.bind?(delete t._hasAppear,delete t._hasDisAppear,delete t._appear,t.classList.remove(n.options.cls),!1):!0})}function h(t){var n=this;t&&t.length>0&&[].forEach.call(t,function(t){t._eleOffset=s(t),t.classList.remove(n.options.cls),t.dataset.bind=1})}function f(){var t=this.container,n=this.appearWatchElements,e=this.options.onAppear,i=this.options.onDisappear,a=s(t,{x:this.options.x,y:this.options.y}),l=this.options.once,c=arguments[0]||{};n&&n.length>0&&[].forEach.call(n,function(t,n){var p=s(t),h=r(t._eleOffset,p);t._eleOffset=p;var f=o(a,p),u=t._appear,w=t._hasAppear,E=t._hasDisAppear;d.data={direction:h},v.data={direction:h},f&&!u?(l&&!w||!l)&&(e&&e.call(t,c),t.dispatchEvent(d),t._hasAppear=!0,t._appear=!0):!f&&u&&(l&&!E||!l)&&(i&&i.call(t,c),t.dispatchEvent(v),t._hasDisAppear=!0,t._appear=!1)})}function u(t){l(this.options,t||(t={})),this.appearWatchElements=this.appearWatchElements||p.call(this,"."+this.options.cls),h.call(this,this.appearWatchElements),c.call(this)}var d,v,w=document,E=function(){u.apply(this,arguments)},_={instances:[],init:function(t){var n={options:{container:window,wait:100,x:0,y:0,cls:"lib-appear",once:!1,onReset:function(){},onAppear:function(){},onDisappear:function(){}},container:null,appearWatchElements:null,bind:function(t){var n=this.options.cls;if("string"==typeof t){var e=p.call(this,t);[].forEach.call(e,function(t,e){t.classList.contains(n)||t.classList.add(n)})}else{if(1!=t.nodeType||!this.container.contains(t))return this;t.classList.contains(n)||t.classList.add(n)}var i=p.call(this,"."+this.options.cls);return this.appearWatchElements=this.appearWatchElements.concat(i),h.call(this,i),this},reset:function(t){return u.call(this,t),this.appearWatchElements.forEach(function(t){delete t._hasAppear,delete t._hasDisAppear,delete t._appear}),this},fire:function(){this.appearWatchElements||(this.appearWatchElements=[]);var t=p.call(this,"."+this.options.cls);return this.appearWatchElements=this.appearWatchElements.concat(t),h.call(this,t),f.call(this),this}};E.prototype=n;var e=new E(t);return this.instances.push(e),e},fireAll:function(){var t=this.instances;t.forEach(function(t){t.fire()})}};i(),e.appear=_}(window,window.lib||(window.lib={}));

/***/ },
/* 26 */
/***/ function(module, exports) {

	'use strict'
	
	module.exports = {
	
	  /**
	   * config:
	   *   - styles
	   *   - duration [Number] milliseconds(ms)
	   *   - timingFunction [string]
	   *   - dealy [Number] milliseconds(ms)
	   */
	  transitionOnce: function (comp, config, callback) {
	    var styles = config.styles || {}
	    var duration = config.duration || 1000 // ms
	    var timingFunction = config.timingFunction || 'ease'
	    var delay = config.delay || 0  // ms
	    var transitionValue = 'all ' + duration + 'ms '
	        + timingFunction + ' ' + delay + 'ms'
	    var dom = comp.node
	    var transitionEndHandler = function (e) {
	      e.stopPropagation()
	      dom.removeEventListener('webkitTransitionEnd', transitionEndHandler)
	      dom.removeEventListener('transitionend', transitionEndHandler)
	      dom.style.transition = ''
	      dom.style.webkitTransition = ''
	      callback()
	    }
	    dom.style.transition = transitionValue
	    dom.style.webkitTransition = transitionValue
	    dom.addEventListener('webkitTransitionEnd', transitionEndHandler)
	    dom.addEventListener('transitionend', transitionEndHandler)
	    comp.updateStyle(styles)
	  }
	
	}

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var config = __webpack_require__(16)
	var utils = __webpack_require__(17)
	var ComponentManager = __webpack_require__(20)
	var flexbox = __webpack_require__(28)
	var valueFilter = __webpack_require__(29)
	__webpack_require__(30)
	
	function Component(data, nodeType) {
	  this.data = data
	  this.node = this.create(nodeType)
	
	  this.createChildren()
	  this.updateAttrs(this.data.attr)
	  // issue: when add element to a list in lifetime hook 'ready', the
	  // styles is set to the classStyle, not style. This is a issue
	  // that jsframework should do something about.
	  var classStyle = this.data.classStyle
	  classStyle && this.updateStyle(this.data.classStyle)
	  this.updateStyle(this.data.style)
	  this.bindEvents(this.data.event)
	}
	
	Component.prototype = {
	
	  create: function (nodeType) {
	    var node = document.createElement(nodeType || 'div')
	    return node
	  },
	
	  getComponentManager: function () {
	    return ComponentManager.getInstance(this.data.instanceId)
	  },
	
	  getParent: function () {
	    return this.getComponentManager().componentMap[this.parentRef]
	  },
	
	  getParentScroller: function () {
	    if (this.isInScrollable()) {
	      return this._parentScroller
	    }
	    return null
	  },
	
	  getRootScroller: function () {
	    if (this.isInScrollable()) {
	      var scroller = this._parentScroller
	      var parent = scroller._parentScroller
	      while (parent) {
	        scroller = parent
	        parent = scroller._parentScroller
	      }
	      return scroller
	    }
	    return null
	  },
	
	  getRootContainer: function () {
	    var root = this.getComponentManager().weexInstance.getRoot()
	      || document.body
	    return root
	  },
	
	  isScrollable: function () {
	    var t = this.data.type
	    return ComponentManager.getScrollableTypes().indexOf(t) !== -1
	  },
	
	  isInScrollable: function () {
	    if (typeof this._isInScrollable === 'boolean') {
	      return this._isInScrollable
	    }
	    var parent = this.getParent()
	    if (parent
	        && (typeof parent._isInScrollable !== 'boolean')
	        && !parent.isScrollable()) {
	      if (parent.data.ref === '_root') {
	        this._isInScrollable = false
	        return false
	      }
	      this._isInScrollable = parent.isInScrollable()
	      this._parentScroller = parent._parentScroller
	      return this._isInScrollable
	    }
	    if (parent && typeof parent._isInScrollable === 'boolean') {
	      this._isInScrollable = parent._isInScrollable
	      this._parentScroller = parent._parentScroller
	      return this._isInScrollable
	    }
	    if (parent && parent.isScrollable()) {
	      this._isInScrollable = true
	      this._parentScroller = parent
	      return true
	    }
	    if (!parent) {
	      console && console.error('isInScrollable - parent not exist.')
	      return
	    }
	  },
	
	  createChildren: function () {
	    var children = this.data.children
	    var parentRef = this.data.ref
	    var componentManager = this.getComponentManager()
	    if (children && children.length) {
	      var fragment = document.createDocumentFragment()
	      var isFlex = false
	      for (var i = 0; i < children.length; i++) {
	        children[i].instanceId = this.data.instanceId
	        children[i].scale = this.data.scale
	        var child = componentManager.createElement(children[i])
	        fragment.appendChild(child.node)
	        child.parentRef = parentRef
	        if (!isFlex
	            && child.data.style
	            && child.data.style.hasOwnProperty('flex')
	          ) {
	          isFlex = true
	        }
	      }
	      this.node.appendChild(fragment)
	    }
	  },
	
	  // @todo: changed param data to child
	  appendChild: function (data) {
	    var children = this.data.children
	    var componentManager = this.getComponentManager()
	    var child = componentManager.createElement(data)
	    this.node.appendChild(child.node)
	    // update this.data.children
	    if (!children || !children.length) {
	      this.data.children = [data]
	    } else {
	      children.push(data)
	    }
	
	    return child
	  },
	
	  insertBefore: function (child, before) {
	    var children = this.data.children
	    var i = 0
	    var l
	    var isAppend = false
	
	    // update this.data.children
	    if (!children || !children.length || !before) {
	      isAppend = true
	    } else {
	      for (l = children.length; i < l; i++) {
	        if (children[i].ref === before.data.ref) {
	          break
	        }
	      }
	      if (i === l) {
	        isAppend = true
	      }
	    }
	
	    if (isAppend) {
	      this.node.appendChild(child.node)
	      children.push(child.data)
	    } else {
	      if (before.fixedPlaceholder) {
	        this.node.insertBefore(child.node, before.fixedPlaceholder)
	      } else {
	        this.node.insertBefore(child.node, before.node)
	      }
	      children.splice(i, 0, child.data)
	    }
	
	  },
	
	  removeChild: function (child) {
	    var children = this.data.children
	    // remove from this.data.children
	    var i = 0
	    var componentManager = this.getComponentManager()
	    if (children && children.length) {
	      for (var l = children.length; i < l; i++) {
	        if (children[i].ref === child.data.ref) {
	          break
	        }
	      }
	      if (i < l) {
	        children.splice(i, 1)
	      }
	    }
	    // remove from componentMap recursively
	    componentManager.removeElementByRef(child.data.ref)
	    if (child.fixedPlaceholder) {
	      this.node.removeChild(child.fixedPlaceholder)
	    }
	    child.node.parentNode.removeChild(child.node)
	  },
	
	  updateAttrs: function (attrs) {
	    // Note：attr must be injected into the dom element because
	    // it will be accessed from the outside developer by event.target.attr.
	    if (!this.node.attr) {
	      this.node.attr = {}
	    }
	    for (var key in attrs) {
	      var value = attrs[key]
	      var attrSetter = this.attr[key]
	      if (typeof attrSetter === 'function') {
	        attrSetter.call(this, value)
	      } else {
	        if (typeof value === 'boolean') {
	          this.node[key] = value
	        } else {
	          this.node.setAttribute(key, value)
	        }
	        this.node.attr[key] = value
	      }
	    }
	  },
	
	  updateStyle: function (style) {
	
	    for (var key in style) {
	      var value = style[key]
	      var styleSetter = this.style[key]
	      if (typeof styleSetter === 'function') {
	        styleSetter.call(this, value)
	        continue
	      }
	      var parser = valueFilter.getFilters(key,
	          { scale: this.data.scale })[typeof value]
	      if (typeof parser === 'function') {
	        value = parser(value)
	      }
	      this.node.style[key] = value
	    }
	  },
	
	  bindEvents: function (evts) {
	    var componentManager = this.getComponentManager()
	    if (evts
	        && Object.prototype.toString.call(evts).slice(8, -1) === 'Array'
	      ) {
	      for (var i = 0, l = evts.length; i < l; i++) {
	        componentManager.addEvent(this, evts[i])
	      }
	    }
	  },
	
	  // dispatch a specified event on this.node
	  //  - type: event type
	  //  - data: event data
	  //  - config: event config object
	  //     - bubbles
	  //     - cancelable
	  dispatchEvent: function (type, data, config) {
	    var event = document.createEvent('HTMLEvents')
	    config = config || {}
	    event.initEvent(type, config.bubbles || false, config.cancelable || false)
	    !data && (data = {})
	    event.data = utils.extend({}, data)
	    utils.extend(event, data)
	    this.node.dispatchEvent(event)
	  },
	
	  updateRecursiveAttr: function (data) {
	    this.updateAttrs(data.attr)
	    var componentManager = this.getComponentManager()
	    var children = this.data.children
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = componentManager.getElementByRef(children[i].ref)
	        if (child) {
	          child.updateRecursiveAttr(data.children[i])
	        }
	      }
	    }
	  },
	
	  updateRecursiveStyle: function (data) {
	    this.updateStyle(data.style)
	    var componentManager = this.getComponentManager()
	    var children = this.data.children
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = componentManager.getElementByRef(children[i].ref)
	        if (child) {
	          child.updateRecursiveStyle(data.children[i])
	        }
	      }
	    }
	  },
	
	  updateRecursiveAll: function (data) {
	    this.updateAttrs(data.attr)
	    this.updateStyle(data.style)
	    var componentManager = this.getComponentManager()
	
	    // var oldRef = this.data.ref
	    // if (componentMap[oldRef]) {
	    //   delete componentMap[oldRef]
	    // }
	    // this.data.ref = data.ref
	    // componentMap[data.ref] = this
	
	    var children = this.data.children
	    if (children) {
	      for (var i = 0; i < children.length; i++) {
	        var child = componentManager.getElementByRef(children[i].ref)
	        if (child) {
	          child.updateRecursiveAll(data.children[i])
	        }
	      }
	    }
	  },
	
	  attr: {}, // attr setters
	
	  style: Object.create(flexbox), // style setters
	
	  clearAttr: function () {
	  },
	
	  clearStyle: function () {
	    this.node.cssText = ''
	  }
	}
	
	Component.prototype.style.position = function (value) {
	
	  // For the elements who are fixed elements before, now
	  // are not fixed: the fixedPlaceholder has to be replaced
	  // by this element.
	  // This is a peace of hacking to fix the problem about
	  // mixing fixed and transform. See 'http://stackoverflo
	  // w.com/questions/15194313/webkit-css-transform3d-posi
	  // tion-fixed-issue' for more info.
	  if (value !== 'fixed') {
	    if (this.fixedPlaceholder) {
	      var parent = this.fixedPlaceholder.parentNode
	      parent.insertBefore(this.node, this.fixedPlaceholder)
	      parent.removeChild(this.fixedPlaceholder)
	      this.fixedPlaceholder = null
	    }
	  } else { // value === 'fixed'
	    // For the elements who are fixed: this fixedPlaceholder
	    // shoud be inserted, and the fixed element itself should
	    // be placed out in root container.
	    this.node.style.position = 'fixed'
	    var parent = this.node.parentNode
	    var replaceWithFixedPlaceholder = function () {
	      this.fixedPlaceholder = document.createElement('div')
	      this.fixedPlaceholder.classList.add('weex-fixed-placeholder')
	      this.fixedPlaceholder.style.display = 'none'
	      this.fixedPlaceholder.style.width = '0px'
	      this.fixedPlaceholder.style.height = '0px'
	      parent.insertBefore(this.fixedPlaceholder, this.node)
	      this.getRootContainer().appendChild(this.node)
	    }.bind(this)
	    if (!parent) {
	      if (this.onAppend) {
	        var pre = this.onAppend.bind(this)
	      }
	      this.onAppend = function () {
	        parent = this.node.parentNode
	        replaceWithFixedPlaceholder()
	        pre && pre()
	      }.bind(this)
	    } else {
	      replaceWithFixedPlaceholder()
	    }
	    return
	  }
	
	  if (value === 'sticky') {
	    this.node.style.zIndex = 100
	    setTimeout(function () {
	      this.sticky = new lib.sticky(this.node, {
	        top: 0
	      })
	    }.bind(this), 0)
	  } else {
	    this.node.style.position = value
	  }
	}
	
	module.exports = Component
	
	
	


/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict'
	
	// Flexbox polyfill
	var flexboxSetters = (function () {
	  var BOX_ALIGN = {
	    stretch: 'stretch',
	    'flex-start': 'start',
	    'flex-end': 'end',
	    center: 'center'
	  }
	  var BOX_ORIENT = {
	    row: 'horizontal',
	    column: 'vertical'
	  }
	  var BOX_PACK = {
	    'flex-start': 'start',
	    'flex-end': 'end',
	    center: 'center',
	    'space-between': 'justify',
	    'space-around': 'justify' // Just same as `space-between`
	  }
	  return {
	    flex: function (value) {
	      this.node.style.webkitBoxFlex = value
	      this.node.style.webkitFlex = value
	      this.node.style.flex = value
	    },
	    alignItems: function (value) {
	      this.node.style.webkitBoxAlign = BOX_ALIGN[value]
	      this.node.style.webkitAlignItems = value
	      this.node.style.alignItems = value
	    },
	    alignSelf: function (value) {
	      this.node.style.webkitAlignSelf = value
	      this.node.style.alignSelf = value
	    },
	    flexDirection: function (value) {
	      this.node.style.webkitBoxOrient = BOX_ORIENT[value]
	      this.node.style.webkitFlexDirection = value
	      this.node.style.flexDirection = value
	    },
	    justifyContent: function (value) {
	      this.node.style.webkitBoxPack = BOX_PACK[value]
	      this.node.style.webkitJustifyContent = value
	      this.node.style.justifyContent = value
	    }
	  }
	})()
	
	module.exports = flexboxSetters


/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict'
	
	var NOT_PX_NUMBER_PROPERTIES = ['flex', 'opacity', 'zIndex', 'fontWeight']
	
	var valueFilter = {
	
	  filterStyles: function (styles, config) {
	    for (var key in styles) {
	      var value = styles[key]
	      var parser = this.getFilters(key, config)[typeof value]
	      if (typeof parser === 'function') {
	        styles[key] = parser(value)
	      }
	    }
	  },
	
	  getFilters: function (key, config) {
	
	    if (NOT_PX_NUMBER_PROPERTIES.indexOf(key) !== -1) {
	      return {}
	    }
	    return {
	      number: function (val) {
	        return val * config.scale + 'px'
	      },
	      string: function (val) {
	        // string of a pure number or a number suffixed with a 'px' unit
	        if (val.match(/^\-?\d*\.?\d+(?:px)?$/)) {
	          return parseFloat(val) * config.scale + 'px'
	        }
	        if (key.match(/transform/) && val.match(/translate/)) {
	          return val.replace(/\d*\.?\d+px/g, function (match) {
	            return parseInt(parseFloat(match) * config.scale) + 'px'
	          })
	        }
	        return val
	      }
	    }
	  }
	}
	
	module.exports = valueFilter


/***/ },
/* 30 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b,c){function d(a){return null!=a&&"object"==typeof a&&Object.getPrototypeOf(a)==Object.prototype}function e(a,b){var c,d,e,f=null,g=0,h=function(){g=Date.now(),f=null,e=a.apply(c,d)};return function(){var i=Date.now(),j=b-(i-g);return c=this,d=arguments,0>=j?(clearTimeout(f),f=null,g=i,e=a.apply(c,d)):f||(f=setTimeout(h,j)),e}}function f(a){var b="";return Object.keys(a).forEach(function(c){b+=c+":"+a[c]+";"}),b}function g(a,c){!c&&d(a)&&(c=a,a=c.element),c=c||{},a.nodeType!=b.ELEMENT_NODE&&"string"==typeof a&&(a=b.querySelector(a));var e=this;e.element=a,e.top=c.top||0,e.withinParent=void 0==c.withinParent?!1:c.withinParent,e.init()}var h=a.parseInt,i=navigator.userAgent,j=!!i.match(/Firefox/i),k=!!i.match(/IEMobile/i),l=j?"-moz-":k?"-ms-":"-webkit-",m=j?"Moz":k?"ms":"webkit",n=function(){var a=b.createElement("div"),c=a.style;return c.cssText="position:"+l+"sticky;position:sticky;",-1!=c.position.indexOf("sticky")}();g.prototype={constructor:g,init:function(){var a=this,b=a.element,c=b.style;c[m+"Transform"]="translateZ(0)",c.transform="translateZ(0)",a._originCssText=c.cssText,n?(c.position=l+"sticky",c.position="sticky",c.top=a.top+"px"):(a._simulateSticky(),a._bindResize())},_bindResize:function(){var b=this,c=/android/gi.test(navigator.appVersion),d=b._resizeEvent="onorientationchange"in a?"orientationchange":"resize",e=b._resizeHandler=function(){setTimeout(function(){b.refresh()},c?200:0)};a.addEventListener(d,e,!1)},refresh:function(){var a=this;n||(a._detach(),a._simulateSticky())},_addPlaceholder:function(a){var c,d=this,e=d.element,g=a.position;if(-1!=["static","relative"].indexOf(g)){c=d._placeholderElement=b.createElement("div");var i=h(a.width)+h(a.marginLeft)+h(a.marginRight),j=h(a.height);"border-box"!=a.boxSizing&&(i+=h(a.borderLeftWidth)+h(a.borderRightWidth)+h(a.paddingLeft)+h(a.paddingRight),j+=h(a.borderTopWidth)+h(a.borderBottomWidth)+h(a.paddingTop)+h(a.paddingBottom)),c.style.cssText=f({display:"none",visibility:"hidden",width:i+"px",height:j+"px",margin:0,"margin-top":a.marginTop,"margin-bottom":a.marginBottom,border:0,padding:0,"float":a["float"]||a.cssFloat}),e.parentNode.insertBefore(c,e)}return c},_simulateSticky:function(){var c=this,d=c.element,g=c.top,i=d.style,j=d.getBoundingClientRect(),k=getComputedStyle(d,""),l=d.parentNode,m=getComputedStyle(l,""),n=c._addPlaceholder(k),o=c.withinParent,p=c._originCssText,q=j.top-g+a.pageYOffset,r=l.getBoundingClientRect().bottom-h(m.paddingBottom)-h(m.borderBottomWidth)-h(k.marginBottom)-j.height-g+a.pageYOffset,s=p+f({position:"fixed",top:g+"px",width:k.width,"margin-top":0}),t=p+f({position:"absolute",top:r+"px",width:k.width}),u=1,v=c._scrollHandler=e(function(){var b=a.pageYOffset;q>b?1!=u&&(i.cssText=p,n&&(n.style.display="none"),u=1):!o&&b>=q||o&&b>=q&&r>b?2!=u&&(i.cssText=s,n&&3!=u&&(n.style.display="block"),u=2):o&&3!=u&&(i.cssText=t,n&&2!=u&&(n.style.display="block"),u=3)},100);if(a.addEventListener("scroll",v,!1),a.pageYOffset>=q){var w=b.createEvent("HTMLEvents");w.initEvent("scroll",!0,!0),a.dispatchEvent(w)}},_detach:function(){var b=this,c=b.element;if(c.style.cssText=b._originCssText,!n){var d=b._placeholderElement;d&&c.parentNode.removeChild(d),a.removeEventListener("scroll",b._scrollHandler,!1)}},destroy:function(){var b=this;b._detach();var c=b.element.style;c.removeProperty(l+"transform"),c.removeProperty("transform"),n||a.removeEventListener(b._resizeEvent,b._resizeHandler,!1)}},c.sticky=g}(window,document,window.lib||(window.lib={}));;module.exports = window.lib['sticky'];

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var utils = __webpack_require__(17)
	
	var _senderMap = {}
	
	function Sender(instance) {
	  if (!(this instanceof Sender)) {
	    return new Sender(instance)
	  }
	  this.instanceId = instance.instanceId
	  this.weexInstance = instance
	  _senderMap[this.instanceId] = this
	}
	
	function _send(instanceId, msg) {
	  callJS(instanceId, [msg])
	}
	
	Sender.getSender = function (instanceId) {
	  return _senderMap[instanceId]
	}
	
	Sender.prototype = {
	
	  // perform a callback to jsframework.
	  performCallback: function (callbackId, data, keepAlive) {
	    var args = [callbackId]
	    data && args.push(data)
	    keepAlive && args.push(keepAlive)
	    _send(this.instanceId, {
	      method: 'callback',
	      args: args
	    })
	  },
	
	  fireEvent: function (ref, type, event) {
	    if (event._alreadyFired) {
	      // stop bubbling up in virtual dom tree.
	      return
	    }
	    // do not prevent default, otherwise the touchstart
	    // event will no longer trigger a click event
	    event._alreadyFired = true
	    var evt = utils.extend({}, event)
	    // The event.target must be the standard event's currentTarget.
	    evt.target = evt.currentTarget
	    evt.value = event.target.value
	    evt.timestamp = Date.now()
	    _send(this.instanceId, {
	      method: 'fireEvent',
	      args: [ref, type, evt]
	    })
	  }
	
	}
	
	module.exports = Sender

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	
	var config = __webpack_require__(16)
	var protocol = __webpack_require__(19)
	var utils = __webpack_require__(17)
	var FrameUpdater = __webpack_require__(21)
	var Sender = __webpack_require__(31)
	
	var callQueue = []
	// Need a task counter?
	// When FrameUpdater is not activated, tasks will not be push
	// into callQueue and there will be no trace for situation of
	// execution of tasks.
	
	// give 10ms for call handling, and rest 6ms for others
	var MAX_TIME_FOR_EACH_FRAME = 10
	
	// callNative: jsFramework will call this method to talk to
	// this renderer.
	// params:
	//  - instanceId: string.
	//  - tasks: array of object.
	//  - callbackId: number.
	function callNative(instanceId, tasks, callbackId) {
	  var calls = []
	  if (typeof tasks === 'string') {
	    try {
	      calls = JSON.parse(tasks)
	    } catch (e) {
	      console.error('invalid tasks:', tasks)
	    }
	  } else if (Object.prototype.toString.call(tasks).slice(8, -1) === 'Array') {
	    calls = tasks
	  }
	  var len = calls.length
	  calls[len - 1].callbackId = (!callbackId && callbackId !== 0)
	                              ? -1
	                              : callbackId
	  // To solve the problem of callapp, the two-way time loop rule must
	  // be replaced by calling directly except the situation of page loading.
	  // 2015-11-03
	  for (var i = 0; i < len; i++) {
	    if (FrameUpdater.isActive()) {
	      callQueue.push({
	        instanceId: instanceId,
	        call: calls[i]
	      })
	    }
	    else {
	      processCall(instanceId, calls[i])
	    }
	  }
	
	}
	
	function processCallQueue() {
	  var len = callQueue.length
	  if (len === 0) {
	    return
	  }
	  var start = Date.now()
	  var elapsed = 0
	
	  while (--len >= 0 && elapsed < MAX_TIME_FOR_EACH_FRAME) {
	    var callObj = callQueue.shift()
	    processCall(callObj.instanceId, callObj.call)
	    elapsed = Date.now() - start
	  }
	}
	
	function processCall(instanceId, call) {
	  var moduleName = call.module
	  var methodName = call.method
	  var module, method
	  var args = call.args || call.arguments || []
	
	  if (!(module = protocol.apiModule[moduleName])) {
	    return
	  }
	  if (!(method = module[methodName])) {
	    return
	  }
	
	  method.apply(protocol.getWeexInstance(instanceId), args)
	
	  var callbackId = call.callbackId
	  if ((callbackId
	    || callbackId === 0
	    || callbackId === '0')
	    && callbackId !== '-1'
	    && callbackId !== -1) {
	    performNextTick(instanceId, callbackId)
	  }
	}
	
	function performNextTick(instanceId, callbackId) {
	  Sender.getSender(instanceId).performCallback(callbackId)
	}
	
	function nativeLog() {
	  if (config.debug) {
	    if (arguments[0].match(/^perf/)) {
	      console.info.apply(console, arguments)
	      return
	    }
	    console.debug.apply(console, arguments)
	  }
	}
	
	function exportsBridgeMethodsToGlobal() {
	  global.callNative = callNative
	  global.nativeLog = nativeLog
	}
	
	module.exports = {
	
	  init: function () {
	
	    // process callQueue every 16 milliseconds.
	    FrameUpdater.addUpdateObserver(processCallQueue)
	    FrameUpdater.start()
	
	    // exports methods to global(window).
	    exportsBridgeMethodsToGlobal()
	  }
	
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var RootComponent = __webpack_require__(34)
	var Container = __webpack_require__(35)
	var Image = __webpack_require__(38)
	var Text = __webpack_require__(42)
	var Vlist = __webpack_require__(43)
	var Hlist = __webpack_require__(49)
	var Countdown = __webpack_require__(50)
	var Marquee = __webpack_require__(52)
	var Slider = __webpack_require__(53)
	var Indicator = __webpack_require__(60)
	var Tabheader = __webpack_require__(63)
	var Scroller = __webpack_require__(67)
	var Input = __webpack_require__(70)
	var Select = __webpack_require__(71)
	var Datepicker = __webpack_require__(72)
	var Timepicker = __webpack_require__(73)
	var Video = __webpack_require__(74)
	var Switch = __webpack_require__(77)
	var A = __webpack_require__(80)
	var Embed = __webpack_require__(81)
	var Refresh = __webpack_require__(82)
	var Loading = __webpack_require__(85)
	var Spinner = __webpack_require__(88)
	var Web = __webpack_require__(91)
	
	var components = {
	  init: function (Weex) {
	    Weex.registerComponent('root', RootComponent)
	    Weex.registerComponent('container', Container)
	    Weex.registerComponent('div', Container)
	    Weex.registerComponent('image', Image)
	    Weex.registerComponent('text', Text)
	    Weex.registerComponent('list', Vlist)
	    Weex.registerComponent('vlist', Vlist)
	    Weex.registerComponent('hlist', Hlist)
	    Weex.registerComponent('countdown', Countdown)
	    Weex.registerComponent('marquee', Marquee)
	    Weex.registerComponent('slider', Slider)
	    Weex.registerComponent('indicator', Indicator)
	    Weex.registerComponent('tabheader', Tabheader)
	    Weex.registerComponent('scroller', Scroller)
	    Weex.registerComponent('input', Input)
	    Weex.registerComponent('select', Select)
	    Weex.registerComponent('datepicker', Datepicker)
	    Weex.registerComponent('timepicker', Timepicker)
	    Weex.registerComponent('video', Video)
	    Weex.registerComponent('switch', Switch)
	    Weex.registerComponent('a', A)
	    Weex.registerComponent('embed', Embed)
	    Weex.registerComponent('refresh', Refresh)
	    Weex.registerComponent('loading', Loading)
	    Weex.registerComponent('spinner', Spinner)
	    Weex.registerComponent('loading-indicator', Spinner)
	    Weex.registerComponent('web', Web)
	  }
	}
	
	module.exports = components


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var ComponentManager = __webpack_require__(20)
	var Component = __webpack_require__(27)
	var utils = __webpack_require__(17)
	var logger = __webpack_require__(15)
	
	var rootCandidates = ['div', 'list', 'vlist', 'scroller']
	
	function RootComponent(data, nodeType) {
	  var id = data.rootId + '-root'
	  var componentManager = ComponentManager.getInstance(data.instanceId)
	
	  // If nodeType is in the downgrades map, just ignore it and
	  // replace it with a div component.
	  var downgrades = componentManager.weexInstance.downgrades
	  this.data = data
	
	  // In some situation the root component should be implemented as
	  // its own type, otherwise it has to be a div component as a root.
	  if (!nodeType) {
	    nodeType = 'div'
	  } else if (rootCandidates.indexOf(nodeType) === -1) {
	    logger.warn('the root component type \'' + nodeType + '\' is not one of '
	      + 'the types in [' + rootCandidates + '] list. It is auto downgraded '
	      + 'to \'div\'.')
	    nodeType = 'div'
	  } else if (downgrades[nodeType]) {
	    logger.warn('Thanks to the downgrade flags for ['
	      + Object.keys(downgrades)
	      + '], the root component type \'' + nodeType
	      + '\' is auto downgraded to \'div\'.')
	    nodeType = 'div'
	  } else {
	    // If the root component is not a embed element in a webpage, then
	    // the html and body height should be fixed to the max height
	    // of viewport.
	    if (!componentManager.weexInstance.embed) {
	      window.addEventListener('renderend', function () {
	        this.detectRootHeight()
	      }.bind(this))
	    }
	    if (nodeType !== 'div') {
	      logger.warn('the root component type \'' + nodeType + '\' may have '
	        + 'some performance issue on some of the android devices when there '
	        + 'is a huge amount of dom elements. Try to add downgrade '
	        + 'flags by adding param \'downgrade_' + nodeType + '=true\' in the '
	        + 'url or setting downgrade config to a array contains \'' + nodeType
	        + '\' in the \'weex.init\' function. This will downgrade the root \''
	        + nodeType + '\' to a \'div\', and may elevate the level of '
	        + 'performance, although it has some other issues.')
	    }
	    !this.data.style.height && (this.data.style.height = '100%')
	  }
	
	  data.type = nodeType
	  var cmp = componentManager.createElement(data)
	  cmp.node.id = id
	  return cmp
	}
	
	RootComponent.prototype = Object.create(Component.prototype)
	
	RootComponent.prototype.detectRootHeight = function () {
	  var rootQuery = '#' + this.getComponentManager().weexInstance.rootId
	  var rootContainer = document.querySelector(rootQuery) || document.body
	  var height = rootContainer.getBoundingClientRect().height
	  if (height > window.innerHeight) {
	    logger.warn([
	      'for scrollable root like \'list\' and \'scroller\', the height of ',
	      'the root container must be a user-specified value. Otherwise ',
	      'the scrollable element may not be able to work correctly. ',
	      'Current height of the root element \'' + rootQuery + '\' is ',
	      height + 'px, and mostly its height should be less than the ',
	      'viewport\'s height ' + window.innerHeight + 'px. Please ',
	      'make sure the height is correct.'
	      ].join(''))
	  }
	}
	
	module.exports = RootComponent


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(36)
	
	var Component = __webpack_require__(27)
	
	function Container (data, nodeType) {
	  Component.call(this, data, nodeType)
	  this.node.classList.add('weex-container')
	}
	
	Container.prototype = Object.create(Component.prototype)
	
	module.exports = Container


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(37);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./container.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./container.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-container {\n  box-sizing: border-box;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n  position: relative;\n  border: 0 solid black;\n  margin: 0;\n  padding: 0;\n}\n\n.weex-element {\n  box-sizing: border-box;\n  position: relative;\n}\n", ""]);
	
	// exports


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	var LazyLoad = __webpack_require__(23)
	var config = __webpack_require__(16)
	var utils = __webpack_require__(17)
	
	__webpack_require__(40)
	
	var DEFAULT_SIZE = 200
	var RESIZE_MODES = ['stretch', 'cover', 'contain']
	var DEFAULT_RESIZE_MODE = 'stretch'
	
	/**
	 * resize: 'cover' | 'contain' | 'stretch', default is 'stretch'
	 * src: url
	 */
	
	function Image (data) {
	  this.resize = DEFAULT_RESIZE_MODE
	  Atomic.call(this, data)
	}
	
	Image.prototype = Object.create(Atomic.prototype)
	
	Image.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-img')
	  return node
	}
	
	Image.prototype.attr = {
	  src: function (val) {
	    if (!this.src) {
	      this.src = lib.img.defaultSrc
	      this.node.style.backgroundImage = 'url(' + this.src + ')'
	    }
	    LazyLoad.makeImageLazy(this.node, val)
	  },
	
	  resize: function (val) {
	    if (RESIZE_MODES.indexOf(val) === -1) {
	      val = 'stretch'
	    }
	    this.node.style.backgroundSize = val === 'stretch'
	                                    ? '100% 100%'
	                                    : val
	  }
	}
	
	Image.prototype.style = utils.extend(Object.create(Atomic.prototype.style), {
	  width: function (val) {
	    val = parseFloat(val) * this.data.scale
	    if (val < 0 || val !== val) {
	      val = DEFAULT_SIZE
	    }
	    this.node.style.width = val + 'px'
	  },
	
	  height: function (val) {
	    val = parseFloat(val) * this.data.scale
	    if (val < 0 || val !== val) {
	      val = DEFAULT_SIZE
	    }
	    this.node.style.height = val + 'px'
	  }
	})
	
	Image.prototype.clearAttr = function () {
	  this.src = ''
	  this.node.style.backgroundImage = ''
	}
	
	module.exports = Image


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Component = __webpack_require__(27)
	
	// Component which can have no subcomponents.
	// This component should not be instantiated directly, since
	// it is designed to be used as a base class to extend from.
	function Atomic (data) {
	  Component.call(this, data)
	}
	
	Atomic.prototype = Object.create(Component.prototype)
	
	Atomic.prototype.appendChild = function (data) {
	  // do nothing
	  return
	}
	
	Atomic.prototype.insertBefore = function (child, before) {
	  // do nothing
	  return
	}
	
	Atomic.prototype.removeChild = function (child) {
	  // do nothing
	  return
	}
	
	module.exports = Atomic


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(41);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./image.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./image.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-img {\n\tbox-sizing: border-box;\n  position: relative;\n  background-repeat: no-repeat;\n  background-size: 100% 100%;\n  background-position: 50%;\n  border: 0 solid black;\n}", ""]);
	
	// exports


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(27)
	var utils = __webpack_require__(17)
	
	var DEFAULT_FONT_SIZE = 32
	var DEFAULT_TEXT_OVERFLOW = 'ellipsis'
	
	// attr
	//  - value: text content.
	//  - lines: maximum lines of the text.
	function Text (data) {
	  Atomic.call(this, data)
	}
	
	Text.prototype = Object.create(Atomic.prototype)
	
	Text.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container')
	  node.style.fontSize = DEFAULT_FONT_SIZE * this.data.scale + 'px'
	  this.textNode = document.createElement('span')
	  // Give the developers the ability to control space
	  // and line-breakers.
	  this.textNode.style.whiteSpace = 'pre-wrap'
	  this.textNode.style.display = '-webkit-box'
	  this.textNode.style.webkitBoxOrient = 'vertical'
	  this.style.lines.call(this, this.data.style.lines)
	  node.appendChild(this.textNode)
	  return node
	}
	
	Text.prototype.attr = {
	  value: function (value) {
	    var span = this.node.firstChild
	    span.innerHTML = ''
	    if (value == null || value === '') {
	      return
	    }
	    span.textContent = value
	    /**
	     * Developers are supposed to have the ability to break text
	     * lines manually. Using ``&nbsp;`` to replace text space is
	     * not compatible with the ``-webkit-line-clamp``. Therefor
	     * we use ``white-space: no-wrap`` instead (instead of the
	     * code bellow).
	
	      var frag = document.createDocumentFragment()
	        text.split(' ').forEach(function(str) {
	          var textNode = document.createTextNode(str)
	          var space = document.createElement('i')
	          space.innerHTML = '&nbsp;'
	          frag.appendChild(space)
	          frag.appendChild(textNode)
	        })
	        frag.removeChild(frag.firstChild)
	        span.appendChild(document.createElement('br'))
	        span.appendChild(frag)
	      })
	      span.removeChild(span.firstChild)
	     */
	  }
	}
	
	Text.prototype.clearAttr = function () {
	  this.node.firstChild.textContent = ''
	}
	
	Text.prototype.style = utils.extend(Object.create(Atomic.prototype.style), {
	
	  lines: function (val) {
	    val = parseInt(val)
	    if (val !== val) { // NaN
	      return
	    }
	    if (val <= 0) {
	      this.textNode.style.textOverflow = ''
	      this.textNode.style.overflow = 'visible'
	      this.textNode.style.webkitLineClamp = ''
	    } else {
	      var style = this.data ? this.data.style : null
	      this.textNode.style.overflow = 'hidden'
	      this.textNode.style.textOverflow = style
	        ? style.textOverflow
	        : DEFAULT_TEXT_OVERFLOW
	      this.textNode.style.webkitLineClamp = val
	    }
	  },
	
	  textOverflow: function (val) {
	    this.textNode.style.textOverflow = val
	  }
	
	})
	
	module.exports = Text


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(44)
	
	function Vlist(data, nodeType) {
	  data.attr.direction = 'v'
	  List.call(this, data, nodeType)
	}
	
	Vlist.prototype = Object.create(List.prototype)
	
	module.exports = Vlist

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(45)
	__webpack_require__(47)
	
	var Component = __webpack_require__(27)
	var LazyLoad = __webpack_require__(23)
	
	var DEFAULT_LOAD_MORE_OFFSET = 500
	
	var directionMap = {
	  h: ['row', 'horizontal', 'h', 'x'],
	  v: ['column', 'vertical', 'v', 'y']
	}
	
	// direction: 'v' or 'h', default is 'v'
	function List(data, nodeType) {
	  // this.loadmoreOffset = Number(data.attr.loadmoreoffset)
	  // this.isAvailableToFireloadmore = true
	  this.direction = directionMap.h.indexOf(data.attr.direction) === -1
	    ? 'v'
	    : 'h'
	  Component.call(this, data, nodeType)
	}
	
	List.prototype = Object.create(Component.prototype)
	
	List.prototype.create = function (nodeType) {
	  var Scroll = lib.scroll
	  var node = Component.prototype.create.call(this, nodeType)
	  node.classList.add('weex-container', 'list-wrap')
	  this.listElement = document.createElement('div')
	  this.listElement.classList.add(
	    'weex-container'
	    , 'list-element'
	    , this.direction + '-list'
	  )
	
	  // Flex will cause a bug to rescale children's size if their total
	  // size exceed the limit of their parent. So to use box instead.
	  this.listElement.style.display = '-webkit-box'
	  this.listElement.style.display = 'box'
	  this.listElement.style.webkitBoxOrient = this.direction === 'h'
	    ? 'horizontal'
	    : 'vertical'
	  this.listElement.style.boxOrient = this.listElement.style.webkitBoxOrient
	
	  node.appendChild(this.listElement)
	  this.scroller = new Scroll({
	    scrollElement: this.listElement
	    , direction: this.direction === 'h' ? 'x' : 'y'
	  })
	  this.scroller.init()
	  this.offset = 0
	  return node
	}
	
	List.prototype.bindEvents = function (evts) {
	  Component.prototype.bindEvents.call(this, evts)
	  // to enable lazyload for Images.
	  this.scroller.addEventListener('scrolling', function (e) {
	    var so = e.scrollObj
	    var scrollTop = so.getScrollTop()
	    var scrollLeft = so.getScrollLeft()
	    var offset = this.direction === 'v' ? scrollTop : scrollLeft
	    var diff = offset - this.offset
	    var dir
	    if (diff >= 0) {
	      dir = this.direction === 'v' ? 'up' : 'left'
	    } else {
	      dir = this.direction === 'v' ? 'down' : 'right'
	    }
	    this.dispatchEvent('scroll', {
	      originalType: 'scrolling',
	      scrollTop: so.getScrollTop(),
	      scrollLeft: so.getScrollLeft(),
	      offset: offset,
	      direction: dir
	    }, {
	      bubbles: true
	    })
	    this.offset = offset
	  }.bind(this))
	
	  var pullendEvent = 'pull' + ({ v: 'up', h: 'left' })[this.direction] + 'end'
	  this.scroller.addEventListener(pullendEvent, function (e) {
	    this.dispatchEvent('loadmore')
	  }.bind(this))
	}
	
	List.prototype.createChildren = function () {
	  var children = this.data.children
	  var parentRef = this.data.ref
	  var componentManager = this.getComponentManager()
	  if (children && children.length) {
	    var fragment = document.createDocumentFragment()
	    var isFlex = false
	    for (var i = 0; i < children.length; i++) {
	      children[i].instanceId = this.data.instanceId
	      children[i].scale = this.data.scale
	      var child = componentManager.createElement(children[i])
	      fragment.appendChild(child.node)
	      child.parentRef = parentRef
	      if (!isFlex
	          && child.data.style
	          && child.data.style.hasOwnProperty('flex')
	        ) {
	        isFlex = true
	      }
	    }
	    this.listElement.appendChild(fragment)
	  }
	  // wait for fragment to appended on listElement on UI thread.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	List.prototype.appendChild = function (data) {
	  var children = this.data.children
	  var componentManager = this.getComponentManager()
	  var child = componentManager.createElement(data)
	  this.listElement.appendChild(child.node)
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	
	  // update this.data.children
	  if (!children || !children.length) {
	    this.data.children = [data]
	  } else {
	    children.push(data)
	  }
	
	  return child
	}
	
	List.prototype.insertBefore = function (child, before) {
	  var children = this.data.children
	  var i = 0
	  var isAppend = false
	
	  // update this.data.children
	  if (!children || !children.length || !before) {
	    isAppend = true
	  } else {
	    for (var l = children.length; i < l; i++) {
	      if (children[i].ref === before.data.ref) {
	        break
	      }
	    }
	    if (i === l) {
	      isAppend = true
	    }
	  }
	
	  if (isAppend) {
	    this.listElement.appendChild(child.node)
	    children.push(child.data)
	  } else {
	    if (before.fixedPlaceholder) {
	      this.listElement.insertBefore(child.node, before.fixedPlaceholder)
	    } else {
	      this.listElement.insertBefore(child.node, before.node)
	    }
	    children.splice(i, 0, child.data)
	  }
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	List.prototype.removeChild = function (child) {
	  var children = this.data.children
	  // remove from this.data.children
	  var i = 0
	  var componentManager = this.getComponentManager()
	  if (children && children.length) {
	    for (var l = children.length; i < l; i++) {
	      if (children[i].ref === child.data.ref) {
	        break
	      }
	    }
	    if (i < l) {
	      children.splice(i, 1)
	    }
	  }
	  // remove from componentMap recursively
	  componentManager.removeElementByRef(child.data.ref)
	  if (child.fixedPlaceholder) {
	    this.listElement.removeChild(child.fixedPlaceholder)
	  }
	  child.node.parentNode.removeChild(child.node)
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	module.exports = List


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(46);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./list.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./list.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".list-wrap {\n  display: block;\n  overflow: hidden;\n}\n\n.list-element {\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(48)
	
	var logger = __webpack_require__(15)
	
	var doc = window.document
	var ua = window.navigator.userAgent
	var scrollObjs = {}
	var plugins = {}
	var dpr = window.dpr
	  || (!!window.navigator.userAgent.match(/iPhone|iPad|iPod/)
	    ? document.documentElement.clientWidth / window.screen.availWidth
	    : 1)
	var inertiaCoefficient = {
	  normal: [2 * dpr, 0.0015 * dpr],
	  slow: [1.5 * dpr, 0.003 * dpr],
	  veryslow: [1.5 * dpr, 0.005 * dpr]
	}
	var timeFunction = {
	  ease: [.25,.1,.25,1],
	  liner: [0,0,1,1],
	  'ease-in': [.42,0,1,1],
	  'ease-out': [0,0,.58,1],
	  'ease-in-out': [.42,0,.58,1]
	}
	var Firefox = !!ua.match(/Firefox/i)
	var IEMobile = !!ua.match(/IEMobile/i)
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-'
	var stylePrefix = Firefox ? 'Moz' : IEMobile ? 'ms' : 'webkit'
	
	function debugLog() {
	  if (lib.scroll.outputDebugLog) {
	    logger.log.apply(logger, arguments)
	  }
	}
	
	function getBoundingClientRect(el) {
	  var rect = el.getBoundingClientRect()
	  if (!rect) {
	    rect = {}
	    rect.width = el.offsetWidth
	    rect.height = el.offsetHeight
	
	    rect.left = el.offsetLeft
	    rect.top = el.offsetTop
	    var parent = el.offsetParent
	    while (parent) {
	      rect.left += parent.offsetLeft
	      rect.top += parent.offsetTop
	      parent = parent.offsetParent
	    }
	
	    rect.right = rect.left + rect.width
	    rect.bottom = rect.top + rect.height
	  }
	  return rect
	}
	
	function getMinScrollOffset(scrollObj) {
	  return 0 - scrollObj.options[scrollObj.axis + 'PaddingTop']
	}
	
	function getMaxScrollOffset(scrollObj) {
	  var rect = getBoundingClientRect(scrollObj.element)
	  var pRect = getBoundingClientRect(scrollObj.viewport)
	  var min = getMinScrollOffset(scrollObj)
	  if (scrollObj.axis === 'y') {
	    var max = 0 - rect.height + pRect.height
	  } else {
	    var max = 0 - rect.width + pRect.width
	  }
	  return Math.min(
	    max + scrollObj.options[scrollObj.axis + 'PaddingBottom'],
	    min
	  )
	}
	
	function getBoundaryOffset(scrollObj, offset) {
	  if (offset > scrollObj.minScrollOffset) {
	    return offset - scrollObj.minScrollOffset
	  }
	  if (offset < scrollObj.maxScrollOffset) {
	    return offset - scrollObj.maxScrollOffset
	  }
	}
	
	function touchBoundary(scrollObj, offset) {
	  if (offset > scrollObj.minScrollOffset) {
	    offset = scrollObj.minScrollOffset
	  } else if (offset < scrollObj.maxScrollOffset) {
	    offset = scrollObj.maxScrollOffset
	  }
	  return offset
	}
	
	function fireEvent(scrollObj, eventName, extra) {
	  debugLog(scrollObj.element.scrollId, eventName, extra)
	  var event = doc.createEvent('HTMLEvents')
	  event.initEvent(eventName, false, true)
	  event.scrollObj = scrollObj
	  if (extra) {
	    for (var key in extra) {
	      event[key] = extra[key]
	    }
	  }
	  scrollObj.element.dispatchEvent(event)
	  scrollObj.viewport.dispatchEvent(event)
	}
	
	function getTransformOffset(scrollObj) {
	  var offset = {x: 0, y: 0}
	  var transform = getComputedStyle(scrollObj.element)
	    [stylePrefix + 'Transform']
	  var matched
	  var reg1 = new RegExp('^matrix3d'
	    + '\\((?:[-\\d.]+,\\s*){12}([-\\d.]+),'
	    + '\\s*([-\\d.]+)(?:,\\s*[-\\d.]+){2}\\)')
	  var reg2 = new RegExp('^matrix'
	    + '\\((?:[-\\d.]+,\\s*){4}([-\\d.]+),\\s*([-\\d.]+)\\)$')
	  if (transform !== 'none') {
	    if ((matched = transform.match(reg1) ||
	        transform.match(reg2))) {
	      offset.x = parseFloat(matched[1]) || 0
	      offset.y = parseFloat(matched[2]) || 0
	    }
	  }
	
	  return offset
	}
	
	var CSSMatrix = IEMobile ? 'MSCSSMatrix' : 'WebKitCSSMatrix'
	var has3d = !!Firefox
	  || CSSMatrix in window
	  && 'm11' in new window[CSSMatrix]()
	function getTranslate(x, y) {
	  x = parseFloat(x)
	  y = parseFloat(y)
	
	  if (x != 0) {
	    x += 'px'
	  }
	
	  if (y != 0) {
	    y += 'px'
	  }
	
	  if (has3d) {
	    return 'translate3d(' + x + ', ' + y + ', 0)'
	  }
	  return 'translate(' + x + ', ' + y + ')'
	}
	
	function setTransitionStyle(scrollObj, duration, timingFunction) {
	  if (duration === '' && timingFunction === '') {
	    scrollObj.element.style[stylePrefix + 'Transition'] = ''
	  } else {
	    scrollObj.element.style[stylePrefix + 'Transition']
	      = cssPrefix + 'transform ' + duration + ' ' + timingFunction + ' 0s'
	  }
	}
	
	function setTransformStyle(scrollObj, offset) {
	  var x = 0
	  var y = 0
	  if (typeof offset === 'object') {
	    x = offset.x
	    y = offset.y
	  } else {
	    if (scrollObj.axis === 'y') {
	      y = offset
	    } else {
	      x = offset
	    }
	  }
	  scrollObj.element.style[stylePrefix + 'Transform'] = getTranslate(x, y)
	}
	
	var panning = false
	doc.addEventListener('touchmove', function (e) {
	  if (panning) {
	    e.preventDefault()
	    return false
	  }
	  return true
	}, false)
	
	function Scroll(element, options) {
	  var that = this
	
	  options = options || {}
	  options.noBounce = !!options.noBounce
	  options.padding = options.padding || {}
	
	  if (options.isPrevent == null) {
	    options.isPrevent = true
	  } else {
	    options.isPrevent = !!options.isPrevent
	  }
	
	  if (options.isFixScrollendClick == null) {
	    options.isFixScrollendClick = true
	  } else {
	    options.isFixScrollendClick = !!options.isFixScrollendClick
	  }
	
	  if (options.padding) {
	    options.yPaddingTop = -options.padding.top || 0
	    options.yPaddingBottom = -options.padding.bottom || 0
	    options.xPaddingTop = -options.padding.left || 0
	    options.xPaddingBottom = -options.padding.right || 0
	  } else {
	    options.yPaddingTop = 0
	    options.yPaddingBottom = 0
	    options.xPaddingTop = 0
	    options.xPaddingBottom = 0
	  }
	
	  options.direction = options.direction || 'y'
	  options.inertia = options.inertia || 'normal'
	
	  this.options = options
	  that.axis = options.direction
	  this.element = element
	  this.viewport = element.parentNode
	  this.plugins = {}
	
	  this.element.scrollId = setTimeout(function () {
	    scrollObjs[that.element.scrollId + ''] = that
	  }, 1)
	
	  this.viewport.addEventListener('touchstart', touchstartHandler, false)
	  this.viewport.addEventListener('touchend', touchendHandler, false)
	  this.viewport.addEventListener('touchcancel', touchendHandler, false)
	  this.viewport.addEventListener('panstart', panstartHandler, false)
	  this.viewport.addEventListener('panmove', panHandler, false)
	  this.viewport.addEventListener('panend', panendHandler, false)
	
	  if (options.isPrevent) {
	    this.viewport.addEventListener('touchstart', function (e) {
	      panning = true
	    }, false)
	    that.viewport.addEventListener('touchend', function (e) {
	      panning = false
	    }, false)
	  }
	
	  // if (options.isPrevent) {
	  //   var d = this.axis === 'y'?'vertical':'horizontal'
	  //   this.viewport.addEventListener(d + 'panstart', function (e) {
	  //     panning = true
	  //   }, false)
	  //   that.viewport.addEventListener('panend', function (e) {
	  //     panning = false
	  //   }, false)
	  // }
	
	  if (options.isFixScrollendClick) {
	    var preventScrollendClick
	    var fixScrollendClickTimeoutId
	
	    this.viewport.addEventListener('scrolling', function () {
	      preventScrollendClick = true
	      fixScrollendClickTimeoutId && clearTimeout(fixScrollendClickTimeoutId)
	      fixScrollendClickTimeoutId = setTimeout(function (e) {
	        preventScrollendClick = false
	      }, 400)
	    }, false)
	
	    function preventScrollendClickHandler(e) {
	      if (preventScrollendClick || isScrolling) {
	        e.preventDefault()
	        e.stopPropagation()
	        return false
	      }
	      return true
	    }
	
	    function fireNiceTapEventHandler(e) {
	      if (!preventScrollendClick && !isScrolling) {
	        setTimeout(function () {
	          var niceTapEvent = document.createEvent('HTMLEvents')
	          niceTapEvent.initEvent('niceclick', true, true)
	          e.target.dispatchEvent(niceTapEvent)
	        }, 300)
	      }
	    }
	
	    this.viewport.addEventListener('click', preventScrollendClickHandler)
	    this.viewport.addEventListener('tap', fireNiceTapEventHandler)
	  }
	
	  if (options.useFrameAnimation) {
	    var scrollAnimation
	
	    Object.defineProperty(this, 'animation', {
	      get: function () {
	        return scrollAnimation
	      }
	    })
	  } else {
	    var transitionEndHandler
	    var transitionEndTimeoutId = 0
	
	    function setTransitionEndHandler(h, t) {
	      transitionEndHandler = null
	      clearTimeout(transitionEndTimeoutId)
	
	      transitionEndTimeoutId = setTimeout(function () {
	        if (transitionEndHandler) {
	          transitionEndHandler = null
	          lib.animation.requestFrame(h)
	        }
	      }, (t || 400))
	
	      transitionEndHandler = h
	    }
	
	    element.addEventListener(
	        Firefox
	          ? 'transitionend'
	          : (stylePrefix + 'TransitionEnd'), function (e) {
	      if (transitionEndHandler) {
	        var handler = transitionEndHandler
	
	        transitionEndHandler = null
	        clearTimeout(transitionEndTimeoutId)
	
	        lib.animation.requestFrame(function () {
	          handler(e)
	        })
	      }
	    }, false)
	  }
	
	  var panFixRatio
	  var isScrolling
	  var isFlickScrolling
	  var cancelScrollEnd
	
	  Object.defineProperty(this, 'isScrolling', {
	    get: function () {
	      return !!isScrolling
	    }
	  })
	
	  function isEnabled(e) {
	    if (!that.enabled) {
	      return false
	    }
	
	    if (typeof e.isVertical != 'undefined') {
	      if (that.axis === 'y' && e.isVertical
	          || that.axis === 'x' && !e.isVertical) {
	        // gesture in same direction, stop bubbling up
	        e.stopPropagation()
	      } else {
	        // gesture in different direction, bubbling up
	        // to the top, without any other process
	        return false
	      }
	    }
	
	    return true
	  }
	
	  function touchstartHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    if (isScrolling) {
	      scrollEnd()
	    }
	
	    if (options.useFrameAnimation) {
	      scrollAnimation && scrollAnimation.stop()
	      scrollAnimation = null
	    } else {
	      var transform = getTransformOffset(that)
	      setTransformStyle(that, transform)
	      setTransitionStyle(that, '', '')
	      transitionEndHandler = null
	      clearTimeout(transitionEndTimeoutId)
	    }
	  }
	
	  function touchendHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    var s0 = getTransformOffset(that)[that.axis]
	    var boundaryOffset = getBoundaryOffset(that, s0)
	
	    if (boundaryOffset) {
	      // dragging out of boundray, bounce is needed
	      var s1 = touchBoundary(that, s0)
	
	      if (options.useFrameAnimation) {
	        // frame
	        var _s = s1 - s0
	        scrollAnimation = new lib.animation(
	            400,
	            lib.cubicbezier.ease,
	            0,
	            function (i1, i2) {
	          var offset = (s0 + _s * i2).toFixed(2)
	          setTransformStyle(that, offset)
	          fireEvent(that, 'scrolling')
	        })
	        scrollAnimation.onend(scrollEnd)
	        scrollAnimation.play()
	      } else {
	        // css
	        var offset =  s1.toFixed(0)
	        setTransitionStyle(that, '0.4s', 'ease')
	        setTransformStyle(that, offset)
	        setTransitionEndHandler(scrollEnd, 400)
	
	        lib.animation.requestFrame(function () {
	          if (isScrolling && that.enabled) {
	            fireEvent(that, 'scrolling')
	            lib.animation.requestFrame(arguments.callee)
	          }
	        })
	      }
	
	      if (boundaryOffset > 0) {
	        fireEvent(that, that.axis === 'y' ? 'pulldownend' : 'pullrightend')
	      } else if (boundaryOffset < 0) {
	        fireEvent(that, that.axis === 'y' ? 'pullupend' : 'pullleftend')
	      }
	    } else if (isScrolling) {
	      // without exceeding the boundary, just end it
	      scrollEnd()
	    }
	  }
	
	  var lastDisplacement
	  function panstartHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    that.transformOffset = getTransformOffset(that)
	    that.minScrollOffset = getMinScrollOffset(that)
	    that.maxScrollOffset = getMaxScrollOffset(that)
	    panFixRatio = 2.5
	    cancelScrollEnd = true
	    isScrolling = true
	    isFlickScrolling = false
	    fireEvent(that, 'scrollstart')
	
	    lastDisplacement = e['displacement' + that.axis.toUpperCase()]
	  }
	
	
	  function panHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    // finger move less than 5 px. just ignore that.
	    var displacement = e['displacement' + that.axis.toUpperCase()]
	    if (Math.abs(displacement - lastDisplacement) < 5) {
	      e.stopPropagation()
	      return
	    }
	    lastDisplacement = displacement
	
	    var offset = that.transformOffset[that.axis] + displacement
	    if (offset > that.minScrollOffset) {
	      offset = that.minScrollOffset
	        + (offset - that.minScrollOffset) / panFixRatio
	      panFixRatio *= 1.003
	    } else if (offset < that.maxScrollOffset) {
	      offset = that.maxScrollOffset
	        - (that.maxScrollOffset - offset) / panFixRatio
	      panFixRatio *= 1.003
	    }
	    if (panFixRatio > 4) {
	      panFixRatio = 4
	    }
	
	    // tell whether or not reach the fringe
	    var boundaryOffset = getBoundaryOffset(that, offset)
	    if (boundaryOffset) {
	      fireEvent(
	          that,
	          boundaryOffset > 0
	          ? (that.axis === 'y' ? 'pulldown' : 'pullright')
	          : (that.axis === 'y' ? 'pullup' : 'pullleft'), {
	        boundaryOffset: Math.abs(boundaryOffset)
	      })
	      if (that.options.noBounce) {
	        offset = touchBoundary(that, offset)
	      }
	    }
	
	    setTransformStyle(that, offset.toFixed(2))
	    fireEvent(that, 'scrolling')
	  }
	
	  function panendHandler(e) {
	    if (!isEnabled(e)) {
	      return
	    }
	
	    if (e.isflick) {
	      flickHandler(e)
	    }
	  }
	
	  function flickHandler(e) {
	    cancelScrollEnd = true
	
	    var v0, a0, t0, s0, s, motion0
	    var v1, a1, t1, s1, motion1,sign
	    var v2, a2, t2, s2, motion2, ft
	
	    s0 = getTransformOffset(that)[that.axis]
	    var boundaryOffset0 = getBoundaryOffset(that, s0)
	    if (!boundaryOffset0) {
	      // when fingers left the range of screen, let touch end handler
	      // to deal with it.
	      // when fingers left the screen, but still in the range of
	      // screen, calculate the intertia.
	      v0 = e['velocity' + that.axis.toUpperCase()]
	
	      var maxV = 2
	      var friction = 0.0015
	      if (options.inertia && inertiaCoefficient[options.inertia]) {
	        maxV = inertiaCoefficient[options.inertia][0]
	        friction = inertiaCoefficient[options.inertia][1]
	      }
	
	      if (v0 > maxV) {
	        v0 = maxV
	      }
	      if (v0 < -maxV) {
	        v0 = -maxV
	      }
	      a0 = friction * (v0 / Math.abs(v0))
	      motion0 = new lib.motion({
	        v: v0,
	        a: -a0
	      })
	      t0 = motion0.t
	      s = s0 + motion0.s
	
	      var boundaryOffset1 = getBoundaryOffset(that, s)
	      if (boundaryOffset1) {
	        debugLog('inertial calculation has exceeded the boundary',
	          boundaryOffset1)
	
	        v1 = v0
	        a1 = a0
	        if (boundaryOffset1 > 0) {
	          s1 = that.minScrollOffset
	          sign = 1
	        } else {
	          s1 = that.maxScrollOffset
	          sign = -1
	        }
	        motion1 = new lib.motion({
	          v: sign * v1,
	          a: -sign * a1,
	          s: Math.abs(s1 - s0)
	        })
	        t1 = motion1.t
	        var timeFunction1 = motion1.generateCubicBezier()
	
	        v2 = v1 - a1 * t1
	        a2 = 0.03 * (v2 / Math.abs(v2))
	        motion2 = new lib.motion({
	          v: v2,
	          a: -a2
	        })
	        t2 = motion2.t
	        s2 = s1 + motion2.s
	        var timeFunction2 = motion2.generateCubicBezier()
	
	        if (options.noBounce) {
	          debugLog('no bounce effect')
	
	          if (s0 !== s1) {
	            if (options.useFrameAnimation) {
	              // frame
	              var _s = s1 - s0
	              var bezier = lib.cubicbezier(
	                timeFunction1[0][0],
	                timeFunction1[0][1],
	                timeFunction1[1][0],
	                timeFunction1[1][1]
	              )
	              scrollAnimation = new lib.animation(
	                  t1.toFixed(0),
	                  bezier,
	                  0,
	                  function (i1, i2) {
	                var offset = (s0 + _s * i2)
	                getTransformOffset(that, offset.toFixed(2))
	                fireEvent(that, 'scrolling', {
	                  afterFlick: true
	                })
	              })
	
	              scrollAnimation.onend(scrollEnd)
	
	              scrollAnimation.play()
	            } else {
	              // css
	              var offset = s1.toFixed(0)
	              setTransitionStyle(
	                that,
	                (t1 / 1000).toFixed(2) + 's',
	                'cubic-bezier(' + timeFunction1 + ')'
	              )
	              setTransformStyle(that, offset)
	              setTransitionEndHandler(
	                scrollEnd,
	                (t1 / 1000).toFixed(2) * 1000
	              )
	            }
	          } else {
	            scrollEnd()
	          }
	        } else if (s0 !== s2) {
	          debugLog(
	            'scroll for inertia',
	            's=' + s2.toFixed(0),
	            't=' + ((t1 + t2) / 1000).toFixed(2)
	          )
	
	          if (options.useFrameAnimation) {
	            var _s = s2 - s0
	            var bezier = lib.cubicbezier.easeOut
	            scrollAnimation = new lib.animation(
	                (t1 + t2).toFixed(0),
	                bezier,
	                0,
	                function (i1, i2) {
	              var offset = s0 + _s * i2
	              setTransformStyle(that, offset.toFixed(2))
	              fireEvent(that, 'scrolling',{
	                afterFlick: true
	              })
	            })
	
	            scrollAnimation.onend(function () {
	              if (!that.enabled) {
	                return
	              }
	
	              var _s = s1 - s2
	              var bezier = lib.cubicbezier.ease
	              scrollAnimation = new lib.animation(
	                  400,
	                  bezier,
	                  0,
	                  function (i1, i2) {
	                var offset = s2 + _s * i2
	                setTransformStyle(that, offset.toFixed(2))
	                fireEvent(that, 'scrolling',{
	                  afterFlick: true
	                })
	              })
	
	              scrollAnimation.onend(scrollEnd)
	
	              scrollAnimation.play()
	            })
	
	            scrollAnimation.play()
	          } else {
	            var offset = s2.toFixed(0)
	            setTransitionStyle(
	              that,
	              ((t1 + t2) / 1000).toFixed(2) + 's',
	              'ease-out'
	            )
	            setTransformStyle(that, offset)
	
	            setTransitionEndHandler(function (e) {
	              if (!that.enabled) {
	                return
	              }
	
	              debugLog('inertial bounce',
	                's=' + s1.toFixed(0),
	                't=400'
	              )
	
	              if (s2 !== s1) {
	                var offset = s1.toFixed(0)
	                setTransitionStyle(that, '0.4s', 'ease')
	                setTransformStyle(that, offset)
	                setTransitionEndHandler(scrollEnd, 400)
	              } else {
	                scrollEnd()
	              }
	            }, ((t1 + t2) / 1000).toFixed(2) * 1000)
	          }
	        } else {
	          scrollEnd()
	        }
	      } else {
	        debugLog('inertial calculation hasn\'t exceeded the boundary')
	        var timeFunction = motion0.generateCubicBezier()
	
	        if (options.useFrameAnimation) {
	          // frame
	          var _s = s - s0
	          var bezier = lib.cubicbezier(
	            timeFunction[0][0],
	            timeFunction[0][1],
	            timeFunction[1][0],
	            timeFunction[1][1]
	          )
	          scrollAnimation = new lib.animation(
	              t0.toFixed(0),
	              bezier,
	              0,
	              function (i1, i2) {
	            var offset = (s0 + _s * i2).toFixed(2)
	            setTransformStyle(that, offset)
	            fireEvent(that, 'scrolling',{
	              afterFlick: true
	            })
	          })
	
	          scrollAnimation.onend(scrollEnd)
	
	          scrollAnimation.play()
	        } else {
	          // css
	          var offset = s.toFixed(0)
	          setTransitionStyle(
	            that,
	            (t0 / 1000).toFixed(2) + 's',
	            'cubic-bezier(' + timeFunction + ')'
	          )
	          setTransformStyle(that, offset)
	          setTransitionEndHandler(scrollEnd, (t0 / 1000).toFixed(2) * 1000)
	        }
	      }
	
	
	      isFlickScrolling = true
	      if (!options.useFrameAnimation) {
	        lib.animation.requestFrame(function () {
	          if (isScrolling && isFlickScrolling && that.enabled) {
	            fireEvent(that, 'scrolling', {
	              afterFlick: true
	            })
	            lib.animation.requestFrame(arguments.callee)
	          }
	        })
	      }
	    }
	  }
	
	  function scrollEnd() {
	    if (!that.enabled) {
	      return
	    }
	
	    cancelScrollEnd = false
	
	    setTimeout(function () {
	      if (!cancelScrollEnd && isScrolling) {
	        isScrolling = false
	        isFlickScrolling = false
	
	        if (options.useFrameAnimation) {
	          scrollAnimation && scrollAnimation.stop()
	          scrollAnimation = null
	        } else {
	          setTransitionStyle(that, '', '')
	        }
	        fireEvent(that, 'scrollend')
	      }
	    }, 50)
	  }
	
	  var proto = {
	    init: function () {
	      this.enable()
	      this.refresh()
	      this.scrollTo(0)
	      return this
	    },
	
	    enable: function () {
	      this.enabled = true
	      return this
	    },
	
	    disable: function () {
	      var el = this.element
	      this.enabled = false
	
	      if (this.options.useFrameAnimation) {
	        scrollAnimation && scrollAnimation.stop()
	      } else {
	        lib.animation.requestFrame(function () {
	          el.style[stylePrefix + 'Transform']
	            = getComputedStyle(el)[stylePrefix + 'Transform']
	        })
	      }
	
	      return this
	    },
	
	    getScrollWidth: function () {
	      return getBoundingClientRect(this.element).width
	    },
	
	    getScrollHeight: function () {
	      return getBoundingClientRect(this.element).height
	    },
	
	    getScrollLeft: function () {
	      return -getTransformOffset(this).x - this.options.xPaddingTop
	    },
	
	    getScrollTop: function () {
	      return -getTransformOffset(this).y - this.options.yPaddingTop
	    },
	
	    getMaxScrollLeft: function () {
	      return -that.maxScrollOffset - this.options.xPaddingTop
	    },
	
	    getMaxScrollTop: function () {
	      return -that.maxScrollOffset - this.options.yPaddingTop
	    },
	
	    getBoundaryOffset: function () {
	      return Math.abs(
	        getBoundaryOffset(this, getTransformOffset(this)[this.axis]) || 0
	      )
	    },
	
	    refresh: function () {
	      var el = this.element
	      var isVertical = (this.axis === 'y')
	      var type = isVertical?'height':'width'
	
	      if (this.options[type] != null) {
	        // use options
	        el.style[type] = this.options[type] + 'px'
	      } else if (!!this.options.useElementRect) {
	        el.style[type] = 'auto'
	        el.style[type] = getBoundingClientRect(el)[type] + 'px'
	      } else if (el.childElementCount > 0) {
	        var range
	        var rect
	        var firstEl = el.firstElementChild
	        var lastEl = el.lastElementChild
	
	        if (document.createRange && !this.options.ignoreOverflow) {
	          // use range
	          range = document.createRange()
	          range.selectNodeContents(el)
	          rect = getBoundingClientRect(range)
	        }
	
	        if (rect) {
	          el.style[type] = rect[type] + 'px'
	        } else {
	          // use child offsets
	          while (firstEl) {
	            if (getBoundingClientRect(firstEl)[type] === 0
	                && firstEl.nextElementSibling) {
	              firstEl = firstEl.nextElementSibling
	            } else {
	              break
	            }
	          }
	
	          while (lastEl && lastEl !== firstEl) {
	            if (getBoundingClientRect(lastEl)[type] === 0
	                && lastEl.previousElementSibling) {
	              lastEl = lastEl.previousElementSibling
	            } else {
	              break
	            }
	          }
	
	          el.style[type] = (getBoundingClientRect(lastEl)[
	              isVertical ? 'bottom' : 'right']
	            - getBoundingClientRect(firstEl)[
	              isVertical ? 'top' : 'left'])
	            + 'px'
	        }
	      }
	
	      this.transformOffset = getTransformOffset(this)
	      this.minScrollOffset = getMinScrollOffset(this)
	      this.maxScrollOffset = getMaxScrollOffset(this)
	      this.scrollTo(
	        -this.transformOffset[this.axis]
	        - this.options[this.axis + 'PaddingTop']
	      )
	      fireEvent(this, 'contentrefresh')
	
	      return this
	    },
	
	    offset: function (childEl) {
	      var elRect = getBoundingClientRect(this.element)
	      var childRect = getBoundingClientRect(childEl)
	      if (this.axis === 'y') {
	        var offsetRect = {
	          top: childRect.top - elRect.top - this.options.yPaddingTop,
	          left: childRect.left - elRect.left,
	          right: elRect.right - childRect.right,
	          width: childRect.width,
	          height: childRect.height
	        }
	
	        offsetRect.bottom = offsetRect.top + offsetRect.height
	      } else {
	        var offsetRect = {
	          top: childRect.top - elRect.top,
	          bottom: elRect.bottom - childRect.bottom,
	          left: childRect.left - elRect.left - this.options.xPaddingTop,
	          width: childRect.width,
	          height: childRect.height
	        }
	
	        offsetRect.right = offsetRect.left + offsetRect.width
	      }
	      return offsetRect
	    },
	
	    getRect: function (childEl) {
	      var viewRect = getBoundingClientRect(this.viewport)
	      var childRect = getBoundingClientRect(childEl)
	      if (this.axis === 'y') {
	        var offsetRect = {
	          top: childRect.top - viewRect.top,
	          left: childRect.left - viewRect.left,
	          right: viewRect.right - childRect.right,
	          width: childRect.width,
	          height: childRect.height
	        }
	
	        offsetRect.bottom = offsetRect.top + offsetRect.height
	      } else {
	        var offsetRect = {
	          top: childRect.top - viewRect.top,
	          bottom: viewRect.bottom - childRect.bottom,
	          left: childRect.left - viewRect.left,
	          width: childRect.width,
	          height: childRect.height
	        }
	
	        offsetRect.right = offsetRect.left + offsetRect.width
	      }
	      return offsetRect
	    },
	
	    isInView: function (childEl) {
	      var viewRect = this.getRect(this.viewport)
	      var childRect = this.getRect(childEl)
	      if (this.axis === 'y') {
	        return viewRect.top < childRect.bottom
	          && viewRect.bottom > childRect.top
	      }
	      return viewRect.left < childRect.right
	        && viewRect.right > childRect.left
	    },
	
	    scrollTo: function (offset, isSmooth) {
	      var that = this
	      var element = this.element
	
	      offset = -offset - this.options[this.axis + 'PaddingTop']
	      offset = touchBoundary(this, offset)
	
	      isScrolling = true
	      if (isSmooth === true) {
	        if (this.options.useFrameAnimation) {
	          var s0 = getTransformOffset(that)[this.axis]
	          var _s = offset - s0
	          scrollAnimation = new lib.animation(
	              400,
	              lib.cubicbezier.easeInOut,
	              0,
	              function (i1, i2) {
	            var offset = (s0 + _s * i2).toFixed(2)
	            setTransformStyle(that, offset)
	            fireEvent(that, 'scrolling')
	          })
	
	          scrollAnimation.onend(scrollEnd)
	
	          scrollAnimation.play()
	        } else {
	          setTransitionStyle(that, '0.4s', 'ease-in-out')
	          setTransformStyle(that, offset)
	          setTransitionEndHandler(scrollEnd, 400)
	
	          lib.animation.requestFrame(function () {
	            if (isScrolling && that.enabled) {
	              fireEvent(that, 'scrolling')
	              lib.animation.requestFrame(arguments.callee)
	            }
	          })
	        }
	      } else {
	        if (!this.options.useFrameAnimation) {
	          setTransitionStyle(that, '', '')
	        }
	        setTransformStyle(that, offset)
	        scrollEnd()
	      }
	
	      return this
	    },
	
	    scrollToElement: function (childEl, isSmooth) {
	      var offset = this.offset(childEl)
	      offset = offset[this.axis === 'y'?'top':'left']
	      return this.scrollTo(offset, isSmooth)
	    },
	
	    getViewWidth: function () {
	      return getBoundingClientRect(this.viewport).width
	    },
	
	    getViewHeight: function () {
	      return getBoundingClientRect(this.viewport).height
	    },
	
	    addPulldownHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('pulldownend', function (e) {
	        that.disable()
	        handler.call(that, e, function () {
	          that.scrollTo(0, true)
	          that.refresh()
	          that.enable()
	        })
	      }, false)
	
	      return this
	    },
	
	    addPullupHandler: function (handler) {
	      var that = this
	
	      this.element.addEventListener('pullupend', function (e) {
	        that.disable()
	        handler.call(that, e, function () {
	          that.scrollTo(that.getScrollHeight(), true)
	          that.refresh()
	          that.enable()
	        })
	      }, false)
	
	      return this
	    },
	
	    addScrollstartHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('scrollstart', function (e) {
	        handler.call(that, e)
	      }, false)
	
	      return this
	    },
	
	    addScrollingHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('scrolling', function (e) {
	        handler.call(that, e)
	      }, false)
	
	      return this
	    },
	
	    addScrollendHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('scrollend', function (e) {
	        handler.call(that, e)
	      }, false)
	
	      return this
	    },
	
	    addContentrenfreshHandler: function (handler) {
	      var that = this
	      this.element.addEventListener('contentrefresh', function (e) {
	        handler.call(that, e)
	      }, false)
	    },
	
	    addEventListener: function (name, handler, useCapture) {
	      var that = this
	      this.element.addEventListener(name, function (e) {
	        handler.call(that, e)
	      }, !!useCapture)
	    },
	
	    removeEventListener: function (name, handler) {
	      var that = this
	      this.element.removeEventListener(name, function (e) {
	        handler.call(that, e)
	      })
	    },
	
	    enablePlugin: function (name, options) {
	      var plugin = plugins[name]
	      if (plugin && !this.plugins[name]) {
	        this.plugins[name] = true
	        options = options || {}
	        plugin.call(this, name, options)
	      }
	      return this
	    }
	  }
	
	  for (var k in proto) {
	    this[k] = proto[k]
	  }
	  delete proto
	}
	
	lib.scroll = function (el, options) {
	  if (arguments.length === 1 && !(arguments[0] instanceof HTMLElement)) {
	    options = arguments[0]
	    if (options.scrollElement) {
	      el = options.scrollElement
	    } else if (options.scrollWrap) {
	      el = options.scrollWrap.firstElementChild
	    } else {
	      throw new Error('no scroll element')
	    }
	  }
	
	  if (!el.parentNode) {
	    throw new Error('wrong dom tree')
	  }
	  if (options
	      && options.direction
	      && ['x', 'y'].indexOf(options.direction) < 0) {
	    throw new Error('wrong direction')
	  }
	
	  var scroll
	  if (options.downgrade === true
	      && lib.scroll.downgrade) {
	    scroll = lib.scroll.downgrade(el, options)
	  } else {
	    if (el.scrollId) {
	      scroll = scrollObjs[el.scrollId]
	    } else {
	      scroll = new Scroll(el, options)
	    }
	  }
	  return scroll
	}
	
	lib.scroll.plugin = function (name, constructor) {
	  if (constructor) {
	    name = name.split(',')
	    name.forEach(function (n) {
	      plugins[n] = constructor
	    })
	  } else {
	    return plugins[name]
	  }
	}
	


/***/ },
/* 48 */
/***/ function(module, exports) {

	'use strict'
	
	/**
	 * transfer Quadratic Bezier Curve to Cubic Bezier Curve
	 *
	 * @param  {number} a abscissa of p1
	 * @param  {number} b ordinate of p1
	 * @return {Array} parameter matrix for cubic bezier curve
	 *   like [[p1x, p1y], [p2x, p2y]]
	 */
	function quadratic2cubicBezier(a, b) {
	  return [
	    [
	      (a / 3 + (a + b) / 3 - a) / (b - a),
	      (a * a / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)
	    ], [
	      (b / 3 + (a + b) / 3 - a) / (b - a),
	      (b * b / 3 + a * b * 2 / 3 - a * a) / (b * b - a * a)
	    ]
	  ]
	}
	
	/**
	 * derive position data from knowing motion parameters
	 * base on Newton's second law: s = vt + at^2/2
	 *
	 * @param {object} config object of { v, a, s, t }
	 *   - v: initial velocity
	 *   - a: accelerate speed
	 *   - t: time
	 *   - s: shifting
	 */
	function Motion(config) {
	
	  this.v = config.v || 0
	  this.a = config.a || 0
	
	  if (typeof config.t !== 'undefined') {
	    this.t = config.t
	  }
	
	  if (typeof config.s !== 'undefined') {
	    this.s = config.s
	  }
	
	  // derive time from shifting
	  if (typeof this.t === 'undefined') {
	    if (typeof this.s === 'undefined') {
	      this.t = -this.v / this.a
	    } else {
	      var t1 = (Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v)
	        / this.a
	      var t2 = (-Math.sqrt(this.v * this.v + 2 * this.a * this.s) - this.v)
	        / this.a
	      this.t = Math.min(t1, t2)
	    }
	  }
	
	  // derive shifting from time
	  if (typeof this.s === 'undefined') {
	    this.s = this.a * this.t * this.t / 2 + this.v * this.t
	  }
	}
	
	/**
	 * derive cubic bezier parameters from motion parameters
	 * @return {Array} parameter matrix for cubic bezier curve
	 *   like [[p1x, p1y], [p2x, p2y]]
	 */
	Motion.prototype.generateCubicBezier = function () {
	  return quadratic2cubicBezier(
	    this.v / this.a, this.t + this.v / this.a
	  )
	}
	
	!lib && (lib = {})
	lib.motion = Motion
	
	module.exports = Motion

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(44)
	
	function Hlist(data, nodeType) {
	  data.attr.direction = 'h'
	  List.call(this, data, nodeType)
	}
	
	Hlist.prototype = Object.create(List.prototype)
	
	module.exports = Hlist

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	__webpack_require__(51)
	
	var FORMATTER_REGEXP = /(\\)?(dd*|hh?|mm?|ss?)/gi
	
	function formatDateTime(data, formatter, timeColor) {
	  return formatter.replace(FORMATTER_REGEXP, function (m) {
	    var len = m.length
	    var firstChar = m.charAt(0)
	    // escape character
	    if (firstChar === '\\') {
	      return m.replace('\\', '')
	    }
	    var value = (firstChar === 'd' ? data.days :
	                firstChar === 'h' ? data.hours :
	                firstChar === 'm' ? data.minutes :
	                firstChar === 's' ? data.seconds : 0) + ''
	
	    // 5 zero should be enough
	    return '<span style="margin:4px;color:'
	      + timeColor + '" >'
	      + ('00000' + value).substr(-Math.max(value.length, len))
	      + '</span>'
	  })
	}
	
	function Countdown (data) {
	  Atomic.call(this, data)
	}
	
	Countdown.prototype = Object.create(Atomic.prototype)
	
	Countdown.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-element')
	  var data = this.data
	  var time = Number(data.attr.countdownTime) || 0
	  var endTime = Date.now() / 1000 + time
	  var cd = lib.countdown({
	    endDate: endTime,
	    onUpdate: function (time) {
	      var timeColor = data.style.timeColor || '#000'
	      var result = formatDateTime(time, data.attr.formatterValue, timeColor)
	      node.innerHTML = result
	    },
	    onEnd: function () {
	    }
	  }).start()
	
	  return node
	}
	
	Countdown.prototype.style = {
	  textColor: function (value) {
	    this.node.style.color = value
	  }
	}
	
	module.exports = Countdown


/***/ },
/* 51 */
/***/ function(module, exports) {

	!function(a,b){function c(a){var b;if("number"==typeof a)b=new Date(1e3*a);else if("string"==typeof a){var c=a.charAt(0),d="+"===c,h="-"===c;if(d||h){for(var i,j=a.substr(1),k=j.split(":"),l=[0,0,0,0],m=4;k.length&&--m>=0;)l[m]=parseInt(k.pop())||0;i=e*l[0]+f*l[1]+g*l[2]+l[3],b=new Date,b.setSeconds(b.getSeconds()+i*(h?-1:1)),b.setMilliseconds(0)}}return b||(b=new Date(a)),b}function d(a,b){return b.replace(FORMATTER_REGEXP,function(b){var c=b.length,d=b.charAt(0);if("\\"===d)return b.replace("\\","");var e=("d"===d?a.days:"h"===d?a.hours:"m"===d?a.minutes:"s"===d?a.seconds:0)+"";return("00000"+e).substr(-Math.max(e.length,c))})}var e=86400,f=3600,g=60,h="d天hh时mm分ss秒";FORMATTER_REGEXP=/(\\)?(dd*|hh?|mm?|ss?)/gi;var i=function(a){a=a||{};var b=this,d=c(a.endDate);if(!d||!d.getTime())throw new Error("Invalid endDate");b.endDate=d,b.onUpdate=a.onUpdate,b.onEnd=a.onEnd,b.interval=a.interval||1e3,b.stringFormatter=a.stringFormatter||h,b.correctDateOffset=a.correctDateOffset||0,b.updateElement=a.updateElement,b._data={days:0,hours:0,minutes:0,seconds:0}};i.prototype={start:function(){var a=this;return a.stop(),a._update()&&(a._intervalId=setInterval(function(){a._update()},a.interval)),a},_update:function(){var a,b=this,c=b._data,h=b.updateElement,i=+new Date+1e3*b.correctDateOffset,j=Math.max(0,Math.round((b.endDate.getTime()-i)/1e3)),k=0>=j;return c.totalSeconds=j,j-=(c.days=Math.floor(j/e))*e,j-=(c.hours=Math.floor(j/f))*f,j-=(c.minutes=Math.floor(j/g))*g,c.seconds=j,c.stringValue=d(c,b.stringFormatter),h&&(h.innerHTML=c.stringValue),(a=b.onUpdate)&&a.call(b,c),k?(b.stop(),(a=b.onEnd)&&a.call(b),!1):!0},stop:function(){var a=this;return a._intervalId&&(clearInterval(a._intervalId),a._intervalId=null),a},setEndDate:function(a){var b=this;return b.endDate=c(a),b}},b.countdown=function(a){return new i(a)}}(window,window.lib||(window.lib={}));

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var config = __webpack_require__(16)
	var Component = __webpack_require__(27)
	var ComponentManager = __webpack_require__(20)
	var LazyLoad = __webpack_require__(23)
	
	function Marquee (data) {
	  this.interval = Number(data.attr.interval) || 5 * 1000
	  this.transitionDuration = Number(data.attr.transitionDuration) || 500
	  this.delay = Number(data.attr.delay) || 0
	  Component.call(this, data)
	}
	
	Marquee.prototype = Object.create(Component.prototype)
	
	Marquee.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container')
	  node.style.overflow = 'hidden'
	  // fix page shaking during slider's playing
	  node.style.webkitTransform = 'translate3D(0,0,0)'
	  node.addEventListener('webkitTransitionEnd', this.end.bind(this), false)
	  return node
	}
	
	Marquee.prototype.createChildren = function () {
	  // first run:
	  // - create each child
	  // - append to parentNode
	  // - find current and next
	  // - set current and next shown and others hidden
	  var children = this.data.children
	  var parentRef = this.data.ref
	  var instanceId = this.data.instanceId
	  var items = []
	  var componentManager = this.getComponentManager()
	
	  var fragment, isFlex, child, node, i
	
	  if (children && children.length) {
	    fragment = document.createDocumentFragment()
	    isFlex = false
	    for (i = 0; i < children.length; i++) {
	      children[i].scale = this.data.scale
	      children[i].instanceId = instanceId
	      child = componentManager.createElement(children[i])
	      child.parentRef = parentRef
	      this.initChild(child)
	      // append and push
	      items.push(child)
	      fragment.appendChild(child.node)
	      if (!isFlex && child.data.style.hasOwnProperty('flex')) {
	        isFlex = true
	      }
	    }
	    this.node.appendChild(fragment)
	  }
	
	  // set items
	  this.items = items
	
	  // reset the clock for first transition
	  this.reset()
	}
	
	Marquee.prototype.initChild = function (child) {
	  var node = child.node
	  node.style.position = 'absolute'
	  node.style.top = '0'
	  node.style.left = '0'
	}
	
	Marquee.prototype.appendChild = function (data) {
	  // dom + items
	  var componentManager = ComponentManager.getInstance(this.data.instanceId)
	  var child = componentManager.createElement(data)
	  this.initChild(child)
	  this.node.appendChild(child.node)
	  this.items.push(child)
	  this.reset()
	  return child // @todo redesign Component#appendChild(component)
	}
	
	Marquee.prototype.insertBefore = function (child, before) {
	  // dom + items
	  var index = this.items.indexOf(before)
	  this.items.splice(index, 0, child)
	  this.initChild(child)
	  this.node.insertBefore(child.node, before.node)
	  this.reset()
	}
	
	Marquee.prototype.removeChild = function (child) {
	  // dom + items
	  var index = this.items.indexOf(child)
	  this.items.splice(index, 1)
	  this.node.removeChild(child.node)
	  this.reset()
	}
	
	/**
	 * status: {
	 *   current: {translateY: 0, shown: true},
	 *   next: {translateY: height, shown: true},
	 *   others[]: {shown: false}
	 *   index: index
	 * }
	 */
	Marquee.prototype.reset = function () {
	  var interval = this.interval - 0
	  var delay = this.delay - 0
	  var items = this.items
	  var self = this
	
	  var loop = function () {
	    self.next()
	    self.timerId = setTimeout(loop, self.interval)
	  }
	
	  // reset display and transform
	  items.forEach(function (item, index) {
	    var node = item.node
	    // set non-current(0)|next(1) item hidden
	    node.style.display = index > 1 ? 'none' : ''
	    // set next(1) item translateY
	    // TODO: it supposed to use item.data.style
	    // but somehow the style object is empty.
	    // This problem relies on jsframework's bugfix.
	
	    // node.style.transform = index === 1
	    //     ? 'translate3D(0,' + config.scale * item.data.style.height + 'px,0)'
	    //     : ''
	    // node.style.webkitTransform = index === 1
	    //     ? 'translate3D(0,' + config.scale * item.data.style.height + 'px,0)'
	    //     : ''
	    node.style.transform = index === 1
	        ? 'translate3D(0,' + self.data.scale * self.data.style.height + 'px,0)'
	        : ''
	    node.style.webkitTransform = index === 1
	        ? 'translate3D(0,' + self.data.scale * self.data.style.height + 'px,0)'
	        : ''
	  })
	
	  setTimeout(function () {
	    // reset current, next, index
	    self.currentItem = items[0]
	    self.nextItem = items[1]
	    self.currentIndex = 0
	
	    items.forEach(function (item, index) {
	      var node = item.node
	      // set transition
	      node.style.transition = 'transform '
	          + self.transitionDuration
	          + 'ms ease'
	      node.style.webkitTransition = '-webkit-transform '
	          + self.transitionDuration
	          + 'ms ease'
	    })
	
	    clearTimeout(self.timerId)
	
	    if (items.length > 1) {
	      self.timerId = setTimeout(loop, delay + interval)
	    }
	  }, 13)
	
	}
	
	/**
	 * next:
	 * - current: {translateY: -height}
	 * - next: {translateY: 0}
	 */
	Marquee.prototype.next = function () {
	  // - update state
	  //   - set current and next transition
	  //   - hide current when transition end
	  //   - set next to current
	  //   - find new next
	  var next = this.nextItem.node
	  var current = this.currentItem.node
	  this.transitionIndex = this.currentIndex
	
	  // Use setTimeout to fix the problem that when the
	  // page recover from backstage, the slider will
	  // not work any longer.
	  setTimeout(function () {
	    next.style.transform = 'translate3D(0,0,0)'
	    next.style.webkitTransform = 'translate3D(0,0,0)'
	    current.style.transform = 'translate3D(0,-'
	        + this.data.scale * this.data.style.height
	        + 'px,0)'
	    current.style.webkitTransform = 'translate3D(0,-'
	        + this.data.scale * this.data.style.height
	        + 'px,0)'
	    this.fireEvent('change')
	  }.bind(this), 300)
	}
	
	Marquee.prototype.fireEvent = function (type) {
	  var length = this.items.length
	  var nextIndex = (this.currentIndex + 1) % length
	  var evt = document.createEvent('HTMLEvents')
	  evt.initEvent(type, false, false)
	  evt.data = {
	    prevIndex: this.currentIndex,
	    index: nextIndex
	  }
	  this.node.dispatchEvent(evt)
	}
	
	/**
	 * end:
	 * - old current: {shown: false}
	 * - old current: {translateY: 0}
	 * - index++ % length
	 * - new current = old next
	 * - new next = items[index+1 % length]
	 * - new next: {translateY: height}
	 * - new next: {shown: true}
	 */
	Marquee.prototype.end = function (e) {
	  var target = e.target
	  var items = this.items
	  var length = items.length
	  var current, next
	  var currentIndex, nextIndex
	
	  currentIndex = this.transitionIndex
	
	  if (isNaN(currentIndex)) {
	    return
	  }
	  delete this.transitionIndex
	
	  current = this.currentItem.node
	  current.style.display = 'none'
	  current.style.webkitTransform = ''
	
	  currentIndex = (currentIndex + 1) % length
	  nextIndex = (currentIndex + 1) % length
	
	  this.currentIndex = currentIndex
	  this.currentItem = this.nextItem
	  this.nextItem = items[nextIndex]
	
	  setTimeout(function () {
	    next = this.nextItem.node
	    // TODO: it supposed to use this.nextItem.data.style
	    // but somehow the style object is empty.
	    // This problem relies on jsframework's bugfix.
	
	    next.style.webkitTransform = 'translate3D(0,'
	        + this.data.scale * this.data.style.height
	        + 'px,0)'
	    next.style.display = ''
	    LazyLoad.loadIfNeeded(next)
	  }.bind(this))
	}
	
	Marquee.prototype.attr = {
	  interval: function (value) {
	    this.interval = value
	  },
	  transitionDuration: function (value) {
	    this.transitionDuration = value
	  },
	  delay: function (value) {
	    this.delay = value
	  }
	}
	
	Marquee.prototype.clearAttr = function () {
	  this.interval = 5 * 1000
	  this.transitionDuration = 500
	  this.delay = 0
	}
	
	module.exports = Marquee


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var extend = __webpack_require__(17).extend
	var config = __webpack_require__(16)
	var Component = __webpack_require__(27)
	var ComponentManager = __webpack_require__(20)
	var LazyLoad = __webpack_require__(23)
	__webpack_require__(54)
	__webpack_require__(58)
	
	var DEFAULT_INTERVAL = 3000
	
	function Slider (data) {
	  this.autoPlay = false  // default value is false.
	  this.interval = DEFAULT_INTERVAL
	  this.direction = 'row' // 'column' is not temporarily supported.
	  this.children = []
	  this.isPageShow = true
	  this.isDomRendering = true
	
	  // bind event 'pageshow' and 'pagehide' on window.
	  this._idleWhenPageDisappear()
	  // bind event 'renderBegin' and 'renderEnd' on window.
	  this._idleWhenDomRendering()
	
	  Component.call(this, data)
	}
	
	Slider.prototype = Object.create(Component.prototype)
	
	Slider.prototype._idleWhenPageDisappear = function () {
	  var _this = this
	  window.addEventListener('pageshow', function () {
	    _this.isPageShow = true
	    _this.autoPlay && !_this.isDomRendering && _this.play()
	  })
	  window.addEventListener('pagehide', function () {
	    _this.isPageShow = false
	    _this.stop()
	  })
	}
	
	Slider.prototype._idleWhenDomRendering = function () {
	  var _this = this
	  window.addEventListener('renderend', function () {
	    _this.isDomRendering = false
	    _this.autoPlay && _this.isPageShow && _this.play()
	  })
	  window.addEventListener('renderbegin', function () {
	    _this.isDomRendering = true
	    _this.stop()
	  })
	}
	
	Slider.prototype.attr = {
	  interval: function (val) {
	    this.interval = parseInt(val) || DEFAULT_INTERVAL
	    if (this.carrousel) {
	      this.carrousel.playInterval = this.interval
	    }
	  },
	
	  playstatus: function (val) {
	    this.playstatus = val && val !== 'false' ? true : false
	    this.autoPlay = this.playstatus
	    if (this.carrousel) {
	      if (this.playstatus) {
	        this.play()
	      } else {
	        this.stop()
	      }
	    }
	  },
	
	  // support playstatus' alias auto-play for compatibility
	  autoPlay: function (val) {
	    this.attr.playstatus.call(this, val)
	  }
	}
	
	Slider.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('slider')
	  node.style.position = 'relative'
	  node.style.overflow = 'hidden'
	  return node
	}
	
	Slider.prototype._doRender = function () {
	  var _this = this
	  _this.createChildren()
	  _this.onAppend()
	}
	
	Slider.prototype.removeChild = function (child) {
	  var children = this.data.children
	  if (children) {
	    for (var i = 0; i < children.length; i++) {
	      if (child.data.ref === children[i].ref) {
	        children.splice(i, 1)
	        break
	      }
	    }
	  }
	
	  this._doRender()
	}
	
	Slider.prototype.insertBefore = function (child, before) {
	  var children = this.data.children
	  // var childIndex = this.children.indexOf(before.data)
	  var childIndex = -1
	  for (var i = 0, l = children.length; i < l; i++) {
	    if (children[i].ref === before.data.ref) {
	      childIndex = i
	      break
	    }
	  }
	  children.splice(childIndex, 0, child.data)
	
	  this._doRender()
	  if (this.children.length > 0) {
	    return this.children[this.children.length - 1]
	  }
	}
	
	Slider.prototype.appendChild = function (data) {
	  var children = this.data.children || (this.data.children = [])
	  children.push(data)
	  this._doRender()
	  if (this.children.length > 0) {
	    return this.children[this.children.length - 1]
	  }
	}
	
	Slider.prototype.createChildren = function () {
	
	  var componentManager = this.getComponentManager()
	
	  // recreate slider container.
	  if (this.sliderContainer) {
	    this.node.removeChild(this.sliderContainer)
	  }
	  if (this.indicator) {
	    this.indicator.node.parentNode.removeChild(this.indicator.node)
	  }
	  this.children = []
	
	  var sliderContainer = document.createElement('ul')
	  sliderContainer.style.listStyle = 'none'
	  this.node.appendChild(sliderContainer)
	  this.sliderContainer = sliderContainer
	
	  var children = this.data.children
	  var scale = this.data.scale
	  var fragment = document.createDocumentFragment()
	  var indicatorData, width, height
	  var childWidth = 0
	  var childHeight = 0
	
	  if (children && children.length) {
	    for (var i = 0; i < children.length; i++) {
	      var child
	      children[i].scale = this.data.scale
	      children[i].instanceId = this.data.instanceId
	      if (children[i].type === 'indicator') {
	        indicatorData = extend(children[i], {
	          extra: {
	            amount: children.length - 1,
	            index: 0
	          }
	        })
	      } else {
	        child = componentManager.createElement(children[i], 'li')
	        this.children.push(child)
	        fragment.appendChild(child.node)
	        width = child.data.style.width || 0
	        height = child.data.style.height || 0
	        width > childWidth && (childWidth = width)
	        height > childHeight && (childHeight = height)
	        child.parentRef = this.data.ref
	      }
	    }
	    // append indicator
	    if (indicatorData) {
	      indicatorData.extra.width = this.data.style.width || childWidth
	      indicatorData.extra.height = this.data.style.height || childHeight
	      this.indicator = componentManager.createElement(indicatorData)
	      this.indicator.parentRef = this.data.ref
	      this.indicator.slider = this
	      this.node.appendChild(this.indicator.node)
	    }
	
	    sliderContainer.style.height = scale * this.data.style.height + 'px'
	    sliderContainer.appendChild(fragment)
	  }
	}
	
	Slider.prototype.onAppend = function () {
	  if (this.carrousel) {
	    this.carrousel.removeEventListener('change', this._getSliderChangeHandler())
	    this.carrousel.stop()
	    this.carrousel = null
	  }
	  this.carrousel = new lib.carrousel(this.sliderContainer, {
	    autoplay: this.autoPlay,
	    useGesture: true
	  })
	
	  this.carrousel.playInterval = this.interval
	  this.carrousel.addEventListener('change', this._getSliderChangeHandler())
	  this.currentIndex = 0
	
	  // preload all images for slider
	  // because:
	  // 1. lib-img doesn't listen to event transitionend
	  // 2. even if we fire lazy load in slider's change event handler,
	  //    the next image still won't be preloaded utill the moment it
	  //    slides into the view, which is too late.
	  if (this.preloadImgsTimer) {
	    clearTimeout(this.preloadImgsTimer)
	  }
	  // The time just before the second slide appear and enough
	  // for all child elements to append is ok.
	  var preloadTime = 0.8
	  this.preloadImgsTimer = setTimeout(function () {
	    var imgs = this.carrousel.element.querySelectorAll('.weex-img')
	    for (var i = 0, l = imgs.length; i < l; i++) {
	      var img = imgs[i]
	      var iLazySrc = img.getAttribute('i-lazy-src')
	      var imgSrc = img.getAttribute('img-src')
	      if (iLazySrc) {
	        img.style.backgroundImage = 'url(' + iLazySrc + ')'
	      } else if (imgSrc) {
	        img.style.backgroundImage = 'url(' + imgSrc + ')'
	      }
	      img.removeAttribute('i-lazy-src')
	      img.removeAttribute('img-src')
	    }
	  }.bind(this), preloadTime * 1000)
	
	  // avoid page scroll when panning
	  var panning = false
	  this.carrousel.element.addEventListener('panstart', function (e) {
	    if (!e.isVertical) {
	      panning = true
	    }
	  })
	  this.carrousel.element.addEventListener('panend', function (e) {
	    if (!e.isVertical) {
	      panning = false
	    }
	  })
	
	  document.addEventListener('touchmove', function (e) {
	    if (panning) {
	      e.preventDefault()
	      return false
	    }
	    return true
	  }.bind(this))
	
	}
	
	Slider.prototype._updateIndicators = function () {
	  this.indicator && this.indicator.setIndex(this.currentIndex)
	}
	
	Slider.prototype._getSliderChangeHandler = function (e) {
	  if (!this.sliderChangeHandler) {
	    this.sliderChangeHandler = (function (e) {
	      var index = this.carrousel.items.index
	      this.currentIndex = index
	
	      // updateIndicators
	      this._updateIndicators()
	
	      this.dispatchEvent('change', { index: index })
	    }).bind(this)
	  }
	  return this.sliderChangeHandler
	}
	
	Slider.prototype.play = function () {
	  this.carrousel.play()
	}
	
	Slider.prototype.stop = function () {
	  this.carrousel.stop()
	}
	
	Slider.prototype.slideTo = function (index) {
	  var offset = index - this.currentIndex
	  this.carrousel.items.slide(offset)
	}
	
	module.exports = Slider


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});__webpack_require__(55);__webpack_require__(56);__webpack_require__(57);!function(){var a="[data-ctrl-name=carrousel]{position:relative;-webkit-transform:translateZ(1px);-ms-transform:translateZ(1px);transform:translateZ(1px)}",b=document.createElement("style");if(document.getElementsByTagName("head")[0].appendChild(b),b.styleSheet)b.styleSheet.disabled||(b.styleSheet.cssText=a);else try{b.innerHTML=a}catch(c){b.innerText=a}}();!function(a,b,c){function d(a){var b,c={x:0,y:0},d=getComputedStyle(a)[l+"Transform"];return"none"!==d&&(b=d.match(/^matrix3d\((?:[-\d.]+,\s*){12}([-\d.]+),\s*([-\d.]+)(?:,\s*[-\d.]+){2}\)/)||d.match(/^matrix\((?:[-\d.]+,\s*){4}([-\d.]+),\s*([-\d.]+)\)$/))&&(c.x=parseFloat(b[1])||0,c.y=parseFloat(b[2])||0),c}function e(a,b){return a=parseFloat(a),b=parseFloat(b),0!=a&&(a+="px"),0!=b&&(b+="px"),n?"translate3d("+a+", "+b+", 0)":"translate("+a+", "+b+")"}function f(a){return o.call(a)}function g(a,c){function g(a,b){var c=h.createEvent("HTMLEvents");if(c.initEvent(a,!1,!1),b)for(var d in b)c[d]=b[d];n.dispatchEvent(c)}function i(a){for(;0>a;)a+=r;for(;a>=r;)a-=r;return a}function j(a){if(0!==r){var b,c,d=q.get(a);r>1&&(b=q.get(a-1),c=2===r?q.getCloned(a+1):q.get(a+1),d.style.left=-o+"px",b.style.left=-o-s+"px",c.style.left=-o+s+"px"),t=d.index,g("change",{prevItem:b,curItem:d,nextItem:c})}}var k=this,m=Date.now()+"-"+ ++p,n=document.createDocumentFragment();1!==arguments.length||arguments[0]instanceof HTMLElement||(c=arguments[0],a=null),a||(a=document.createElement("ul"),n.appendChild(a)),c=c||{},a.setAttribute("data-ctrl-name","carrousel"),a.setAttribute("data-ctrl-id",m),a.style.position="relative",a.style[l+"Transform"]=e(0,0);var o=0,q={},r=0,s=c.step||a.getBoundingClientRect().width,t=0;q.add=function(b){var c=document.createElement("li");return c.style.display="none",c.style["float"]="left",c.index=r,"string"==typeof b?c.innerHTML=b:b instanceof HTMLElement&&c.appendChild(b),a.appendChild(c),Object.defineProperty(q,r+"",{get:function(){return c}}),r++,c},q.get=function(a){return q[i(a)]},q.getCloned=function(b){function c(a,b,d){var e=a._listeners;if(e){b._listeners=e;for(var f in e)b.addEventListener(f,e[f])}if(d&&a.children&&a.children.length)for(var g=0,h=a.children.length;h>g;g++)c(a.children[g],b.children[g],d)}var b=i(b),d=a.querySelector('[cloned="cloned-'+b+'"]'),e=q[b];return d||(d=e.cloneNode(!0),c(e,d,!0),a.appendChild(d),d.setAttribute("cloned","cloned-"+b),d.index=b),d},q.slide=function(c){if(0!==r){1===r&&(c=0);var f=d(a).x,g=o+s*-c,h=g-f;if(0!==h){new b.animation(400,b.cubicbezier.ease,function(b,c){a.style[l+"Transform"]=e(f+h*c,0)}).play().then(function(){o=g,a.style[l+"Transform"]=e(g,0),c&&j(t+c)})}}},q.next=function(){q.slide(1)},q.prev=function(){q.slide(-1)},f(a.querySelectorAll("li")).forEach(function(a){a.style.position="absolute",a.style.top="0",a.style.left=r*s+"px",a.style["float"]="left",a.index=r,Object.defineProperty(q,r+"",{get:function(){return a}}),r++}),Object.defineProperty(this,"items",{get:function(){return q}}),Object.defineProperty(q,"length",{get:function(){return r}}),Object.defineProperty(q,"index",{get:function(){return t}}),Object.defineProperty(q,"step",{get:function(){return s},set:function(a){s=a}});var u=!1,v=!1,w=!1;this.play=function(){return u?void(v||(v=setTimeout(function(){w=!0,q.next(),setTimeout(function(){w=!1},500),v=setTimeout(arguments.callee,400+z)},400+z))):(u=!0,j(0))},this.stop=function(){v&&(clearTimeout(v),setTimeout(function(){v=!1},500))};var x=!1,y=!1;Object.defineProperty(this,"autoplay",{get:function(){return x},set:function(a){x=!!a,y&&(clearTimeout(y),y=!1),x?y=setTimeout(function(){k.play()},2e3):k.stop()}}),this.autoplay=!!c.autoplay;var z=1500;if(Object.defineProperty(this,"playInterval",{get:function(){return z},set:function(a){z=a}}),this.playInterval=!!c.playInterval||1500,c.useGesture){var A,B=!1;a.addEventListener("panstart",function(a){a.isVertical||B&&w||(a.preventDefault(),a.stopPropagation(),x&&k.stop(),A=0,B=!0)}),a.addEventListener("panmove",function(b){!b.isVertical&&B&&(b.preventDefault(),b.stopPropagation(),A=b.displacementX,a.style[l+"Transform"]=e(o+A,0))}),a.addEventListener("panend",function(a){!a.isVertical&&B&&(a.preventDefault(),a.stopPropagation(),B=!1,a.isflick?0>A?q.next():q.prev():Math.abs(A)<s/2?q.slide(0):q.slide(0>A?1:-1),x&&setTimeout(function(){k.play()},2e3))},!1),a.addEventListener("swipe",function(a){a.isVertical||(a.preventDefault(),a.stopPropagation())})}this.addEventListener=function(a,b){this.root.addEventListener(a,b,!1)},this.removeEventListener=function(a,b){this.root.removeEventListener(a,b,!1)},this.root=n,this.element=a}var h=a.document,i=a.navigator.userAgent,j=!!i.match(/Firefox/i),k=!!i.match(/IEMobile/i),l=j?"Moz":k?"ms":"webkit",m=k?"MSCSSMatrix":"WebKitCSSMatrix",n=!!j||m in a&&"m11"in new a[m],o=Array.prototype.slice,p=0;b.carrousel=g}(window,window.lib,window.ctrl||(window.ctrl={}));;module.exports = window.lib['carrousel'];

/***/ },
/* 55 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){return setTimeout(a,l)}function d(a){clearTimeout(a)}function e(){var a={},b=new m(function(b,c){a.resolve=b,a.reject=c});return a.promise=b,a}function f(a,b){return["then","catch"].forEach(function(c){b[c]=function(){return a[c].apply(a,arguments)}}),b}function g(b){var c,d,h=!1;this.request=function(){h=!1;var g=arguments;return c=e(),f(c.promise,this),d=n(function(){h||c&&c.resolve(b.apply(a,g))}),this},this.cancel=function(){return d&&(h=!0,o(d),c&&c.reject("CANCEL")),this},this.clone=function(){return new g(b)}}function h(a,b){"function"==typeof b&&(b={0:b});for(var c=a/l,d=1/c,e=[],f=Object.keys(b).map(function(a){return parseInt(a)}),h=0;c>h;h++){var i=f[0],j=d*h;if(null!=i&&100*j>=i){var k=b[""+i];k instanceof g||(k=new g(k)),e.push(k),f.shift()}else e.length&&e.push(e[e.length-1].clone())}return e}function i(a){var c;return"string"==typeof a||a instanceof Array?b.cubicbezier?"string"==typeof a?b.cubicbezier[a]&&(c=b.cubicbezier[a]):a instanceof Array&&4===a.length&&(c=b.cubicbezier.apply(b.cubicbezier,a)):console.error("require lib.cubicbezier"):"function"==typeof a&&(c=a),c}function j(a,b,c){var d,g=h(a,c),j=1/(a/l),k=0,m=i(b);if(!m)throw new Error("unexcept timing function");var n=!1;this.play=function(){function a(){var c=j*(k+1).toFixed(10),e=g[k];e.request(c.toFixed(10),b(c).toFixed(10)).then(function(){n&&(k===g.length-1?(n=!1,d&&d.resolve("FINISH"),d=null):(k++,a()))},function(){})}if(!n)return n=!0,d||(d=e(),f(d.promise,this)),a(),this},this.stop=function(){return n?(n=!1,g[k]&&g[k].cancel(),this):void 0}}var k=60,l=1e3/k,m=a.Promise||b.promise&&b.promise.ES6Promise,n=window.requestAnimationFrame||window.msRequestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||c,o=window.cancelAnimationFrame||window.msCancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||d;(n===c||o===d)&&(n=c,o=d),b.animation=function(a,b,c){return new j(a,b,c)},b.animation.frame=function(a){return new g(a)},b.animation.requestFrame=function(a){var b=new g(a);return b.request()}}(window,window.lib||(window.lib={}));;module.exports = window.lib['animation'];

/***/ },
/* 56 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a,b,c,d){function e(a){return(3*k*a+2*l)*a+m}function f(a){return((k*a+l)*a+m)*a}function g(a){return((n*a+o)*a+p)*a}function h(a){for(var b,c,d=a,g=0;8>g;g++){if(c=f(d)-a,Math.abs(c)<j)return d;if(b=e(d),Math.abs(b)<j)break;d-=c/b}var h=1,i=0;for(d=a;h>i;){if(c=f(d)-a,Math.abs(c)<j)return d;c>0?h=d:i=d,d=(h+i)/2}return d}function i(a){return g(h(a))}var j=1e-6,k=3*a-3*c+1,l=3*c-6*a,m=3*a,n=3*b-3*d+1,o=3*d-6*b,p=3*b;return i}b.cubicbezier=c,b.cubicbezier.linear=c(0,0,1,1),b.cubicbezier.ease=c(.25,.1,.25,1),b.cubicbezier.easeIn=c(.42,0,1,1),b.cubicbezier.easeOut=c(0,0,.58,1),b.cubicbezier.easeInOut=c(.42,0,.58,1)}(window,window.lib||(window.lib={}));;module.exports = window.lib['cubicbezier'];

/***/ },
/* 57 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a){"use strict";function b(a,b){for(var c=a;c;){if(c.contains(b)||c==b)return c;c=c.parentNode}return null}function c(a,b,c){var d=i.createEvent("HTMLEvents");if(d.initEvent(b,!0,!0),"object"==typeof c)for(var e in c)d[e]=c[e];a.dispatchEvent(d)}function d(a,b,c,d,e,f,g,h){var i=Math.atan2(h-f,g-e)-Math.atan2(d-b,c-a),j=Math.sqrt((Math.pow(h-f,2)+Math.pow(g-e,2))/(Math.pow(d-b,2)+Math.pow(c-a,2))),k=[e-j*a*Math.cos(i)+j*b*Math.sin(i),f-j*b*Math.cos(i)-j*a*Math.sin(i)];return{rotate:i,scale:j,translate:k,matrix:[[j*Math.cos(i),-j*Math.sin(i),k[0]],[j*Math.sin(i),j*Math.cos(i),k[1]],[0,0,1]]}}function e(a){0===Object.keys(l).length&&(j.addEventListener("touchmove",f,!1),j.addEventListener("touchend",g,!1),j.addEventListener("touchcancel",h,!1));for(var d=0;d<a.changedTouches.length;d++){var e=a.changedTouches[d],i={};for(var m in e)i[m]=e[m];var n={startTouch:i,startTime:Date.now(),status:"tapping",element:a.srcElement||a.target,pressingHandler:setTimeout(function(b,d){return function(){"tapping"===n.status&&(n.status="pressing",c(b,"longpress",{touch:d,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a})),clearTimeout(n.pressingHandler),n.pressingHandler=null}}(a.srcElement||a.target,a.changedTouches[d]),500)};l[e.identifier]=n}if(2==Object.keys(l).length){var o=[];for(var m in l)o.push(l[m].element);c(b(o[0],o[1]),"dualtouchstart",{touches:k.call(a.touches),touchEvent:a})}}function f(a){for(var e=0;e<a.changedTouches.length;e++){var f=a.changedTouches[e],g=l[f.identifier];if(!g)return;g.lastTouch||(g.lastTouch=g.startTouch),g.lastTime||(g.lastTime=g.startTime),g.velocityX||(g.velocityX=0),g.velocityY||(g.velocityY=0),g.duration||(g.duration=0);var h=Date.now()-g.lastTime,i=(f.clientX-g.lastTouch.clientX)/h,j=(f.clientY-g.lastTouch.clientY)/h,k=70;h>k&&(h=k),g.duration+h>k&&(g.duration=k-h),g.velocityX=(g.velocityX*g.duration+i*h)/(g.duration+h),g.velocityY=(g.velocityY*g.duration+j*h)/(g.duration+h),g.duration+=h,g.lastTouch={};for(var m in f)g.lastTouch[m]=f[m];g.lastTime=Date.now();var n=f.clientX-g.startTouch.clientX,o=f.clientY-g.startTouch.clientY,p=Math.sqrt(Math.pow(n,2)+Math.pow(o,2));("tapping"===g.status||"pressing"===g.status)&&p>10&&(g.status="panning",g.isVertical=!(Math.abs(n)>Math.abs(o)),c(g.element,"panstart",{touch:f,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a,isVertical:g.isVertical}),c(g.element,(g.isVertical?"vertical":"horizontal")+"panstart",{touch:f,touchEvent:a})),"panning"===g.status&&(g.panTime=Date.now(),c(g.element,"panmove",{displacementX:n,displacementY:o,touch:f,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a,isVertical:g.isVertical}),g.isVertical?c(g.element,"verticalpanmove",{displacementY:o,touch:f,touchEvent:a}):c(g.element,"horizontalpanmove",{displacementX:n,touch:f,touchEvent:a}))}if(2==Object.keys(l).length){for(var q,r=[],s=[],t=[],e=0;e<a.touches.length;e++){var f=a.touches[e],g=l[f.identifier];r.push([g.startTouch.clientX,g.startTouch.clientY]),s.push([f.clientX,f.clientY])}for(var m in l)t.push(l[m].element);q=d(r[0][0],r[0][1],r[1][0],r[1][1],s[0][0],s[0][1],s[1][0],s[1][1]),c(b(t[0],t[1]),"dualtouch",{transform:q,touches:a.touches,touchEvent:a})}}function g(a){if(2==Object.keys(l).length){var d=[];for(var e in l)d.push(l[e].element);c(b(d[0],d[1]),"dualtouchend",{touches:k.call(a.touches),touchEvent:a})}for(var i=0;i<a.changedTouches.length;i++){var n=a.changedTouches[i],o=n.identifier,p=l[o];if(p){if(p.pressingHandler&&(clearTimeout(p.pressingHandler),p.pressingHandler=null),"tapping"===p.status&&(p.timestamp=Date.now(),c(p.element,"tap",{touch:n,touchEvent:a}),m&&p.timestamp-m.timestamp<300&&c(p.element,"doubletap",{touch:n,touchEvent:a}),m=p),"panning"===p.status){var q=Date.now(),r=q-p.startTime,s=((n.clientX-p.startTouch.clientX)/r,(n.clientY-p.startTouch.clientY)/r,n.clientX-p.startTouch.clientX),t=n.clientY-p.startTouch.clientY,u=Math.sqrt(p.velocityY*p.velocityY+p.velocityX*p.velocityX),v=u>.5&&q-p.lastTime<100,w={duration:r,isflick:v,velocityX:p.velocityX,velocityY:p.velocityY,displacementX:s,displacementY:t,touch:n,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a,isVertical:p.isVertical};c(p.element,"panend",w),v&&(c(p.element,"swipe",w),p.isVertical?c(p.element,"verticalswipe",w):c(p.element,"horizontalswipe",w))}"pressing"===p.status&&c(p.element,"pressend",{touch:n,touchEvent:a}),delete l[o]}}0===Object.keys(l).length&&(j.removeEventListener("touchmove",f,!1),j.removeEventListener("touchend",g,!1),j.removeEventListener("touchcancel",h,!1))}function h(a){if(2==Object.keys(l).length){var d=[];for(var e in l)d.push(l[e].element);c(b(d[0],d[1]),"dualtouchend",{touches:k.call(a.touches),touchEvent:a})}for(var i=0;i<a.changedTouches.length;i++){var m=a.changedTouches[i],n=m.identifier,o=l[n];o&&(o.pressingHandler&&(clearTimeout(o.pressingHandler),o.pressingHandler=null),"panning"===o.status&&c(o.element,"panend",{touch:m,touches:a.touches,changedTouches:a.changedTouches,touchEvent:a}),"pressing"===o.status&&c(o.element,"pressend",{touch:m,touchEvent:a}),delete l[n])}0===Object.keys(l).length&&(j.removeEventListener("touchmove",f,!1),j.removeEventListener("touchend",g,!1),j.removeEventListener("touchcancel",h,!1))}var i=a.document,j=i.documentElement,k=Array.prototype.slice,l={},m=null;j.addEventListener("touchstart",e,!1)}(window);;module.exports = window.lib['gesturejs'];

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(59);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./slider.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./slider.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".slider {\n  position: relative;\n}\n\n.slider .indicator-container {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-align: center;\n  box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  font-size: 0;\n}\n.slider .indicator-container .indicator {\n  border-radius: 50%;\n}\n.slider .indicator-container.row {\n  -webkit-box-orient: horizontal;\n  box-orient: horizontal;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}\n.slider .indicator-container.column {\n  -webkit-box-orient: vertical;\n  box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var extend = __webpack_require__(17).extend
	var config = __webpack_require__(16)
	var Atomic = __webpack_require__(39)
	var Component = __webpack_require__(27)
	
	__webpack_require__(61)
	
	var DEFAULT_ITEM_COLOR = '#999'
	var DEFAULT_ITEM_SELECTED_COLOR = '#0000ff'
	var DEFAULT_ITEM_SIZE = 20
	var DEFAULT_MARGIN_SIZE = 10
	
	// Style supported:
	//   position: (default - absolute)
	//   itemColor: color of indicator dots
	//   itemSelectedColor: color of the selected indicator dot
	//   itemSize: size of indicators
	//   other layout styles
	function Indicator (data) {
	  this.direction = 'row' // 'column' is not temporarily supported.
	  this.amount = data.extra.amount
	  this.index = data.extra.index
	  this.sliderWidth = data.extra.width
	  this.sliderHeight = data.extra.height
	  var styles = data.style || {}
	  this.data = data
	  this.style.width.call(this, styles.width)
	  this.style.height.call(this, styles.height)
	  this.items = []
	  Atomic.call(this, data)
	}
	
	Indicator.prototype = Object.create(Atomic.prototype)
	
	Indicator.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-indicators')
	  node.classList.add('weex-element')
	  node.style.position = 'absolute'
	  this.node = node
	  this.style.itemSize.call(this, 0)
	  this.itemColor = DEFAULT_ITEM_COLOR
	  this.itemSelectedColor = DEFAULT_ITEM_SELECTED_COLOR
	  this.updateStyle({
	    left: 0,
	    top: 0,
	    itemSize: 0
	  })
	  return node
	}
	
	Indicator.prototype.createChildren = function () {
	  var root = document.createDocumentFragment()
	  for (var i = 0; i < this.amount; i++) {
	    var indicator = document.createElement('div')
	    indicator.classList.add('weex-indicator')
	    indicator.style.boxSizing = 'border-box'
	    indicator.style.margin = '0 '
	                            + (DEFAULT_MARGIN_SIZE * this.data.scale)
	                            + 'px'
	    indicator.style.width = this.itemSize + 'px'
	    indicator.style.height = this.itemSize + 'px'
	    indicator.setAttribute('index', i)
	    if (this.index === i) {
	      indicator.style.backgroundColor = this.itemSelectedColor
	    } else {
	      indicator.style.backgroundColor = this.itemColor
	    }
	    indicator.addEventListener('click', this._clickHandler.bind(this, i))
	    this.items[i] = indicator
	    root.appendChild(indicator)
	  }
	  this.node.appendChild(root)
	}
	
	Indicator.prototype.style
	    = extend(Object.create(Atomic.prototype.style), {
	  itemColor: function (val) {
	    this.itemColor = val || DEFAULT_ITEM_COLOR
	    for (var i = 0, l = this.items.length; i < l; i++) {
	      this.items[i].style.backgroundColor = this.itemColor
	    }
	  },
	
	  itemSelectedColor: function (val) {
	    this.itemSelectedColor = val || DEFAULT_ITEM_SELECTED_COLOR
	    if (typeof this.index !== 'undefined'
	        && this.items.length > this.index) {
	      this.items[this.index].style.backgroundColor
	          = this.itemSelectedColor
	    }
	  },
	
	  itemSize: function (val) {
	    val = parseInt(val) * this.data.scale
	          || DEFAULT_ITEM_SIZE * this.data.scale
	    this.itemSize = val
	    this.node.style.height = val + 'px'
	    for (var i = 0, l = this.items.length; i < l; i++) {
	      this.items[i].style.width = val + 'px'
	      this.items[i].style.height = val + 'px'
	    }
	  },
	
	  width: function (val) {
	    val = parseInt(val) * this.data.scale || parseInt(this.sliderWidth)
	    this.virtualWrapperWidth = val
	  },
	
	  height: function (val) {
	    val = parseInt(val) * this.data.scale || parseInt(this.sliderHeight)
	    this.virtualWrapperHeight = val
	  },
	
	  top: function (val) {
	    val = this.virtualWrapperHeight / 2 - this.itemSize / 2
	        + val * this.data.scale
	    this.node.style.bottom = ''
	    this.node.style.top = val + 'px'
	  },
	
	  bottom: function (val) {
	    val = this.virtualWrapperHeight / 2 - this.itemSize / 2
	        + val * this.data.scale
	    this.node.style.top = ''
	    this.node.style.bottom = val + 'px'
	  },
	
	  left: function (val) {
	    val = this.virtualWrapperWidth / 2
	          - (this.itemSize + 2 * DEFAULT_MARGIN_SIZE * this.data.scale)
	              * this.amount / 2
	          + val * this.data.scale
	    this.node.style.right = ''
	    this.node.style.left = val + 'px'
	  },
	
	  right: function (val) {
	    val = this.virtualWrapperWidth / 2
	          - (this.itemSize + 2 * DEFAULT_MARGIN_SIZE * this.data.scale)
	              * this.amount / 2
	          + val * this.data.scale
	    this.node.style.left = ''
	    this.node.style.right = val + 'px'
	  }
	})
	
	Indicator.prototype.setIndex = function (idx) {
	  if (idx >= this.amount) {
	    return
	  }
	  var prev = this.items[this.index]
	  var cur = this.items[idx]
	  prev.classList.remove('active')
	  prev.style.backgroundColor = this.itemColor
	  cur.classList.add('active')
	  cur.style.backgroundColor = this.itemSelectedColor
	  this.index = idx
	}
	
	Indicator.prototype._clickHandler = function (idx) {
	  this.slider.slideTo(idx)
	}
	
	module.exports = Indicator


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(62);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./indicator.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./indicator.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-indicators {\n  position: absolute;\n  white-space: nowrap;\n}\n.weex-indicators .weex-indicator {\n  float: left;\n  border-radius: 50%;\n}\n", ""]);
	
	// exports


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	var msgQueue = __webpack_require__(64)
	var config = __webpack_require__(16)
	var utils = __webpack_require__(17)
	
	// TODO: refactor this scss code since this is strongly
	// dependent on lib.flexible other than the value of
	// scale.
	__webpack_require__(65)
	
	function TabHeader(data) {
	  Atomic.call(this, data)
	}
	
	var proto = TabHeader.prototype = Object.create(Atomic.prototype)
	
	proto.create = function () {
	  // outside container.
	  var node = document.createElement('div')
	  node.className = 'tab-header'
	  // tip on the top.
	  var bar = document.createElement('div')
	  bar.className = 'header-bar'
	  bar.textContent = 'CHANGE FLOOR'
	  // middle layer.
	  var body = document.createElement('div')
	  body.className = 'header-body'
	  var box = document.createElement('ul')
	  box.className = 'tabheader'
	
	  body.appendChild(box)
	  node.appendChild(bar)
	  node.appendChild(body)
	  this._bar = bar
	  this._body = body
	  this.box = box
	  this.node = node
	  // init events.
	  this._initFoldBtn()
	  this._initEvent()
	  return node
	}
	
	proto._initFoldBtn = function () {
	  var _this = this
	  var node = this.node
	  var btn = document.createElement('span')
	  btn.className = 'fold-toggle iconfont'
	  btn.innerHTML = '&#xe661;'
	  node.appendChild(btn)
	
	  btn.addEventListener('click', function () {
	    if (_this.unfolding) {
	      _this._folding()
	    } else {
	      _this._unfolding()
	    }
	  })
	}
	
	proto._initMask = function () {
	  var mask = document.createElement('div')
	  mask.className = 'tabheader-mask'
	  this.mask = mask
	  // stop default behavior: page moving.
	  mask.addEventListener('touchmove', function (evt) {
	    evt.preventDefault()
	  })
	  // click to unfold.
	  var _this = this
	  mask.addEventListener('click', function () {
	    _this._folding()
	  })
	
	  document.body.appendChild(mask)
	}
	
	proto._unfolding = function () {
	  // mark the initial posiiton of tabheader
	  if (!this.flag) {
	    var flag = document.createComment('tabheader')
	    this.flag = flag
	    this.node.parentNode.insertBefore(flag, this.node)
	  }
	  if (!this.mask) {
	    this._initMask()
	  }
	
	  // record the scroll position.
	  this._scrollVal = this._body.scrollLeft
	  // record the position in document.
	  this._topVal = this.node.getBoundingClientRect().top
	  this._styleTop = this.node.style.top
	
	  document.body.appendChild(this.node)
	  this.node.classList.add('unfold-header')
	  this.node.style.height = 'auto'
	  // recalc the position when it is unfolded.
	  var thHeight = this.node.getBoundingClientRect().height
	  if (thHeight + this._topVal > window.innerHeight) {
	    this._topVal = this._topVal
	        + (window.innerHeight - thHeight - this._topVal)
	  }
	
	  this.node.style.top = this._topVal + 'px'
	  // process mask style
	  this.mask.classList.add('unfold-header')
	  this.mask.style.height = window.innerHeight + 'px'
	  this.unfolding = true
	}
	
	proto._folding = function () {
	  if (this.unfolding !== true) {
	    return
	  }
	
	  this.mask.classList.remove('unfold-header')
	  this.node.classList.remove('unfold-header')
	
	  this.node.style.height = ''
	  this.node.style.top = this._styleTop
	
	  // recover the position of tabheader.
	  this.flag.parentNode.insertBefore(this.node, this.flag)
	  // recover the position of scoller.
	  this._body.scrollLeft = this._scrollVal
	
	  this._scrollToView()
	  this.unfolding = false
	}
	
	proto._initEvent = function () {
	  this._initClickEvent()
	  this._initSelectEvent()
	}
	
	// init events.
	proto._initClickEvent = function () {
	  var box = this.box
	  var _this = this
	
	  box.addEventListener('click', function (evt) {
	    var target = evt.target
	    if (target.nodeName === 'UL') {
	      return
	    }
	
	    if (target.parentNode.nodeName === 'LI') {
	      target = target.parentNode
	    }
	
	    var floor = target.getAttribute('data-floor')
	
	    if (_this.data.attr.selectedIndex == floor) {
	      // Duplicated clicking, not to trigger select event.
	      return
	    }
	
	    fireEvent(target, 'select', {index:  floor})
	  })
	}
	
	proto._initSelectEvent = function () {
	  var node = this.node
	  var _this = this
	  node.addEventListener('select', function (evt) {
	    var index
	    if (evt.index !== undefined) {
	      index = evt.index
	    } else if (evt.data && evt.data.index !== undefined) {
	      index = evt.data.index
	    }
	
	    if (index === undefined) {
	      return
	    }
	
	    _this.attr.selectedIndex.call(_this, index)
	  })
	}
	
	proto.attr = {
	  highlightIcon: function () {
	    return createHighlightIcon()
	  },
	  data: function () {
	    var attr = this.data.attr
	    // Ensure there is a default selected value.
	    if (attr.selectedIndex === undefined) {
	      attr.selectedIndex = 0
	    }
	
	    var list = attr.data || []
	    var curItem = attr.selectedIndex
	
	    var ret = []
	    var itemTmpl = '<li class="th-item" data-floor="{{floor}}">'
	        + '{{hlIcon}}{{floorName}}</li>'
	
	    list.forEach(function (item, idx) {
	      var html = itemTmpl.replace('{{floor}}', idx)
	      if (curItem == idx) {
	        html = html.replace('{{hlIcon}}', createHighlightIcon())
	      } else {
	        html = html.replace('{{hlIcon}}', '')
	      }
	
	      html = html.replace('{{floorName}}', item)
	
	      ret.push(html)
	    }, this)
	
	    this.box.innerHTML = ret.join('')
	  },
	  selectedIndex: function (val) {
	    var attr = this.data.attr
	
	    if (val === undefined) {
	      val = 0
	    }
	
	    // if (val == attr.selectedIndex) {
	    //   return
	    // }
	
	    attr.selectedIndex = val
	
	    this.attr.data.call(this)
	
	    this._folding()
	    this.style.textHighlightColor.call(this, this.textHighlightColor)
	  }
	}
	
	proto.style = Object.create(Atomic.prototype.style)
	
	proto.style.opacity = function (val) {
	  if (val === undefined || val < 0 || val > 1) {
	    val = 1
	  }
	
	  this.node.style.opacity = val
	}
	
	proto.style.textColor = function (val) {
	  if (!isValidColor(val)) {
	    return
	  }
	
	  this.node.style.color = val
	}
	
	proto.style.textHighlightColor = function (val) {
	  if (!isValidColor(val)) {
	    return
	  }
	  this.textHighlightColor = val
	  var attr = this.data.attr
	
	  var node = this.node.querySelector('[data-floor="'
	      + attr.selectedIndex + '"]')
	  if (node) {
	    node.style.color = val
	    this._scrollToView(node)
	  }
	}
	
	proto._scrollToView = function (node) {
	  if (!node) {
	    var attr = this.data.attr
	    node = this.node.querySelector('[data-floor="' + attr.selectedIndex + '"]')
	  }
	  if (!node) {
	    return
	  }
	
	  var defaultVal = this._body.scrollLeft
	  var leftVal = defaultVal  - node.offsetLeft + 300
	
	  var scrollVal = getScrollVal(this._body.getBoundingClientRect(), node)
	  doScroll(this._body, scrollVal)
	}
	
	// scroll the tabheader.
	// positive val means to scroll right.
	// negative val means to scroll left.
	function doScroll(node, val, finish) {
	  if (!val) {
	    return
	  }
	  if (finish === undefined) {
	    finish = Math.abs(val)
	  }
	
	  if (finish <= 0) {
	    return
	  }
	
	  setTimeout(function () {
	    if (val > 0) {
	      node.scrollLeft += 2
	    } else {
	      node.scrollLeft -= 2
	    }
	    finish -= 2
	
	    doScroll(node, val, finish)
	  })
	}
	
	// get scroll distance.
	function getScrollVal(rect, node) {
	  var left = node.previousSibling
	  var right = node.nextSibling
	  var scrollVal
	
	  // process left-side element first.
	  if (left) {
	    var leftRect = left.getBoundingClientRect()
	    // only need to compare the value of left.
	    if (leftRect.left < rect.left) {
	      scrollVal = leftRect.left
	      return scrollVal
	    }
	  }
	
	  if (right) {
	    var rightRect = right.getBoundingClientRect()
	    // compare the value of right.
	    if (rightRect.right > rect.right) {
	      scrollVal = rightRect.right - rect.right
	      return scrollVal
	    }
	  }
	
	  // process current node, from left to right.
	  var nodeRect = node.getBoundingClientRect()
	  if (nodeRect.left < rect.left) {
	    scrollVal = nodeRect.left
	  } else if (nodeRect.right > rect.right) {
	    scrollVal = nodeRect.right - rect.right
	  }
	
	  return scrollVal
	}
	
	// trigger and broadcast events.
	function fireEvent(element, type, data) {
	  var evt = document.createEvent('Event')
	  evt.data = data
	  utils.extend(evt, data)
	  // need bubble.
	  evt.initEvent(type, true, true)
	
	  element.dispatchEvent(evt)
	}
	
	function createHighlightIcon(code) {
	  var html = '<i class="hl-icon iconfont">' + '&#xe650' + '</i>'
	  return html
	}
	
	function isValidColor(color) {
	  if (!color) {
	    return false
	  }
	
	  if (color.charAt(0) !== '#') {
	    return false
	  }
	
	  if (color.length !== 7) {
	    return false
	  }
	
	  return true
	}
	
	module.exports = TabHeader


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var config = __webpack_require__(16)
	var messageQueue = []
	
	function flushMessage() {
	  if (typeof callJS === 'function' && messageQueue.length > 0) {
	    callJS(config.instanceId, JSON.stringify(messageQueue))
	    messageQueue.length = 0
	  }
	}
	
	function push(msg) {
	  messageQueue.push(msg)
	}
	
	/**
	 * To fix the problem of callapp, the two-way time loop mechanism must
	 * be replaced by directly procedure call except the situation of
	 * page loading.
	 * 2015-11-03
	 */
	function pushDirectly(msg) {
	  callJS(config.instanceId, [msg])
	}
	
	module.exports = {
	  push: pushDirectly
	}


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(66);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./tabheader.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./tabheader.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".tab-header {\n  position: relative;\n  width: 10rem;\n  font-size: 14px;\n  color: #333;\n}\n.tab-header .header-bar {\n  height: 1.17rem;\n  line-height: 1.17rem;\n  display: none;\n  color: #999;\n  padding-left: 0.4rem;\n}\n.tab-header .header-body {\n  margin-right: 1.07rem;\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n.tab-header .header-body::-webkit-scrollbar {\n  width: 0;\n  height: 0;\n  overflow: hidden;\n}\n.tab-header .fold-toggle {\n  position: absolute;\n  top: 0.59rem;\n  -webkit-transform: translateY(-50%);\n  right: 0.29rem;\n  width: 0.48rem;\n  height: 0.48rem;\n  line-height: 0.48rem;\n  text-align: center;\n  z-index: 99;\n  font-size: 14px;\n}\n.tab-header.unfold-header {\n  position: fixed !important;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.tabheader {\n  list-style: none;\n  white-space: nowrap;\n  height: 1.17rem;\n  line-height: 1.17rem;\n}\n.tabheader .th-item {\n  padding-left: 0.72rem;\n  position: relative;\n  display: inline-block;\n}\n.tabheader .hl-icon {\n  width: 0.4rem;\n  height: 0.4rem;\n  line-height: 0.4rem;\n  text-align: center;\n  position: absolute;\n  top: 50%;\n  -webkit-transform: translateY(-50%);\n  left: 0.24rem;\n  font-size: 14px;\n}\n\n.unfold-header .header-bar {\n  display: block;\n}\n.unfold-header .fold-toggle {\n  -webkit-transform: translateY(-50%) rotate(180deg);\n}\n.unfold-header .header-body {\n  margin-right: 0;\n  padding: 0.24rem;\n}\n.unfold-header .tabheader {\n  display: block;\n  height: auto;\n}\n.unfold-header .th-item {\n  box-sizing: border-box;\n  float: left;\n  width: 33.3333%;\n  height: 1.01rem;\n  line-height: 1.01rem;\n}\n.unfold-header .hl-icon {\n  margin-right: 0;\n  position: absolute;\n}\n.unfold-header.tabheader-mask {\n  display: block;\n  width: 100%;\n  height: 100%;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n\n.tabheader-mask {\n  display: none;\n  position: fixed;\n  left: 0;\n  top: 0;\n}\n\n@font-face {\n  font-family: \"iconfont\";\n  src: url(\"data:application/x-font-ttf;charset=utf-8;base64,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R7AEQ7CAYmAgsAArIIqKYSCwAkNgZCOwA0NhZFBYsAJDYRuwA0NgWbADJbCAYmGwAiVGYTgjIDwjOBshICBGI0ewACsjYTghWbEkARQrLbA7LLAuKy6xJAEUKy2wPCywLyshIyAgPLAEI0IjOLEkARQrsARDLrAkKy2wPSywABUgR7AAI0KyAAEBFRQTLrAqKi2wPiywABUgR7AAI0KyAAEBFRQTLrAqKi2wPyyxAAEUE7ArKi2wQCywLSotsEEssAAWRSMgLiBGiiNhOLEkARQrLbBCLLAJI0KwQSstsEMssgAAOistsEQssgABOistsEUssgEAOistsEYssgEBOistsEcssgAAOystsEgssgABOystsEkssgEAOystsEossgEBOystsEsssgAANystsEwssgABNystsE0ssgEANystsE4ssgEBNystsE8ssgAAOSstsFAssgABOSstsFEssgEAOSstsFIssgEBOSstsFMssgAAPCstsFQssgABPCstsFUssgEAPCstsFYssgEBPCstsFcssgAAOCstsFgssgABOCstsFkssgEAOCstsFossgEBOCstsFsssDArLrEkARQrLbBcLLAwK7A0Ky2wXSywMCuwNSstsF4ssAAWsDArsDYrLbBfLLAxKy6xJAEUKy2wYCywMSuwNCstsGEssDErsDUrLbBiLLAxK7A2Ky2wYyywMisusSQBFCstsGQssDIrsDQrLbBlLLAyK7A1Ky2wZiywMiuwNistsGcssDMrLrEkARQrLbBoLLAzK7A0Ky2waSywMyuwNSstsGossDMrsDYrLbBrLCuwCGWwAyRQeLABFTAtAABLuADIUlixAQGOWbkIAAgAYyCwASNEILADI3CwDkUgIEu4AA5RS7AGU1pYsDQbsChZYGYgilVYsAIlYbABRWMjYrACI0SzCgkFBCuzCgsFBCuzDg8FBCtZsgQoCUVSRLMKDQYEK7EGAUSxJAGIUViwQIhYsQYDRLEmAYhRWLgEAIhYsQYBRFlZWVm4Af+FsASNsQUARAAAAA==\") format(\"truetype\");\n}\n.iconfont {\n  font-family: iconfont !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -webkit-text-stroke-width: 0.2px;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n[data-dpr=\"2\"] .tab-header {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tab-header {\n  font-size: 42px;\n}\n\n[data-dpr=\"2\"] .tabheader .hl-icon {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tabheader .hl-icon {\n  font-size: 42px;\n}\n\n[data-dpr=\"2\"] .tab-header .fold-toggle {\n  font-size: 28px;\n}\n\n[data-dpr=\"3\"] .tab-header .fold-toggle {\n  font-size: 42px;\n}\n", ""]);
	
	// exports


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(68)
	__webpack_require__(47)
	
	// lib.scroll events:
	//  - scrollstart
	//  - scrolling
	//  - pulldownend
	//  - pullupend
	//  - pullleftend
	//  - pullrightend
	//  - pulldown
	//  - pullup
	//  - pullleft
	//  - pullright
	//  - contentrefresh
	
	var Component = __webpack_require__(27)
	var utils = __webpack_require__(17)
	
	var directionMap = {
	  h: ['row', 'horizontal', 'h', 'x'],
	  v: ['column', 'vertical', 'v', 'y']
	}
	
	var DEFAULT_DIRECTION = 'column'
	
	// attrs:
	//  - scroll-direciton: none|vertical|horizontal (default is vertical)
	//  - show-scrollbar: true|false (default is true)
	function Scroller (data, nodeType) {
	  var attrs = data.attr || {}
	  var direction = attrs.scrollDirection
	    || attrs.direction
	    || DEFAULT_DIRECTION
	  this.direction = directionMap.h.indexOf(direction) === -1
	    ? 'v'
	    : 'h'
	  this.showScrollbar = attrs.showScrollbar || true
	  Component.call(this, data, nodeType)
	}
	
	Scroller.prototype = Object.create(Component.prototype)
	
	Scroller.prototype.create = function (nodeType) {
	  var Scroll = lib.scroll
	  var node = Component.prototype.create.call(this, nodeType)
	  node.classList.add('weex-container', 'scroll-wrap')
	  this.scrollElement = document.createElement('div')
	  this.scrollElement.classList.add(
	    'weex-container',
	    'scroll-element',
	    this.direction + '-scroller'
	  )
	
	  // Flex will cause a bug to rescale children's size if their total
	  // size exceed the limit of their parent. So to use box instead.
	  this.scrollElement.style.display = '-webkit-box'
	  this.scrollElement.style.display = 'box'
	  this.scrollElement.style.webkitBoxOrient = this.direction === 'h'
	    ? 'horizontal'
	    : 'vertical'
	  this.scrollElement.style.boxOrient = this.scrollElement.style.webkitBoxOrient
	
	  node.appendChild(this.scrollElement)
	  this.scroller = new Scroll({
	    // if the direction is x, then the bounding rect of the scroll element
	    // should be got by the 'Range' API other than the 'getBoundingClientRect'
	    // API, because the width outside the viewport won't be count in by
	    // 'getBoundingClientRect'.
	    // Otherwise should use the element rect in case there is a child scroller
	    // or list in this scroller. If using 'Range', the whole scroll element
	    // including the hiding part will be count in the rect.
	    useElementRect: this.direction === 'v',
	    scrollElement: this.scrollElement,
	    direction: this.direction === 'h' ? 'x' : 'y'
	  })
	  this.scroller.init()
	  this.offset = 0
	  return node
	}
	
	Scroller.prototype.bindEvents = function (evts) {
	  Component.prototype.bindEvents.call(this, evts)
	  // to enable lazyload for Images
	  this.scroller.addEventListener('scrolling', function (e) {
	    var so = e.scrollObj
	    var scrollTop = so.getScrollTop()
	    var scrollLeft = so.getScrollLeft()
	    var offset = this.direction === 'v' ? scrollTop : scrollLeft
	    var diff = offset - this.offset
	    var dir
	    if (diff >= 0) {
	      dir = this.direction === 'v' ? 'up' : 'left'
	    } else {
	      dir = this.direction === 'v' ? 'down' : 'right'
	    }
	    this.dispatchEvent('scroll', {
	      originalType: 'scrolling',
	      scrollTop: so.getScrollTop(),
	      scrollLeft: so.getScrollLeft(),
	      offset: offset,
	      direction: dir
	    }, {
	      bubbles: true
	    })
	    this.offset = offset
	  }.bind(this))
	
	  var pullendEvent = 'pull'
	    + ({ v: 'up', h: 'left' })[this.direction]
	    + 'end'
	  this.scroller.addEventListener(pullendEvent, function (e) {
	    this.dispatchEvent('loadmore')
	  }.bind(this))
	}
	
	Scroller.prototype.createChildren = function () {
	  var children = this.data.children
	  var parentRef = this.data.ref
	  var componentManager = this.getComponentManager()
	  if (children && children.length) {
	    var fragment = document.createDocumentFragment()
	    var isFlex = false
	    for (var i = 0; i < children.length; i++) {
	      children[i].instanceId = this.data.instanceId
	      children[i].scale = this.data.scale
	      var child = componentManager.createElement(children[i])
	      fragment.appendChild(child.node)
	      child.parentRef = parentRef
	      if (!isFlex
	          && child.data.style
	          && child.data.style.hasOwnProperty('flex')
	        ) {
	        isFlex = true
	      }
	    }
	    this.scrollElement.appendChild(fragment)
	  }
	  // wait for fragment to appended on scrollElement on UI thread.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	Scroller.prototype.appendChild = function (data) {
	  var children = this.data.children
	  var componentManager = this.getComponentManager()
	  var child = componentManager.createElement(data)
	  this.scrollElement.appendChild(child.node)
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	
	  // update this.data.children
	  if (!children || !children.length) {
	    this.data.children = [data]
	  } else {
	    children.push(data)
	  }
	
	  return child
	}
	
	Scroller.prototype.insertBefore = function (child, before) {
	  var children = this.data.children
	  var i = 0
	  var isAppend = false
	
	  // update this.data.children
	  if (!children || !children.length || !before) {
	    isAppend = true
	  } else {
	    for (var l = children.length; i < l; i++) {
	      if (children[i].ref === before.data.ref) {
	        break
	      }
	    }
	    if (i === l) {
	      isAppend = true
	    }
	  }
	
	  if (isAppend) {
	    this.scrollElement.appendChild(child.node)
	    children.push(child.data)
	  } else {
	    if (before.fixedPlaceholder) {
	      this.scrollElement.insertBefore(child.node, before.fixedPlaceholder)
	    } else {
	      this.scrollElement.insertBefore(child.node, before.node)
	    }
	    children.splice(i, 0, child.data)
	  }
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	Scroller.prototype.removeChild = function (child) {
	  var children = this.data.children
	  // remove from this.data.children
	  var i = 0
	  var componentManager = this.getComponentManager()
	  if (children && children.length) {
	    for (var l = children.length; i < l; i++) {
	      if (children[i].ref === child.data.ref) {
	        break
	      }
	    }
	    if (i < l) {
	      children.splice(i, 1)
	    }
	  }
	  // remove from componentMap recursively
	  componentManager.removeElementByRef(child.data.ref)
	  if (child.fixedPlaceholder) {
	    this.scrollElement.removeChild(child.fixedPlaceholder)
	  }
	  child.node.parentNode.removeChild(child.node)
	
	  // wait for UI thread to update.
	  setTimeout(function () {
	    this.scroller.refresh()
	  }.bind(this), 0)
	}
	
	module.exports = Scroller


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(69);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./scroller.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./scroller.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".scroll-wrap {\n  display: block;\n  overflow: hidden;\n}\n\n.scroll-element.horizontal {\n  -webkit-box-orient: horizontal;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}\n.scroll-element.vertical {\n  -webkit-box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	var utils = __webpack_require__(17)
	
	// attrs:
	//   - type: text|password|tel|email|url
	//   - value
	//   - placeholder
	//   - disabled
	//   - autofocus
	function Input (data) {
	  var attrs = data.attr || {}
	  this.type = attrs.type || 'text'
	  this.value = attrs.value
	  this.placeholder = attrs.placeholder
	  this.autofocus = attrs.autofocus && (attrs.autofocus !== 'false')
	                    ? true
	                    : false
	  Atomic.call(this, data)
	}
	
	Input.prototype = Object.create(Atomic.prototype)
	
	Input.prototype.create = function () {
	  var node = document.createElement('input')
	  var uuid = Math.floor(10000000000000 * Math.random()) + Date.now()
	  this.className = 'weex-ipt-' + uuid
	  this.styleId = 'weex-style-' + uuid
	  node.classList.add(this.className)
	  node.setAttribute('type', this.type)
	  node.type = this.type
	  // For the consistency of input component's width.
	  // The date and time type of input will have a bigger width
	  // when the 'box-sizing' is not set to 'border-box'
	  node.classList.add('weex-element')
	  this.value && (node.value = this.value)
	  this.placeholder && (node.placeholder = this.placeholder)
	  return node
	}
	
	Input.prototype.updateStyle = function (style) {
	  Atomic.prototype.updateStyle.call(this, style)
	  if (style && style.placeholderColor) {
	    this.placeholderColor = style.placeholderColor
	    this.setPlaceholderColor()
	  }
	}
	
	Input.prototype.attr = {
	  disabled: function (val) {
	    this.node.disabled = val && val !== 'false'
	                    ? true
	                    : false
	  }
	}
	
	Input.prototype.setPlaceholderColor = function () {
	  if (!this.placeholderColor) {
	    return
	  }
	  var vendors = [
	    '::-webkit-input-placeholder',
	    ':-moz-placeholder',
	    '::-moz-placeholder',
	    ':-ms-input-placeholder',
	    ':placeholder-shown'
	  ]
	  var css = ''
	  var cssRule = 'color: ' + this.placeholderColor + ';'
	  for (var i = 0, l = vendors.length; i < l; i++) {
	    css += '.' + this.className + vendors[i] + '{'
	           + cssRule + '}'
	  }
	  utils.appendStyle(css, this.styleId, true)
	}
	
	module.exports = Input


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(27)
	var sender = __webpack_require__(31)
	
	// attrs:
	//   - options: the options to be listed, as a array of strings.
	//   - selectedIndex: the selected options' index number.
	//   - disabled
	function Select (data) {
	  var attrs = data.attr || {}
	  this.options = []
	  this.selectedIndex = 0
	  Atomic.call(this, data)
	}
	
	Select.prototype = Object.create(Atomic.prototype)
	
	Select.prototype.create = function () {
	  var node = document.createElement('select')
	  var uuid = Math.floor(10000000000000 * Math.random()) + Date.now()
	  this.className = 'weex-slct-' + uuid
	  this.styleId = 'weex-style-' + uuid
	  node.classList.add(this.className)
	  // For the consistency of input component's width.
	  // The date and time type of input will have a bigger width
	  // when the 'box-sizing' is not set to 'border-box'
	  node.style['box-sizing'] = 'border-box'
	  return node
	}
	
	Select.prototype.attr = {
	  disabled: function (val) {
	    this.node.disabled = val && val !== 'false'
	                    ? true
	                    : false
	  },
	  options: function (val) {
	    if (Object.prototype.toString.call(val) !== '[object Array]') {
	      return
	    }
	    this.options = val
	    this.node.innerHTML = ''
	    this.createOptions(val)
	  },
	  selectedIndex: function (val) {
	    val = parseInt(val)
	    if (typeof val !== 'number' || val !== val || val >= this.options.length) {
	      return
	    }
	    this.node.value = this.options[val]
	  }
	}
	
	Select.prototype.bindEvents = function (evts) {
	  var isListenToChange = false
	  Atomic.prototype.bindEvents.call(
	      this,
	      evts.filter(function (val) {
	        var pass = val !== 'change'
	        !pass && (isListenToChange = true)
	        return pass
	      }))
	  if (isListenToChange) {
	    this.node.addEventListener('change', function (e) {
	      e.index = this.options.indexOf(this.node.value)
	      sender.fireEvent(this.data.ref, 'change', e)
	    }.bind(this))
	  }
	}
	
	Select.prototype.createOptions = function (opts) {
	  var optDoc = document.createDocumentFragment()
	  var opt
	  for (var i = 0, l = opts.length; i < l; i++) {
	    opt = document.createElement('option')
	    opt.appendChild(document.createTextNode(opts[i]))
	    optDoc.appendChild(opt)
	  }
	  this.node.appendChild(optDoc)
	}
	
	module.exports = Select


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	
	// attrs:
	//   - value
	//   - disabled
	function Datepicker (data) {
	  Atomic.call(this, data)
	}
	
	Datepicker.prototype = Object.create(Atomic.prototype)
	
	Datepicker.prototype.create = function () {
	  var node = document.createElement('input')
	  var uuid = Math.floor(10000000000000 * Math.random()) + Date.now()
	  this.className = 'weex-ipt-' + uuid
	  this.styleId = 'weex-style-' + uuid
	  node.classList.add(this.className)
	  node.setAttribute('type', 'date')
	  node.type = 'date'
	  // For the consistency of input component's width.
	  // The date and time type of input will have a bigger width
	  // when the 'box-sizing' is not set to 'border-box'
	  node.classList.add('weex-element')
	  return node
	}
	
	Datepicker.prototype.attr = {
	  disabled: function (val) {
	    this.node.disabled = val && val !== 'false'
	                    ? true
	                    : false
	  }
	}
	
	module.exports = Datepicker


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	
	// attrs:
	//   - value
	//   - disabled
	function Timepicker (data) {
	  Atomic.call(this, data)
	}
	
	Timepicker.prototype = Object.create(Atomic.prototype)
	
	Timepicker.prototype.create = function () {
	  var node = document.createElement('input')
	  var uuid = Math.floor(10000000000000 * Math.random()) + Date.now()
	  this.className = 'weex-ipt-' + uuid
	  this.styleId = 'weex-style-' + uuid
	  node.classList.add(this.className)
	  node.setAttribute('type', 'time')
	  node.type = 'time'
	  // For the consistency of input component's width.
	  // The date and time type of input will have a bigger width
	  // when the 'box-sizing' is not set to 'border-box'
	  node.classList.add('weex-element')
	  return node
	}
	
	Timepicker.prototype.attr = {
	  disabled: function (val) {
	    this.node.disabled = val && val !== 'false'
	                    ? true
	                    : false
	  }
	}
	
	module.exports = Timepicker


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	var utils = __webpack_require__(17)
	__webpack_require__(75)
	
	// attrs:
	//   - autoPlay: true | false (default: false)
	//   - playStatus: play | pause | stop
	//   - src: {string}
	//   - poster: {string}
	//   - loop: true | false (default: false)
	//   - muted: true | false (default: false)
	// events:
	//   - start
	//   - pause
	//   - finish
	//   - fail
	function Video (data) {
	  var autoPlay = data.attr.autoPlay
	  var playStatus = data.attr.playStatus
	  this.autoPlay = autoPlay === true || autoPlay === 'true'
	  if (playStatus !== 'play'
	      && playStatus !== 'stop'
	      && playStatus !== 'pause') {
	    this.playStatus = 'pause'
	  } else {
	    this.playStatus = playStatus
	  }
	  Atomic.call(this, data)
	}
	
	Video.prototype = Object.create(Atomic.prototype)
	
	Video.prototype.attr = {
	  playStatus: function (val) {
	    if (val !== 'play' && val !== 'stop' && val !== 'pause') {
	      val = 'pause'
	    }
	    if (this.playStatus === val) {
	      return
	    }
	    this.playStatus = val
	    this.node.setAttribute('play-status', val)
	    this[this.playStatus]()
	  },
	  autoPlay: function (val) {
	    // DO NOTHING
	  }
	}
	
	Video.prototype.create = function () {
	  var node = document.createElement('video')
	  node.classList.add('weex-video', 'weex-element')
	  node.controls = true
	  node.autoplay = this.autoPlay
	  node.setAttribute('play-status', this.playStatus)
	  this.node = node
	  if (this.autoPlay && this.playStatus === 'play') {
	    this.play()
	  }
	  return node
	}
	
	Video.prototype.bindEvents = function (evts) {
	  Atomic.prototype.bindEvents.call(this, evts)
	
	  // convert w3c-video events to weex-video events.
	  var evtsMap = {
	    start: 'play',
	    finish: 'ended',
	    fail: 'error'
	  }
	  for (var evtName in evtsMap) {
	    this.node.addEventListener(evtsMap[evtName], function (type, e) {
	      this.dispatchEvent(type, e.data)
	    }.bind(this, evtName))
	  }
	}
	
	Video.prototype.play = function () {
	  var src = this.node.getAttribute('src')
	  if (!src) {
	    src = this.node.getAttribute('data-src')
	    src && this.node.setAttribute('src', src)
	  }
	  this.node.play()
	}
	
	Video.prototype.pause = function () {
	  this.node.pause()
	}
	
	Video.prototype.stop = function () {
	  this.node.pause()
	  this.node.autoplay = false
	  this.node.setAttribute('data-src', this.node.src)
	  this.node.src = ''
	}
	
	module.exports = Video


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(76);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./video.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./video.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-video {\n\tbackground-color: #000;\n}", ""]);
	
	// exports


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	var utils = __webpack_require__(17)
	__webpack_require__(78)
	
	var defaults = {
	  color: '#64bd63'
	  , secondaryColor: '#dfdfdf'
	  , jackColor: '#fff'
	  , jackSecondaryColor: null
	  , className: 'weex-switch'
	  , disabledOpacity: 0.5
	  , speed: '0.4s'
	  , width: 100
	  , height: 60
	  // is width and height scalable ?
	  , scalable: false
	}
	
	// attrs:
	//   - checked: if is checked.
	//   - disabled: if true, this component is not available for interaction.
	function Switch (data) {
	  this.options = utils.extend({}, defaults)
	  this.checked = data.attr.checked
	      && data.attr.checked !== 'false' ? true : false
	  this.data = data
	  this.width = this.options.width * data.scale
	  this.height = this.options.height * data.scale
	  Atomic.call(this, data)
	}
	
	Switch.prototype = Object.create(Atomic.prototype)
	
	Switch.prototype.create = function () {
	  var node = document.createElement('span')
	  this.jack = document.createElement('small')
	  node.appendChild(this.jack)
	  node.className = this.options.className
	  this.node = node
	  this.attr.disabled.call(this, this.data.attr.disabled)
	  return node
	}
	
	Switch.prototype.onAppend = function () {
	  this.setSize()
	  this.setPosition()
	}
	
	Switch.prototype.attr = {
	  disabled: function (val) {
	    this.disabled = val && val !== 'false'
	                    ? true
	                    : false
	    this.disabled ? this.disable() : this.enable()
	  }
	}
	
	Switch.prototype.setSize = function () {
	  var min = Math.min(this.width, this.height)
	  var max = Math.max(this.width, this.height)
	  this.node.style.width = max + 'px'
	  this.node.style.height = min + 'px'
	  this.node.style.borderRadius = min / 2 + 'px'
	  this.jack.style.width
	      = this.jack.style.height
	      = min + 'px'
	}
	
	Switch.prototype.setPosition = function (clicked) {
	  var checked = this.checked
	  var node = this.node
	  var jack = this.jack
	
	  if (clicked && checked) {
	    checked = false
	  } else if (clicked && !checked) {
	    checked = true
	  }
	
	  if (checked === true) {
	    this.checked = true
	
	    if (window.getComputedStyle) {
	      jack.style.left = parseInt(window.getComputedStyle(node).width)
	                        - parseInt(window.getComputedStyle(jack).width) + 'px'
	    } else {
	      jack.style.left = parseInt(node.currentStyle['width'])
	                        - parseInt(jack.currentStyle['width']) + 'px'
	    }
	
	    this.options.color && this.colorize()
	    this.setSpeed()
	  } else {
	    this.checked = false
	    jack.style.left = 0
	    node.style.boxShadow = 'inset 0 0 0 0 ' + this.options.secondaryColor
	    node.style.borderColor = this.options.secondaryColor
	    node.style.backgroundColor
	        = (this.options.secondaryColor !== defaults.secondaryColor)
	          ? this.options.secondaryColor
	          : '#fff'
	    jack.style.backgroundColor
	        = (this.options.jackSecondaryColor !== this.options.jackColor)
	          ? this.options.jackSecondaryColor
	          : this.options.jackColor
	    this.setSpeed()
	  }
	}
	
	Switch.prototype.colorize = function () {
	  var nodeHeight = this.node.offsetHeight / 2
	
	  this.node.style.backgroundColor = this.options.color
	  this.node.style.borderColor = this.options.color
	  this.node.style.boxShadow = 'inset 0 0 0 '
	                              + nodeHeight
	                              + 'px '
	                              + this.options.color
	  this.jack.style.backgroundColor = this.options.jackColor
	}
	
	Switch.prototype.setSpeed = function () {
	  var switcherProp = {}
	  var jackProp = {
	      'background-color': this.options.speed
	      , left: this.options.speed.replace(/[a-z]/, '') / 2 + 's'
	    }
	
	  if (this.checked) {
	    switcherProp = {
	      border: this.options.speed
	      , 'box-shadow': this.options.speed
	      , 'background-color': this.options.speed.replace(/[a-z]/, '') * 3 + 's'
	    }
	  } else {
	    switcherProp = {
	      border: this.options.speed
	      , 'box-shadow': this.options.speed
	    }
	  }
	
	  utils.transitionize(this.node, switcherProp)
	  utils.transitionize(this.jack, jackProp)
	}
	
	Switch.prototype.disable = function () {
	  !this.disabled && (this.disabled = true)
	  this.node.style.opacity = defaults.disabledOpacity
	  this.node.removeEventListener('click', this.getClickHandler())
	}
	
	Switch.prototype.enable = function () {
	  this.disabled && (this.disabled = false)
	  this.node.style.opacity = 1
	  this.node.addEventListener('click', this.getClickHandler())
	}
	
	Switch.prototype.getClickHandler = function () {
	  if (!this._clickHandler) {
	    this._clickHandler = function () {
	      // var parent = this.node.parentNode.tagName.toLowerCase()
	      // var labelParent = (parent === 'label') ? false : true
	      this.setPosition(true)
	      this.dispatchEvent('change', {
	        checked: this.checked
	      })
	    }.bind(this)
	  }
	  return this._clickHandler
	}
	
	Switch.prototype.style
	    = utils.extend(Object.create(Atomic.prototype.style), {
	
	      width: function (val) {
	        if (!this.options.scalable) {
	          return
	        }
	        val = parseFloat(val)
	        if (val !== val || val < 0) { // NaN
	          val = this.options.width
	        }
	        this.width = val * this.data.scale
	        this.setSize()
	      },
	
	      height: function (val) {
	        if (!this.options.scalable) {
	          return
	        }
	        val = parseFloat(val)
	        if (val !== val || val < 0) { // NaN
	          val = this.options.height
	        }
	        this.height = val * this.data.scale
	        this.setSize()
	      }
	
	    })
	
	module.exports = Switch


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(79);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./switch.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./switch.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, "/* switch defaults. */\n.weex-switch {\n  background-color: #fff;\n  border: 1px solid #dfdfdf;\n  cursor: pointer;\n  display: inline-block;\n  position: relative;\n  vertical-align: middle;\n  -moz-user-select: none;\n  -khtml-user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  box-sizing: content-box;\n  background-clip: content-box;\n}\n\n.weex-switch > small {\n  background: #fff;\n  border-radius: 100%;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);\n  position: absolute;\n  top: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var logger = __webpack_require__(15)
	var Component = __webpack_require__(27)
	
	// attrs:
	//   - href
	function A (data) {
	  Component.call(this, data)
	}
	
	A.prototype = Object.create(Component.prototype)
	
	A.prototype.create = function () {
	  var node = document.createElement('a')
	  node.classList.add('weex-container')
	  node.style.textDecoration = 'none'
	  return node
	}
	
	A.prototype.attr = {
	  href: function (val) {
	    if (!val) {
	      return logger.warn('href of <a> should not be a null value.')
	    }
	    this.href = val
	    this.node.setAttribute('data-href', val)
	  }
	}
	
	A.prototype.bindEvents = function (evts) {
	  // event handler for click event will be processed
	  // before the url redirection.
	  Component.prototype.bindEvents.call(this, evts)
	  this.node.addEventListener('click', function (evt) {
	    if (evt._alreadyFired && evt.target !== this.node) {
	      // if the event target is this.node, then this is
	      // just another click event handler for the same
	      // target, not a handler for a bubbling up event,
	      // otherwise it is a bubbling up event, and it
	      // should be disregarded.
	      return
	    }
	    evt._alreadyFired = true
	    location.href = this.href
	  }.bind(this))
	}
	
	module.exports = A


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Component = __webpack_require__(27)
	var utils = __webpack_require__(17)
	
	var ID_PREFIX = 'weex_embed_'
	
	function _generateId() {
	  return ID_PREFIX + utils.getRandom(10)
	}
	
	function Embed (data, nodeType) {
	  var attr = data.attr
	  if (attr) {
	    this.source = attr.src
	    this.loader = attr.loader || 'xhr'
	    this.jsonpCallback = attr.jsonpCallback
	  }
	  Component.call(this, data, nodeType)
	}
	
	Embed.prototype = Object.create(Component.prototype)
	
	Embed.prototype.create = function () {
	  var node = document.createElement('div')
	  node.id = this.id
	  node.style.overflow = 'scroll'
	  return node
	}
	
	Embed.prototype.initWeex = function () {
	  this.id = _generateId()
	  this.node.id = this.id
	  var config = {
	    appId: this.id,
	    source: this.source,
	    bundleUrl: this.source,
	    loader: this.loader,
	    jsonpCallback: this.jsonpCallback,
	    width: this.node.getBoundingClientRect().width,
	    rootId: this.id,
	    embed: true
	  }
	  window.weex.init(config)
	}
	
	Embed.prototype.destroyWeex = function () {
	  this.id && window.destroyInstance(this.id)
	  // TODO: unbind events and clear doms.
	  this.node.innerHTML = ''
	}
	
	Embed.prototype.reloadWeex = function () {
	  if (this.id) {
	    this.destroyWeex()
	    this.id = null
	    this.node.id = null
	    this.node.innerHTML = ''
	  }
	  this.initWeex()
	}
	
	// not recommended, because of the leak of memory.
	Embed.prototype.attr = {
	  src: function (value) {
	    this.source = value
	    this.reloadWeex()
	  }
	}
	
	module.exports = Embed


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Component = __webpack_require__(27)
	
	__webpack_require__(83)
	
	var parents = ['scroller', 'list']
	
	// Only if pulldown offset is larger than this value can this
	// component trigger the 'refresh' event, otherwise just recover
	// to the start point.
	var CLAMP = 130
	
	var ua = window.navigator.userAgent
	var Firefox = !!ua.match(/Firefox/i)
	var IEMobile = !!ua.match(/IEMobile/i)
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-'
	
	function Refresh (data) {
	  Component.call(this, data)
	}
	
	Refresh.prototype = Object.create(Component.prototype)
	
	Refresh.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container', 'weex-refresh')
	  return node
	}
	
	Refresh.prototype.onAppend = function () {
	  var parent = this.getParent()
	  var self = this
	  if (parents.indexOf(parent.data.type) === -1) {
	    return
	  }
	  parent.scroller.addEventListener('pulldown', function (e) {
	    self.adjustHeight(Math.abs(e.scrollObj.getScrollTop()))
	    if (!this.display) {
	      self.show()
	    }
	  })
	  parent.scroller.addEventListener('pulldownend', function (e) {
	    var top = Math.abs(e.scrollObj.getScrollTop())
	    if (top > CLAMP) {
	      self.handleRefresh(e)
	    }
	  })
	}
	
	Refresh.prototype.adjustHeight = function (val) {
	  this.node.style.height = val + 'px'
	  this.node.style.top = -val + 'px'
	}
	
	Refresh.prototype.handleRefresh = function (e) {
	  var scrollObj = e.scrollObj
	  var parent = this.getParent()
	  var scrollElement = parent.scrollElement || parent.listElement
	  this.node.style.height = CLAMP + 'px'
	  this.node.style.top = -CLAMP + 'px'
	  var translateStr = 'translate3d(0px,' + CLAMP + 'px,0px)'
	  scrollElement.style[cssPrefix + 'transform']
	    = cssPrefix + translateStr
	  scrollElement.style.transform = translateStr
	  this.dispatchEvent('refresh')
	}
	
	Refresh.prototype.show = function () {
	  this.display = true
	  this.node.style.display = '-webkit-box'
	  this.node.style.display = '-webkit-flex'
	  this.node.style.display = 'flex'
	}
	
	Refresh.prototype.hide = function () {
	  this.display = false
	  var parent = this.getParent()
	  if (parent) {
	    var scrollElement = parent.scrollElement || parent.listElement
	    var translateStr = 'translate3d(0px,0px,0px)'
	    scrollElement.style[cssPrefix + 'transform']
	      = cssPrefix + translateStr
	    scrollElement.style.transform = translateStr
	  }
	  this.node.style.display = 'none'
	}
	
	Refresh.prototype.attr = {
	  display: function (val) {
	    if (val === 'show') {
	      setTimeout(function () {
	        this.show()
	      }.bind(this), 0)
	    } else if (val === 'hide') {
	      setTimeout(function () {
	        this.hide()
	      }.bind(this), 0)
	    } else {
	      // TODO
	      console.error('h5render:attribute value of refresh \'display\' '
	          + val
	          + ' is invalid. Should be \'show\' or \'hide\'')
	    }
	  }
	}
	
	module.exports = Refresh


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(84);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./refresh.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./refresh.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-refresh {\n  // -webkit-box-align: center;\n  // -webkit-align-items: center;\n  // align-items: center;\n  // -webkit-box-pack: center;\n  // -webkit-justify-content: center;\n  // justify-content: center;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 0;\n}", ""]);
	
	// exports


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Component = __webpack_require__(27)
	
	__webpack_require__(86)
	
	var parents = ['scroller', 'list']
	
	var DEFAULT_HEIGHT = 130
	
	var ua = window.navigator.userAgent
	var Firefox = !!ua.match(/Firefox/i)
	var IEMobile = !!ua.match(/IEMobile/i)
	var cssPrefix = Firefox ? '-moz-' : IEMobile ? '-ms-' : '-webkit-'
	
	function Loading (data) {
	  Component.call(this, data)
	}
	
	Loading.prototype = Object.create(Component.prototype)
	
	Loading.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container', 'weex-loading')
	  return node
	}
	
	Loading.prototype.onAppend = function () {
	  var parent = this.getParent()
	  var self = this
	  var scrollWrapHeight = parent.node.getBoundingClientRect().height
	  if (parents.indexOf(parent.data.type) === -1) {
	    return
	  }
	  parent.scroller.addEventListener('pullup', function (e) {
	    var obj = e.scrollObj
	    self.adjustHeight(Math.abs(
	      obj.getScrollHeight() - obj.getScrollTop() - scrollWrapHeight))
	    if (!self.display) {
	      self.show()
	    }
	  })
	  parent.scroller.addEventListener('pullupend', function (e) {
	    self.handleLoading(e)
	  })
	}
	
	Loading.prototype.adjustHeight = function (val) {
	  this.node.style.height = val + 'px'
	  this.node.style.bottom = -val + 'px'
	}
	
	Loading.prototype.handleLoading = function (e) {
	  var parent = this.getParent()
	  var scrollElement = parent.scrollElement || parent.listElement
	  var offset = scrollElement.getBoundingClientRect().height
	            - parent.node.getBoundingClientRect().height
	            + DEFAULT_HEIGHT
	  this.node.style.height = DEFAULT_HEIGHT + 'px'
	  this.node.style.bottom = -DEFAULT_HEIGHT + 'px'
	  var translateStr = 'translate3d(0px,-' + offset + 'px,0px)'
	  scrollElement.style[cssPrefix + 'transform']
	    = cssPrefix + translateStr
	  scrollElement.style.transform = translateStr
	  this.dispatchEvent('loading')
	}
	
	Loading.prototype.show = function () {
	  this.display = true
	  this.node.style.display = '-webkit-box'
	  this.node.style.display = '-webkit-flex'
	  this.node.style.display = 'flex'
	}
	
	Loading.prototype.hide = function () {
	  this.display = false
	  var parent = this.getParent()
	  if (parent) {
	    var scrollElement = parent.scrollElement || parent.listElement
	    var scrollElementHeight = scrollElement.getBoundingClientRect().height
	    var scrollWrapHeight = parent.node.getBoundingClientRect().height
	    var left = scrollElementHeight
	      - parent.scroller.getScrollTop()
	      - scrollWrapHeight
	    if (left < 0) {
	      var offset = scrollElementHeight
	              - parent.node.getBoundingClientRect().height
	      var translateStr = 'translate3d(0px,-' + offset + 'px,0px)'
	      scrollElement.style[cssPrefix + 'transform']
	        = cssPrefix + translateStr
	      scrollElement.style.transform = translateStr
	    }
	  }
	  this.node.style.display = 'none'
	}
	
	Loading.prototype.attr = {
	  display: function (val) {
	    if (val === 'show') {
	      setTimeout(function () {
	        this.show()
	      }.bind(this), 0)
	    } else if (val === 'hide') {
	      setTimeout(function () {
	        this.hide()
	      }.bind(this), 0)
	    } else {
	      // TODO
	      console.error('h5render:attribute value of refresh \'display\' '
	          + val
	          + ' is invalid. Should be \'show\' or \'hide\'')
	    }
	  }
	}
	
	module.exports = Loading


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(87);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./loading.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./loading.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-loading {\n  // -webkit-box-align: center;\n  // -webkit-align-items: center;\n  // align-items: center;\n  // -webkit-box-pack: center;\n  // -webkit-justify-content: center;\n  // justify-content: center;\n  overflow: hidden;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 0;\n}", ""]);
	
	// exports


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	var utils = __webpack_require__(17)
	
	__webpack_require__(89)
	
	function Spinner (data) {
	  Atomic.call(this, data)
	}
	
	Spinner.prototype = Object.create(Atomic.prototype)
	
	Spinner.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-container', 'weex-spinner-wrap')
	  this.spinner = document.createElement('div')
	  this.spinner.classList.add('weex-element', 'weex-spinner')
	  node.appendChild(this.spinner)
	  return node
	}
	
	Spinner.prototype.updateStyle = function (style) {
	  Atomic.prototype.updateStyle.call(this, style)
	  if (style && style.color) {
	    this.setKeyframeColor(utils.getRgb(this.node.style.color))
	  }
	}
	
	Spinner.prototype.getStyleSheet = function () {
	  if (this.styleSheet) {
	    return
	  }
	  var styles = document.styleSheets
	  outer: for (var i = 0, l = styles.length; i < l; i++) {
	    var rules = styles[i].rules
	    for (var j = 0, m = rules.length; j < m; j++) {
	      var item = rules.item(j)
	      if (
	        (item.type === CSSRule.KEYFRAMES_RULE
	          || item.type === CSSRule.WEBKIT_KEYFRAMES_RULE)
	        && item.name === 'spinner') {
	        break outer
	      }
	    }
	  }
	  this.styleSheet = styles[i]
	}
	
	Spinner.prototype.setKeyframeColor = function (val) {
	  this.getStyleSheet()
	  var keyframeRules = this.computeKeyFrameRules(val)
	  var rules, item, cssRules, keyframe
	  rules = this.styleSheet.rules
	  for (var i = 0, l = rules.length; i < l; i++) {
	    item = rules.item(i)
	    if ((item.type === CSSRule.KEYFRAMES_RULE
	          || item.type === CSSRule.WEBKIT_KEYFRAMES_RULE)
	        && item.name === 'spinner') {
	      cssRules = item.cssRules
	      for (var j = 0, m = cssRules.length; j < m; j++) {
	        keyframe = cssRules[j]
	        if (keyframe.type === CSSRule.KEYFRAME_RULE
	          || keyframe.type === CSSRule.WEBKIT_KEYFRAME_RULE) {
	          keyframe.style.boxShadow = keyframeRules[j]
	        }
	      }
	    }
	  }
	}
	
	Spinner.prototype.computeKeyFrameRules = function (rgb) {
	  if (!rgb) {
	    return
	  }
	  var scaleArr = [
	    '0em -2.6em 0em 0em',
	    '1.8em -1.8em 0 0em',
	    '2.5em 0em 0 0em',
	    '1.75em 1.75em 0 0em',
	    '0em 2.5em 0 0em',
	    '-1.8em 1.8em 0 0em',
	    '-2.6em 0em 0 0em',
	    '-1.8em -1.8em 0 0em']
	  var colorArr = [
	    '1',
	    '0.2',
	    '0.2',
	    '0.2',
	    '0.2',
	    '0.2',
	    '0.5',
	    '0.7'].map(function (e) {
	      return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + e + ')'
	    })
	  var rules = []
	  for (var i = 0; i < scaleArr.length; i++) {
	    var tmpColorArr = utils.loopArray(colorArr, i, 'r')
	    rules.push(scaleArr.map(function (scaleStr, i) {
	      return scaleStr + ' ' + tmpColorArr[i]
	    }).join(', '))
	  }
	  return rules
	}
	
	module.exports = Spinner


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(90);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../css-loader/index.js!./spinner.css", function() {
				var newContent = require("!!./../../../css-loader/index.js!./spinner.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-spinner-wrap {\n  width: 1.013333rem; /* 76px */\n  height: 1.013333rem;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  overflow: visible;\n}\n\n.weex-spinner {\n  font-size: 0.16rem; /* 12px */\n  width: 1em;\n  height: 1em;\n  border-radius: 50%;\n  position: relative;\n  text-indent: -9999em;\n  -webkit-animation: spinner 1.1s infinite ease;\n  animation: spinner 1.1s infinite ease;\n  -webkit-transform: translateZ(0);\n  -ms-transform: translateZ(0);\n  transform: translateZ(0);\n}\n@-webkit-keyframes spinner {\n  0%,\n  100% {\n    box-shadow: 0em -2.6em 0em 0em #ffffff, 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.5), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7);\n  }\n  12.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.7), 1.8em -1.8em 0 0em #ffffff, 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5);\n  }\n  25% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.5), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7), 2.5em 0em 0 0em #ffffff, 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  37.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5), 2.5em 0em 0 0em rgba(255, 255, 255, 0.7), 1.75em 1.75em 0 0em #ffffff, 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  50% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.5), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.7), 0em 2.5em 0 0em #ffffff, -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  62.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.5), 0em 2.5em 0 0em rgba(255, 255, 255, 0.7), -1.8em 1.8em 0 0em #ffffff, -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  75% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.5), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.7), -2.6em 0em 0 0em #ffffff, -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  87.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.5), -2.6em 0em 0 0em rgba(255, 255, 255, 0.7), -1.8em -1.8em 0 0em #ffffff;\n  }\n}\n@keyframes spinner {\n  0%,\n  100% {\n    box-shadow: 0em -2.6em 0em 0em #ffffff, 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.5), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7);\n  }\n  12.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.7), 1.8em -1.8em 0 0em #ffffff, 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5);\n  }\n  25% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.5), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.7), 2.5em 0em 0 0em #ffffff, 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  37.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.5), 2.5em 0em 0 0em rgba(255, 255, 255, 0.7), 1.75em 1.75em 0 0em #ffffff, 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  50% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.5), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.7), 0em 2.5em 0 0em #ffffff, -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.2), -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  62.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.5), 0em 2.5em 0 0em rgba(255, 255, 255, 0.7), -1.8em 1.8em 0 0em #ffffff, -2.6em 0em 0 0em rgba(255, 255, 255, 0.2), -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  75% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.5), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.7), -2.6em 0em 0 0em #ffffff, -1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2);\n  }\n  87.5% {\n    box-shadow: 0em -2.6em 0em 0em rgba(255, 255, 255, 0.2), 1.8em -1.8em 0 0em rgba(255, 255, 255, 0.2), 2.5em 0em 0 0em rgba(255, 255, 255, 0.2), 1.75em 1.75em 0 0em rgba(255, 255, 255, 0.2), 0em 2.5em 0 0em rgba(255, 255, 255, 0.2), -1.8em 1.8em 0 0em rgba(255, 255, 255, 0.5), -2.6em 0em 0 0em rgba(255, 255, 255, 0.7), -1.8em -1.8em 0 0em #ffffff;\n  }\n}\n", ""]);
	
	// exports


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Atomic = __webpack_require__(39)
	var utils = __webpack_require__(17)
	var logger = __webpack_require__(15)
	
	// A component to import web pages, which works like
	// a iframe element or a webview.
	// attrs:
	//   - src
	// events:
	//   - pagestart
	//   - pagefinish
	//   - error
	function Web (data) {
	  Atomic.call(this, data)
	}
	
	Web.prototype = Object.create(Atomic.prototype)
	
	Web.prototype.create = function () {
	  // Iframe's defect: can't use position:absolute and top, left, right,
	  // bottom all setting to zero and use margin to leave specified
	  // height for a blank area, and have to use 100% to fill the parent
	  // container, otherwise it will use a unwanted default size instead.
	  // Therefore a div as a iframe wrapper is needed here.
	  var node = document.createElement('div')
	  node.classList.add('weex-container')
	  this.web = document.createElement('iframe')
	  node.appendChild(this.web)
	  this.web.classList.add('weex-element')
	  this.web.style.width = '100%'
	  this.web.style.height = '100%'
	  this.web.style.border = 'none'
	  return node
	}
	
	Web.prototype.bindEvents = function (evts) {
	  Atomic.prototype.bindEvents.call(this, evts)
	  var that = this
	  this.web.addEventListener('load', function (e) {
	    that.dispatchEvent('pagefinish', utils.extend({
	      url: that.web.src
	    }))
	  })
	  window.addEventListener('message', this.msgHandler.bind(this))
	}
	
	Web.prototype.msgHandler = function (evt) {
	  var msg = evt.data
	  if (typeof msg === 'string') {
	    try {
	      msg = JSON.parse(msg)
	    } catch (e) {}
	  }
	  if (!msg) {
	    return
	  }
	  if (msg.type === 'weex') {
	    if (!utils.isArray(msg.content)) {
	      return logger.error('weex msg received by web component. msg.content'
	        + ' should be a array:', msg.content)
	    }
	    callNative(this.getComponentManager().instanceId, msg.content)
	  }
	}
	
	Web.prototype.attr = {
	  src: function (val) {
	    this.web.src = val
	    setTimeout(function () {
	      this.dispatchEvent('pagestart', { url: val })
	    }.bind(this), 0)
	  }
	}
	
	Web.prototype.goBack = function () {
	  this.web.contentWindow.history.back()
	}
	
	Web.prototype.goForward = function () {
	  this.web.contentWindow.history.forward()
	}
	
	Web.prototype.reload = function () {
	  this.web.contentWindow.location.reload()
	}
	
	module.exports = Web


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	var dom = __webpack_require__(93)
	var event = __webpack_require__(101)
	var pageInfo = __webpack_require__(102)
	var stream = __webpack_require__(103)
	var modal = __webpack_require__(105)
	var animation = __webpack_require__(122)
	var webview = __webpack_require__(123)
	var timer = __webpack_require__(124)
	var navigator = __webpack_require__(125)
	
	var api = {
	  init: function (Weex) {
	    Weex.registerApiModule('dom', dom, dom._meta)
	    Weex.registerApiModule('event', event, event._meta)
	    Weex.registerApiModule('pageInfo', pageInfo, pageInfo._meta)
	    Weex.registerApiModule('stream', stream, stream._meta)
	    Weex.registerApiModule('modal', modal, modal._meta)
	    Weex.registerApiModule('animation', animation, animation._meta)
	    Weex.registerApiModule('webview', webview, webview._meta)
	    Weex.registerApiModule('timer', timer, timer._meta)
	    Weex.registerApiModule('navigator', navigator, navigator._meta)
	  }
	}
	
	module.exports = api

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var messageQueue = __webpack_require__(64)
	var FrameUpdater = __webpack_require__(21)
	var Component = __webpack_require__(27)
	var scroll = __webpack_require__(94)
	var config = __webpack_require__(16)
	var logger = __webpack_require__(15)
	
	var dom = {
	
	  /**
	   * createBody: create root component
	   * @param  {object} element
	   *    container|listview|scrollview
	   * @return {[type]}      [description]
	   */
	  createBody: function (element) {
	    var componentManager = this.getComponentManager()
	    element.scale = this.scale
	    element.instanceId = componentManager.instanceId
	    return componentManager.createBody(element)
	  },
	
	  addElement: function (parentRef, element, index) {
	    var componentManager = this.getComponentManager()
	    element.scale = this.scale
	    element.instanceId = componentManager.instanceId
	    return componentManager.addElement(parentRef, element, index)
	  },
	
	  removeElement: function (ref) {
	    var componentManager = this.getComponentManager()
	    return componentManager.removeElement(ref)
	  },
	
	  moveElement: function (ref, parentRef, index) {
	    var componentManager = this.getComponentManager()
	    return componentManager.moveElement(ref, parentRef, index)
	  },
	
	  addEvent: function (ref, type) {
	    var componentManager = this.getComponentManager()
	    return componentManager.addEvent(ref, type)
	  },
	
	  removeEvent: function (ref, type) {
	    var componentManager = this.getComponentManager()
	    return componentManager.removeEvent(ref, type)
	  },
	
	  /**
	   * updateAttrs: update attributes of component
	   * @param  {string} ref
	   * @param  {obj} attr
	   */
	  updateAttrs: function (ref, attr) {
	    var componentManager = this.getComponentManager()
	    return componentManager.updateAttrs(ref, attr)
	  },
	
	  /**
	   * updateStyle: udpate style of component
	   * @param {string} ref
	   * @param {obj} style
	   */
	  updateStyle: function (ref, style) {
	    var componentManager = this.getComponentManager()
	    return componentManager.updateStyle(ref, style)
	  },
	
	  createFinish: function () {
	    // TODO
	    // FrameUpdater.pause()
	  },
	
	  refreshFinish: function () {
	    // TODO
	  },
	
	  /**
	   * scrollToElement
	   * @param  {string} ref
	   * @param  {obj} options {offset:Number}
	   *   ps: scroll-to has 'ease' and 'duration'(ms) as options.
	   */
	  scrollToElement: function (ref, options) {
	    !options && (options = {})
	    var componentManager = this.getComponentManager()
	    var elem = componentManager.getElementByRef(ref)
	    if (!elem) {
	      return logger.error('component of ref ' + ref + ' doesn\'t exist.')
	    }
	    var parentScroller = elem.getParentScroller()
	    if (parentScroller) {
	      parentScroller.scroller.scrollToElement(elem.node, true)
	    } else {
	      var offsetTop = elem.node.getBoundingClientRect().top
	          + document.body.scrollTop
	      var offset = (Number(options.offset) || 0) * this.scale
	      var tween = scroll(0, offsetTop + offset, options)
	      tween.on('end', function () {
	        logger.log('scroll end.')
	      })
	    }
	  }
	
	}
	
	dom._meta = {
	  dom: [{
	    name: 'createBody',
	    args: ['object']
	  }, {
	    name: 'addElement',
	    args: ['string', 'object', 'number']
	  }, {
	    name: 'removeElement',
	    args: ['string']
	  }, {
	    name: 'moveElement',
	    args: ['string', 'string', 'number']
	  }, {
	    name: 'addEvent',
	    args: ['string', 'string']
	  }, {
	    name: 'removeEvent',
	    args: ['string', 'string']
	  }, {
	    name: 'updateAttrs',
	    args: ['string', 'object']
	  }, {
	    name: 'updateStyle',
	    args: ['string', 'object']
	  }, {
	    name: 'createFinish',
	    args: []
	  }, {
	    name: 'refreshFinish',
	    args: []
	  }, {
	    name: 'scrollToElement',
	    args: ['string', 'object']
	  }]
	}
	
	module.exports = dom


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Tween = __webpack_require__(95);
	var raf = __webpack_require__(100);
	
	/**
	 * Expose `scrollTo`.
	 */
	
	module.exports = scrollTo;
	
	/**
	 * Scroll to `(x, y)`.
	 *
	 * @param {Number} x
	 * @param {Number} y
	 * @api public
	 */
	
	function scrollTo(x, y, options) {
	  options = options || {};
	
	  // start position
	  var start = scroll();
	
	  // setup tween
	  var tween = Tween(start)
	    .ease(options.ease || 'out-circ')
	    .to({ top: y, left: x })
	    .duration(options.duration || 1000);
	
	  // scroll
	  tween.update(function(o){
	    window.scrollTo(o.left | 0, o.top | 0);
	  });
	
	  // handle end
	  tween.on('end', function(){
	    animate = function(){};
	  });
	
	  // animate
	  function animate() {
	    raf(animate);
	    tween.update();
	  }
	
	  animate();
	  
	  return tween;
	}
	
	/**
	 * Return scroll position.
	 *
	 * @return {Object}
	 * @api private
	 */
	
	function scroll() {
	  var y = window.pageYOffset || document.documentElement.scrollTop;
	  var x = window.pageXOffset || document.documentElement.scrollLeft;
	  return { top: y, left: x };
	}


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */
	
	var Emitter = __webpack_require__(96);
	var clone = __webpack_require__(97);
	var type = __webpack_require__(98);
	var ease = __webpack_require__(99);
	
	/**
	 * Expose `Tween`.
	 */
	
	module.exports = Tween;
	
	/**
	 * Initialize a new `Tween` with `obj`.
	 *
	 * @param {Object|Array} obj
	 * @api public
	 */
	
	function Tween(obj) {
	  if (!(this instanceof Tween)) return new Tween(obj);
	  this._from = obj;
	  this.ease('linear');
	  this.duration(500);
	}
	
	/**
	 * Mixin emitter.
	 */
	
	Emitter(Tween.prototype);
	
	/**
	 * Reset the tween.
	 *
	 * @api public
	 */
	
	Tween.prototype.reset = function(){
	  this.isArray = 'array' === type(this._from);
	  this._curr = clone(this._from);
	  this._done = false;
	  this._start = Date.now();
	  return this;
	};
	
	/**
	 * Tween to `obj` and reset internal state.
	 *
	 *    tween.to({ x: 50, y: 100 })
	 *
	 * @param {Object|Array} obj
	 * @return {Tween} self
	 * @api public
	 */
	
	Tween.prototype.to = function(obj){
	  this.reset();
	  this._to = obj;
	  return this;
	};
	
	/**
	 * Set duration to `ms` [500].
	 *
	 * @param {Number} ms
	 * @return {Tween} self
	 * @api public
	 */
	
	Tween.prototype.duration = function(ms){
	  this._duration = ms;
	  return this;
	};
	
	/**
	 * Set easing function to `fn`.
	 *
	 *    tween.ease('in-out-sine')
	 *
	 * @param {String|Function} fn
	 * @return {Tween}
	 * @api public
	 */
	
	Tween.prototype.ease = function(fn){
	  fn = 'function' == typeof fn ? fn : ease[fn];
	  if (!fn) throw new TypeError('invalid easing function');
	  this._ease = fn;
	  return this;
	};
	
	/**
	 * Stop the tween and immediately emit "stop" and "end".
	 *
	 * @return {Tween}
	 * @api public
	 */
	
	Tween.prototype.stop = function(){
	  this.stopped = true;
	  this._done = true;
	  this.emit('stop');
	  this.emit('end');
	  return this;
	};
	
	/**
	 * Perform a step.
	 *
	 * @return {Tween} self
	 * @api private
	 */
	
	Tween.prototype.step = function(){
	  if (this._done) return;
	
	  // duration
	  var duration = this._duration;
	  var now = Date.now();
	  var delta = now - this._start;
	  var done = delta >= duration;
	
	  // complete
	  if (done) {
	    this._from = this._to;
	    this._update(this._to);
	    this._done = true;
	    this.emit('end');
	    return this;
	  }
	
	  // tween
	  var from = this._from;
	  var to = this._to;
	  var curr = this._curr;
	  var fn = this._ease;
	  var p = (now - this._start) / duration;
	  var n = fn(p);
	
	  // array
	  if (this.isArray) {
	    for (var i = 0; i < from.length; ++i) {
	      curr[i] = from[i] + (to[i] - from[i]) * n;
	    }
	
	    this._update(curr);
	    return this;
	  }
	
	  // objech
	  for (var k in from) {
	    curr[k] = from[k] + (to[k] - from[k]) * n;
	  }
	
	  this._update(curr);
	  return this;
	};
	
	/**
	 * Set update function to `fn` or
	 * when no argument is given this performs
	 * a "step".
	 *
	 * @param {Function} fn
	 * @return {Tween} self
	 * @api public
	 */
	
	Tween.prototype.update = function(fn){
	  if (0 == arguments.length) return this.step();
	  this._update = fn;
	  return this;
	};

/***/ },
/* 96 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks['$' + event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var type;
	try {
	  type = __webpack_require__(98);
	} catch (_) {
	  type = __webpack_require__(98);
	}
	
	/**
	 * Module exports.
	 */
	
	module.exports = clone;
	
	/**
	 * Clones objects.
	 *
	 * @param {Mixed} any object
	 * @api public
	 */
	
	function clone(obj){
	  switch (type(obj)) {
	    case 'object':
	      var copy = {};
	      for (var key in obj) {
	        if (obj.hasOwnProperty(key)) {
	          copy[key] = clone(obj[key]);
	        }
	      }
	      return copy;
	
	    case 'array':
	      var copy = new Array(obj.length);
	      for (var i = 0, l = obj.length; i < l; i++) {
	        copy[i] = clone(obj[i]);
	      }
	      return copy;
	
	    case 'regexp':
	      // from millermedeiros/amd-utils - MIT
	      var flags = '';
	      flags += obj.multiline ? 'm' : '';
	      flags += obj.global ? 'g' : '';
	      flags += obj.ignoreCase ? 'i' : '';
	      return new RegExp(obj.source, flags);
	
	    case 'date':
	      return new Date(obj.getTime());
	
	    default: // string, number, boolean, …
	      return obj;
	  }
	}


/***/ },
/* 98 */
/***/ function(module, exports) {

	/**
	 * toString ref.
	 */
	
	var toString = Object.prototype.toString;
	
	/**
	 * Return the type of `val`.
	 *
	 * @param {Mixed} val
	 * @return {String}
	 * @api public
	 */
	
	module.exports = function(val){
	  switch (toString.call(val)) {
	    case '[object Date]': return 'date';
	    case '[object RegExp]': return 'regexp';
	    case '[object Arguments]': return 'arguments';
	    case '[object Array]': return 'array';
	    case '[object Error]': return 'error';
	  }
	
	  if (val === null) return 'null';
	  if (val === undefined) return 'undefined';
	  if (val !== val) return 'nan';
	  if (val && val.nodeType === 1) return 'element';
	
	  val = val.valueOf
	    ? val.valueOf()
	    : Object.prototype.valueOf.apply(val)
	
	  return typeof val;
	};


/***/ },
/* 99 */
/***/ function(module, exports) {

	
	// easing functions from "Tween.js"
	
	exports.linear = function(n){
	  return n;
	};
	
	exports.inQuad = function(n){
	  return n * n;
	};
	
	exports.outQuad = function(n){
	  return n * (2 - n);
	};
	
	exports.inOutQuad = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n;
	  return - 0.5 * (--n * (n - 2) - 1);
	};
	
	exports.inCube = function(n){
	  return n * n * n;
	};
	
	exports.outCube = function(n){
	  return --n * n * n + 1;
	};
	
	exports.inOutCube = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n;
	  return 0.5 * ((n -= 2 ) * n * n + 2);
	};
	
	exports.inQuart = function(n){
	  return n * n * n * n;
	};
	
	exports.outQuart = function(n){
	  return 1 - (--n * n * n * n);
	};
	
	exports.inOutQuart = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n * n;
	  return -0.5 * ((n -= 2) * n * n * n - 2);
	};
	
	exports.inQuint = function(n){
	  return n * n * n * n * n;
	}
	
	exports.outQuint = function(n){
	  return --n * n * n * n * n + 1;
	}
	
	exports.inOutQuint = function(n){
	  n *= 2;
	  if (n < 1) return 0.5 * n * n * n * n * n;
	  return 0.5 * ((n -= 2) * n * n * n * n + 2);
	};
	
	exports.inSine = function(n){
	  return 1 - Math.cos(n * Math.PI / 2 );
	};
	
	exports.outSine = function(n){
	  return Math.sin(n * Math.PI / 2);
	};
	
	exports.inOutSine = function(n){
	  return .5 * (1 - Math.cos(Math.PI * n));
	};
	
	exports.inExpo = function(n){
	  return 0 == n ? 0 : Math.pow(1024, n - 1);
	};
	
	exports.outExpo = function(n){
	  return 1 == n ? n : 1 - Math.pow(2, -10 * n);
	};
	
	exports.inOutExpo = function(n){
	  if (0 == n) return 0;
	  if (1 == n) return 1;
	  if ((n *= 2) < 1) return .5 * Math.pow(1024, n - 1);
	  return .5 * (-Math.pow(2, -10 * (n - 1)) + 2);
	};
	
	exports.inCirc = function(n){
	  return 1 - Math.sqrt(1 - n * n);
	};
	
	exports.outCirc = function(n){
	  return Math.sqrt(1 - (--n * n));
	};
	
	exports.inOutCirc = function(n){
	  n *= 2
	  if (n < 1) return -0.5 * (Math.sqrt(1 - n * n) - 1);
	  return 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
	};
	
	exports.inBack = function(n){
	  var s = 1.70158;
	  return n * n * (( s + 1 ) * n - s);
	};
	
	exports.outBack = function(n){
	  var s = 1.70158;
	  return --n * n * ((s + 1) * n + s) + 1;
	};
	
	exports.inOutBack = function(n){
	  var s = 1.70158 * 1.525;
	  if ( ( n *= 2 ) < 1 ) return 0.5 * ( n * n * ( ( s + 1 ) * n - s ) );
	  return 0.5 * ( ( n -= 2 ) * n * ( ( s + 1 ) * n + s ) + 2 );
	};
	
	exports.inBounce = function(n){
	  return 1 - exports.outBounce(1 - n);
	};
	
	exports.outBounce = function(n){
	  if ( n < ( 1 / 2.75 ) ) {
	    return 7.5625 * n * n;
	  } else if ( n < ( 2 / 2.75 ) ) {
	    return 7.5625 * ( n -= ( 1.5 / 2.75 ) ) * n + 0.75;
	  } else if ( n < ( 2.5 / 2.75 ) ) {
	    return 7.5625 * ( n -= ( 2.25 / 2.75 ) ) * n + 0.9375;
	  } else {
	    return 7.5625 * ( n -= ( 2.625 / 2.75 ) ) * n + 0.984375;
	  }
	};
	
	exports.inOutBounce = function(n){
	  if (n < .5) return exports.inBounce(n * 2) * .5;
	  return exports.outBounce(n * 2 - 1) * .5 + .5;
	};
	
	// aliases
	
	exports['in-quad'] = exports.inQuad;
	exports['out-quad'] = exports.outQuad;
	exports['in-out-quad'] = exports.inOutQuad;
	exports['in-cube'] = exports.inCube;
	exports['out-cube'] = exports.outCube;
	exports['in-out-cube'] = exports.inOutCube;
	exports['in-quart'] = exports.inQuart;
	exports['out-quart'] = exports.outQuart;
	exports['in-out-quart'] = exports.inOutQuart;
	exports['in-quint'] = exports.inQuint;
	exports['out-quint'] = exports.outQuint;
	exports['in-out-quint'] = exports.inOutQuint;
	exports['in-sine'] = exports.inSine;
	exports['out-sine'] = exports.outSine;
	exports['in-out-sine'] = exports.inOutSine;
	exports['in-expo'] = exports.inExpo;
	exports['out-expo'] = exports.outExpo;
	exports['in-out-expo'] = exports.inOutExpo;
	exports['in-circ'] = exports.inCirc;
	exports['out-circ'] = exports.outCirc;
	exports['in-out-circ'] = exports.inOutCirc;
	exports['in-back'] = exports.inBack;
	exports['out-back'] = exports.outBack;
	exports['in-out-back'] = exports.inOutBack;
	exports['in-bounce'] = exports.inBounce;
	exports['out-bounce'] = exports.outBounce;
	exports['in-out-bounce'] = exports.inOutBounce;


/***/ },
/* 100 */
/***/ function(module, exports) {

	/**
	 * Expose `requestAnimationFrame()`.
	 */
	
	exports = module.exports = window.requestAnimationFrame
	  || window.webkitRequestAnimationFrame
	  || window.mozRequestAnimationFrame
	  || fallback;
	
	/**
	 * Fallback implementation.
	 */
	
	var prev = new Date().getTime();
	function fallback(fn) {
	  var curr = new Date().getTime();
	  var ms = Math.max(0, 16 - (curr - prev));
	  var req = setTimeout(fn, ms);
	  prev = curr;
	  return req;
	}
	
	/**
	 * Cancel.
	 */
	
	var cancel = window.cancelAnimationFrame
	  || window.webkitCancelAnimationFrame
	  || window.mozCancelAnimationFrame
	  || window.clearTimeout;
	
	exports.cancel = function(id){
	  cancel.call(window, id);
	};


/***/ },
/* 101 */
/***/ function(module, exports) {

	'use strict'
	
	var event = {
	  /**
	   * openUrl
	   * @param  {string} url
	   */
	  openURL: function (url) {
	    location.href = url
	  }
	
	}
	
	event._meta = {
	  event: [{
	    name: 'openURL',
	    args: ['string']
	  }]
	}
	
	module.exports = event

/***/ },
/* 102 */
/***/ function(module, exports) {

	'use strict'
	
	var pageInfo = {
	
	  setTitle: function (title) {
	    title = title || 'Weex HTML5'
	    try {
	      title = decodeURIComponent(title)
	    } catch (e) {}
	    document.title = title
	  }
	}
	
	pageInfo._meta = {
	  pageInfo: [{
	    name: 'setTitle',
	    args: ['string']
	  }]
	}
	
	module.exports = pageInfo

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	
	var utils = __webpack_require__(17)
	var logger = __webpack_require__(15)
	
	__webpack_require__(104)
	
	var jsonpCnt = 0
	var ERROR_STATE = -1
	
	function _jsonp(config, callback, progressCallback) {
	  var cbName = 'jsonp_' + (++jsonpCnt)
	  var script, url, head
	
	  if (!config.url) {
	    logger.error('config.url should be set in _jsonp for \'fetch\' API.')
	  }
	
	  global[cbName] = (function (cb) {
	    return function (response) {
	      callback(response)
	      delete global[cb]
	    }
	  })(cbName)
	
	  script = document.createElement('script')
	  try {
	    url = lib.httpurl(config.url)
	  } catch (err) {
	    logger.error('invalid config.url in _jsonp for \'fetch\' API: '
	      + config.url)
	  }
	  url.params.callback = cbName
	  script.type = 'text/javascript'
	  script.src = url.toString()
	  // script.onerror is not working on IE or safari.
	  // but they are not considered here.
	  script.onerror = (function (cb) {
	    return function (err) {
	      logger.error('unexpected error in _jsonp for \'fetch\' API', err)
	      callback(err)
	      delete global[cb]
	    }
	  })(cbName)
	  head = document.getElementsByTagName('head')[0]
	  head.insertBefore(script, null)
	}
	
	function _xhr(config, callback, progressCallback) {
	  var xhr = new XMLHttpRequest()
	  xhr.responseType = config.type
	  xhr.open(config.method, config.url, true)
	
	  xhr.onload = function (res) {
	    callback({
	      status: xhr.status,
	      ok: xhr.status >= 200 && xhr.status < 300,
	      statusText: xhr.statusText,
	      data: xhr.response,
	      headers: xhr.getAllResponseHeaders().split('\n')
	        .reduce(function (obj, headerStr) {
	          var headerArr = headerStr.match(/(.+): (.+)/)
	          if (headerArr) {
	            obj[headerArr[1]] = headerArr[2]
	          }
	          return obj
	        }, {})
	    })
	  }
	
	  if (progressCallback) {
	    xhr.onprogress = function (e) {
	      progressCallback({
	        readyState: xhr.readyState,
	        status: xhr.status,
	        length: e.loaded,
	        total: e.total,
	        statusText: xhr.statusText,
	        headers: xhr.getAllResponseHeaders().split('\n')
	          .reduce(function (obj, headerStr) {
	            var headerArr = headerStr.match(/(.+): (.+)/)
	            if (headerArr) {
	              obj[headerArr[1]] = headerArr[2]
	            }
	            return obj
	          }, {})
	      })
	    }
	  }
	
	  xhr.onerror = function (err) {
	    logger.error('unexpected error in _xhr for \'fetch\' API', err)
	    callback({
	      status: ERROR_STATE,
	      ok: false,
	      statusText: '',
	      data: '',
	      headers: {}
	    })
	  }
	
	  xhr.send(config.body)
	}
	
	var stream = {
	
	  /**
	   * sendHttp
	   * Note: This API is deprecated. Please use stream.fetch instead.
	   * send a http request through XHR.
	   * @deprecated
	   * @param  {obj} params
	   *  - method: 'GET' | 'POST',
	   *  - url: url requested
	   * @param  {string} callbackId
	   */
	  sendHttp: function (param, callbackId) {
	    if (typeof param === 'string') {
	      try {
	        param = JSON.parse(param)
	      } catch (e) {
	        return
	      }
	    }
	    if (typeof param !== 'object' || !param.url) {
	      return logger.error(
	        'invalid config or invalid config.url for sendHttp API')
	    }
	
	    var sender = this.sender
	    var method = param.method || 'GET'
	    var xhr = new XMLHttpRequest()
	    xhr.open(method, param.url, true)
	    xhr.onload = function () {
	      sender.performCallback(callbackId, this.responseText)
	    }
	    xhr.onerror = function (error) {
	      return logger.error('unexpected error in sendHttp API', error)
	      sender.performCallback(
	        callbackId,
	        new Error('unexpected error in sendHttp API')
	      )
	    }
	    xhr.send()
	  },
	
	  /**
	   * fetch
	   * use stream.fetch to request for a json file, a plain text file or
	   * a arraybuffer for a file stream. (You can use Blob and FileReader
	   * API implemented by most modern browsers to read a arraybuffer.)
	   * @param  {object} options config options
	   *   - method {string} 'GET' | 'POST'
	   *   - headers {obj}
	   *   - url {string}
	   *   - mode {string} 'cors' | 'no-cors' | 'same-origin' | 'navigate'
	   *   - body
	   *   - type {string} 'json' | 'jsonp' | 'text'
	   * @param  {string} callbackId
	   * @param  {string} progressCallbackId
	   */
	  fetch: function (options, callbackId, progressCallbackId) {
	
	    var DEFAULT_METHOD = 'GET'
	    var DEFAULT_MODE = 'cors'
	    var DEFAULT_TYPE = 'text'
	
	    var methodOptions = ['GET', 'POST']
	    var modeOptions = ['cors', 'no-cors', 'same-origin', 'navigate']
	    var typeOptions = ['text', 'json', 'jsonp', 'arraybuffer']
	
	    var fallback = false  // fallback from 'fetch' API to XHR.
	    var sender = this.sender
	
	    var config = utils.extend({}, options)
	
	    // validate options.method
	    if (typeof config.method === 'undefined') {
	      config.method = DEFAULT_METHOD
	      logger.warn('options.method for \'fetch\' API has been set to '
	        + 'default value \'' + config.method + '\'')
	    } else if (methodOptions.indexOf((config.method + '')
	        .toUpperCase()) === -1) {
	      return logger.error('options.method \''
	        + config.method
	        + '\' for \'fetch\' API should be one of '
	        + methodOptions + '.')
	    }
	
	    // validate options.url
	    if (!config.url) {
	      return logger.error('options.url should be set for \'fetch\' API.')
	    }
	
	    // validate options.mode
	    if (typeof config.mode === 'undefined') {
	      config.mode = DEFAULT_MODE
	    } else if (modeOptions.indexOf((config.mode + '').toLowerCase()) === -1) {
	      return logger.error('options.mode \''
	        + config.mode
	        + '\' for \'fetch\' API should be one of '
	        + modeOptions + '.')
	    }
	
	    // validate options.type
	    if (typeof config.type === 'undefined') {
	      config.type = DEFAULT_TYPE
	      logger.warn('options.type for \'fetch\' API has been set to '
	        + 'default value \'' + config.type + '\'.')
	    } else if (typeOptions.indexOf((config.type + '').toLowerCase()) === -1) {
	      return logger.error('options.type \''
	          + config.type
	          + '\' for \'fetch\' API should be one of '
	          + typeOptions + '.')
	    }
	
	    var _callArgs = [config, function (res) {
	      sender.performCallback(callbackId, res)
	    }]
	    if (progressCallbackId) {
	      _callArgs.push(function (res) {
	        // Set 'keepAlive' to true for sending continuous callbacks
	        sender.performCallback(progressCallbackId, res, true)
	      })
	    }
	
	    if (config.type === 'jsonp') {
	      _jsonp.apply(this, _callArgs)
	    } else {
	      _xhr.apply(this, _callArgs)
	    }
	  }
	
	}
	
	stream._meta = {
	  stream: [{
	    name: 'sendHttp',
	    args: ['object', 'function']
	  }, {
	    name: 'fetch',
	    args: ['object', 'function', 'function']
	  }]
	}
	
	module.exports = stream
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 104 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){var b={};Object.defineProperty(this,"params",{set:function(a){if("object"==typeof a){for(var c in b)delete b[c];for(var c in a)b[c]=a[c]}},get:function(){return b},enumerable:!0}),Object.defineProperty(this,"search",{set:function(a){if("string"==typeof a){0===a.indexOf("?")&&(a=a.substr(1));var c=a.split("&");for(var d in b)delete b[d];for(var e=0;e<c.length;e++){var f=c[e].split("=");if(void 0!==f[1]&&(f[1]=f[1].toString()),f[0])try{b[decodeURIComponent(f[0])]=decodeURIComponent(f[1])}catch(g){b[f[0]]=f[1]}}}},get:function(){var a=[];for(var c in b)if(void 0!==b[c])if(""!==b[c])try{a.push(encodeURIComponent(c)+"="+encodeURIComponent(b[c]))}catch(d){a.push(c+"="+b[c])}else try{a.push(encodeURIComponent(c))}catch(d){a.push(c)}return a.length?"?"+a.join("&"):""},enumerable:!0});var c;Object.defineProperty(this,"hash",{set:function(a){"string"==typeof a&&(a&&a.indexOf("#")<0&&(a="#"+a),c=a||"")},get:function(){return c},enumerable:!0}),this.set=function(a){a=a||"";var b;if(!(b=a.match(new RegExp("^([a-z0-9-]+:)?[/]{2}(?:([^@/:?]+)(?::([^@/:]+))?@)?([^:/?#]+)(?:[:]([0-9]+))?([/][^?#;]*)?(?:[?]([^#]*))?([#][^?]*)?$","i"))))throw new Error("Wrong uri scheme.");this.protocol=b[1]||("object"==typeof location?location.protocol:""),this.username=b[2]||"",this.password=b[3]||"",this.hostname=this.host=b[4],this.port=b[5]||"",this.pathname=b[6]||"/",this.search=b[7]||"",this.hash=b[8]||"",this.origin=this.protocol+"//"+this.hostname},this.toString=function(){var a=this.protocol+"//";return this.username&&(a+=this.username,this.password&&(a+=":"+this.password),a+="@"),a+=this.host,this.port&&"80"!==this.port&&(a+=":"+this.port),this.pathname&&(a+=this.pathname),this.search&&(a+=this.search),this.hash&&(a+=this.hash),a},a&&this.set(a.toString())}b.httpurl=function(a){return new c(a)}}(window,window.lib||(window.lib={}));;module.exports = window.lib['httpurl'];

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var modal = __webpack_require__(106)
	
	var msg = {
	
	  // duration: default is 0.8 seconds.
	  toast: function (config) {
	    modal.toast(config.message, config.duration)
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - callback
	  alert: function (config, callbackId) {
	    var sender =  this.sender
	    config.callback = function () {
	      sender.performCallback(callbackId)
	    }
	    modal.alert(config)
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - cancelTitle: title of cancel button
	  //  - callback
	  confirm: function (config, callbackId) {
	    var sender =  this.sender
	    config.callback = function (val) {
	      sender.performCallback(callbackId, val)
	    }
	    modal.confirm(config)
	  },
	
	  // config:
	  //  - message: string
	  //  - okTitle: title of ok button
	  //  - cancelTitle: title of cancel button
	  //  - callback
	  prompt: function (config, callbackId) {
	    var sender =  this.sender
	    config.callback = function (val) {
	      sender.performCallback(callbackId, val)
	    }
	    modal.prompt(config)
	  }
	
	}
	
	msg._meta = {
	  modal: [{
	    name: 'toast',
	    args: ['object']
	  }, {
	    name: 'alert',
	    args: ['object', 'string']
	  }, {
	    name: 'confirm',
	    args: ['object', 'string']
	  }, {
	    name: 'prompt',
	    args: ['object', 'string']
	  }]
	}
	
	module.exports = msg


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Alert = __webpack_require__(107)
	var Confirm = __webpack_require__(113)
	var Prompt = __webpack_require__(116)
	var toast = __webpack_require__(119)
	
	var modal = {
	
	  toast: function (msg, duration) {
	    toast.push(msg, duration)
	  },
	
	  alert: function (config) {
	    new Alert(config).show()
	  },
	
	  prompt: function (config) {
	    new Prompt(config).show()
	  },
	
	  confirm: function (config) {
	    new Confirm(config).show()
	  }
	
	}
	
	!window.lib && (window.lib = {})
	window.lib.modal = modal
	
	module.exports = modal

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(108)
	__webpack_require__(111)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	
	function Alert(config) {
	  this.msg = config.message || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  Modal.call(this)
	  this.node.classList.add('amfe-alert')
	}
	
	Alert.prototype = Object.create(Modal.prototype)
	
	Alert.prototype.createNodeContent = function () {
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  this.node.appendChild(buttonGroup)
	  var button = document.createElement('div')
	  button.classList.add(BUTTON_CLASS, 'alert-ok')
	  button.appendChild(document.createTextNode(this.okTitle))
	  buttonGroup.appendChild(button)
	}
	
	Alert.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var button = this.node.querySelector('.' + BUTTON_CLASS)
	  button.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback()
	  }.bind(this))
	}
	
	module.exports = Alert


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(109)
	
	// there will be only one instance of modal.
	var MODAL_WRAP_CLASS = 'amfe-modal-wrap'
	var MODAL_NODE_CLASS = 'amfe-modal-node'
	
	function Modal() {
	  this.wrap = document.querySelector(MODAL_WRAP_CLASS)
	  this.node = document.querySelector(MODAL_NODE_CLASS)
	  if (!this.wrap) {
	    this.createWrap()
	  }
	  if (!this.node) {
	    this.createNode()
	  }
	  this.clearNode()
	  this.createNodeContent()
	  this.bindEvents()
	}
	
	Modal.prototype = {
	
	  show: function () {
	    this.wrap.style.display = 'block'
	    this.node.classList.remove('hide')
	  },
	
	  destroy: function () {
	    document.body.removeChild(this.wrap)
	    document.body.removeChild(this.node)
	    this.wrap = null
	    this.node = null
	  },
	
	  createWrap: function () {
	    this.wrap = document.createElement('div')
	    this.wrap.className = MODAL_WRAP_CLASS
	    document.body.appendChild(this.wrap)
	  },
	
	  createNode: function () {
	    this.node = document.createElement('div')
	    this.node.classList.add(MODAL_NODE_CLASS, 'hide')
	    document.body.appendChild(this.node)
	  },
	
	  clearNode: function () {
	    this.node.innerHTML = ''
	  },
	
	  createNodeContent: function () {
	
	    // do nothing.
	    // child classes can override this method.
	  },
	
	  bindEvents: function () {
	    this.wrap.addEventListener('click', function (e) {
	      e.preventDefault()
	      e.stopPropagation()
	    })
	  }
	}
	
	module.exports = Modal


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(110);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../css-loader/index.js!./modal.css", function() {
				var newContent = require("!!./../../../../css-loader/index.js!./modal.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-modal-wrap {\n  display: none;\n  position: fixed;\n  z-index: 999999999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-color: #000;\n  opacity: 0.5;\n}\n\n.amfe-modal-node {\n  position: fixed;\n  z-index: 9999999999;\n  top: 50%;\n  left: 50%;\n  width: 6.666667rem;\n  min-height: 2.666667rem;\n  border-radius: 0.066667rem;\n  -webkit-transform: translate(-50%, -50%);\n  transform: translate(-50%, -50%);\n  background-color: #fff;\n}\n.amfe-modal-node.hide {\n  display: none;\n}\n.amfe-modal-node .content {\n  width: 100%;\n  min-height: 1.866667rem;\n  box-sizing: border-box;\n  font-size: 0.32rem;\n  line-height: 0.426667rem;\n  padding: 0.213333rem;\n  border-bottom: 1px solid #ddd;\n}\n.amfe-modal-node .btn-group {\n  width: 100%;\n  height: 0.8rem;\n  font-size: 0.373333rem;\n  text-align: center;\n}\n.amfe-modal-node .btn-group .btn {\n  box-sizing: border-box;\n  height: 0.8rem;\n  line-height: 0.8rem;\n}\n", ""]);
	
	// exports


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(112);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../css-loader/index.js!./alert.css", function() {
				var newContent = require("!!./../../../../css-loader/index.js!./alert.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-alert .amfe-alert-ok {\n  width: 100%;\n}\n", ""]);
	
	// exports


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(108)
	__webpack_require__(114)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	
	function Confirm(config) {
	  this.msg = config.message || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  this.cancelTitle = config.cancelTitle || 'Cancel'
	  Modal.call(this)
	  this.node.classList.add('amfe-confirm')
	}
	
	Confirm.prototype = Object.create(Modal.prototype)
	
	Confirm.prototype.createNodeContent = function () {
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  this.node.appendChild(buttonGroup)
	  var btnOk = document.createElement('div')
	  btnOk.appendChild(document.createTextNode(this.okTitle))
	  btnOk.classList.add('btn-ok', BUTTON_CLASS)
	  var btnCancel = document.createElement('div')
	  btnCancel.appendChild(document.createTextNode(this.cancelTitle))
	  btnCancel.classList.add('btn-cancel', BUTTON_CLASS)
	  buttonGroup.appendChild(btnOk)
	  buttonGroup.appendChild(btnCancel)
	  this.node.appendChild(buttonGroup)
	}
	
	Confirm.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var btnOk = this.node.querySelector('.' + BUTTON_CLASS + '.btn-ok')
	  var btnCancel = this.node.querySelector('.' + BUTTON_CLASS + '.btn-cancel')
	  btnOk.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback(this.okTitle)
	  }.bind(this))
	  btnCancel.addEventListener('click', function () {
	    this.destroy()
	    this.callback && this.callback(this.cancelTitle)
	  }.bind(this))
	}
	
	module.exports = Confirm


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(115);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../css-loader/index.js!./confirm.css", function() {
				var newContent = require("!!./../../../../css-loader/index.js!./confirm.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-confirm .btn-group .btn {\n  float: left;\n  width: 50%;\n}\n.amfe-confirm .btn-group .btn.btn-ok {\n  border-right: 1px solid #ddd;\n}\n", ""]);
	
	// exports


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Modal = __webpack_require__(108)
	__webpack_require__(117)
	
	var CONTENT_CLASS = 'content'
	var MSG_CLASS = 'content-msg'
	var BUTTON_GROUP_CLASS = 'btn-group'
	var BUTTON_CLASS = 'btn'
	var INPUT_WRAP_CLASS = 'input-wrap'
	var INPUT_CLASS = 'input'
	
	function Prompt(config) {
	  this.msg = config.message || ''
	  this.defaultMsg = config.default || ''
	  this.callback = config.callback
	  this.okTitle = config.okTitle || 'OK'
	  this.cancelTitle = config.cancelTitle || 'Cancel'
	  Modal.call(this)
	  this.node.classList.add('amfe-prompt')
	}
	
	Prompt.prototype = Object.create(Modal.prototype)
	
	Prompt.prototype.createNodeContent = function () {
	
	  var content = document.createElement('div')
	  content.classList.add(CONTENT_CLASS)
	  this.node.appendChild(content)
	
	  var msg = document.createElement('div')
	  msg.classList.add(MSG_CLASS)
	  msg.appendChild(document.createTextNode(this.msg))
	  content.appendChild(msg)
	
	  var inputWrap = document.createElement('div')
	  inputWrap.classList.add(INPUT_WRAP_CLASS)
	  content.appendChild(inputWrap)
	  var input = document.createElement('input')
	  input.classList.add(INPUT_CLASS)
	  input.type = 'text'
	  input.autofocus = true
	  input.placeholder = this.defaultMsg
	  inputWrap.appendChild(input)
	
	  var buttonGroup = document.createElement('div')
	  buttonGroup.classList.add(BUTTON_GROUP_CLASS)
	  var btnOk = document.createElement('div')
	  btnOk.appendChild(document.createTextNode(this.okTitle))
	  btnOk.classList.add('btn-ok', BUTTON_CLASS)
	  var btnCancel = document.createElement('div')
	  btnCancel.appendChild(document.createTextNode(this.cancelTitle))
	  btnCancel.classList.add('btn-cancel', BUTTON_CLASS)
	  buttonGroup.appendChild(btnOk)
	  buttonGroup.appendChild(btnCancel)
	  this.node.appendChild(buttonGroup)
	}
	
	Prompt.prototype.bindEvents = function () {
	  Modal.prototype.bindEvents.call(this)
	  var btnOk = this.node.querySelector('.' + BUTTON_CLASS + '.btn-ok')
	  var btnCancel = this.node.querySelector('.' + BUTTON_CLASS + '.btn-cancel')
	  var that = this
	  btnOk.addEventListener('click', function () {
	    var val = document.querySelector('input').value
	    this.destroy()
	    this.callback && this.callback({
	      result: that.okTitle,
	      data: val
	    })
	  }.bind(this))
	  btnCancel.addEventListener('click', function () {
	    var val = document.querySelector('input').value
	    this.destroy()
	    this.callback && this.callback({
	      result: that.cancelTitle
	    })
	  }.bind(this))
	}
	
	module.exports = Prompt


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(118);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../css-loader/index.js!./prompt.css", function() {
				var newContent = require("!!./../../../../css-loader/index.js!./prompt.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-prompt .input-wrap {\n  box-sizing: border-box;\n  width: 100%;\n  padding: 0.24rem 0.213333rem 0.213333rem;\n  height: 0.96rem;\n}\n.amfe-prompt .input-wrap .input {\n  box-sizing: border-box;\n  width: 100%;\n  height: 0.56rem;\n  line-height: 0.56rem;\n  font-size: 0.32rem;\n}\n.amfe-prompt .btn-group .btn {\n  float: left;\n  width: 50%;\n}\n.amfe-prompt .btn-group .btn.btn-ok {\n  border-right: 1px solid #ddd;\n}\n", ""]);
	
	// exports


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(120)
	
	var queue = []
	var timer
	var isProcessing = false
	var toastWin
	var TOAST_WIN_CLASS_NAME = 'amfe-toast'
	
	var DEFAULT_DURATION = 0.8
	
	function showToastWindow(msg, callback) {
	  var handleTransitionEnd = function () {
	    toastWin.removeEventListener('transitionend', handleTransitionEnd)
	    callback && callback()
	  }
	  if (!toastWin) {
	    toastWin = document.createElement('div')
	    toastWin.classList.add(TOAST_WIN_CLASS_NAME, 'hide')
	    document.body.appendChild(toastWin)
	  }
	  toastWin.innerHTML = msg
	  toastWin.addEventListener('transitionend', handleTransitionEnd)
	  setTimeout(function () {
	    toastWin.classList.remove('hide')
	  }, 0)
	}
	
	function hideToastWindow(callback) {
	  var handleTransitionEnd = function () {
	    toastWin.removeEventListener('transitionend', handleTransitionEnd)
	    callback && callback()
	  }
	  if (!toastWin) {
	    return
	  }
	  toastWin.addEventListener('transitionend', handleTransitionEnd)
	  toastWin.classList.add('hide')
	}
	
	var toast = {
	
	  push: function (msg, duration) {
	    queue.push({
	      msg: msg,
	      duration: duration || DEFAULT_DURATION
	    })
	    this.show()
	  },
	
	  show: function () {
	    var that = this
	
	    // All messages had been toasted already, so remove the toast window,
	    if (!queue.length) {
	      toastWin && toastWin.parentNode.removeChild(toastWin)
	      toastWin = null
	      return
	    }
	
	    // the previous toast is not ended yet.
	    if (isProcessing) {
	      return
	    }
	    isProcessing = true
	
	    var toastInfo = queue.shift()
	    showToastWindow(toastInfo.msg, function () {
	      timer = setTimeout(function () {
	        timer = null
	        hideToastWindow(function () {
	          isProcessing = false
	          that.show()
	        })
	      }, toastInfo.duration * 1000)
	    })
	  }
	
	}
	
	module.exports = {
	  push: toast.push.bind(toast)
	}


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(121);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../../../css-loader/index.js!./toast.css", function() {
				var newContent = require("!!./../../../../css-loader/index.js!./toast.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".amfe-toast {\n  font-size: 0.32rem;\n  line-height: 0.426667rem;\n  position: fixed;\n  box-sizing: border-box;\n  max-width: 80%;\n  bottom: 2.666667rem;\n  left: 50%;\n  padding: 0.213333rem;\n  background-color: #000;\n  color: #fff;\n  text-align: center;\n  opacity: 0.6;\n  transition: all 0.4s ease-in-out;\n  border-radius: 0.066667rem;\n  -webkit-transform: translateX(-50%);\n  transform: translateX(-50%);\n}\n\n.amfe-toast.hide {\n  opacity: 0;\n}\n", ""]);
	
	// exports


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var Sender = __webpack_require__(31)
	
	var _data = {}
	
	var animation = {
	
	  /**
	   * transition
	   * @param  {string} ref        [description]
	   * @param  {obj} config     [description]
	   * @param  {string} callbackId [description]
	   */
	  transition: function (ref, config, callbackId) {
	    var refData = _data[ref]
	    var stylesKey = JSON.stringify(config.styles)
	    var weexInstance = this
	    // If the same component perform a animation with exactly the same
	    // styles in a sequence with so short interval that the prev animation
	    // is still in playing, then the next animation should be ignored.
	    if (refData && refData[stylesKey]) {
	      return
	    }
	    if (!refData) {
	      refData = _data[ref] = {}
	    }
	    refData[stylesKey] = true
	    return this.getComponentManager().transition(ref, config, function () {
	      // Remove the stylesKey in refData so that the same animation
	      // can be played again after current animation is already finished.
	      delete refData[stylesKey]
	      weexInstance.sender.performCallback(callbackId)
	    })
	  }
	
	}
	
	animation._meta = {
	  animation: [{
	    name: 'transition',
	    args: ['string', 'object', 'string']
	  }]
	}
	
	module.exports = animation


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var sender = __webpack_require__(31)
	
	var webview = {
	
	  // ref: ref of the web component.
	  goBack: function (ref) {
	    var webComp = this.getComponentManager().getElementByRef(ref)
	    if (!webComp.goBack) {
	      console.error('error: the specified component has no method of'
	          + ' goBack. Please make sure it is a webview component.')
	      return
	    }
	    webComp.goBack()
	  },
	
	  // ref: ref of the web component.
	  goForward: function (ref) {
	    var webComp = this.getComponentManager().getElementByRef(ref)
	    if (!webComp.goForward) {
	      console.error('error: the specified component has no method of'
	          + ' goForward. Please make sure it is a webview component.')
	      return
	    }
	    webComp.goForward()
	  },
	
	  // ref: ref of the web component.
	  reload: function (ref) {
	    var webComp = this.getComponentManager().getElementByRef(ref)
	    if (!webComp.reload) {
	      console.error('error: the specified component has no method of'
	          + ' reload. Please make sure it is a webview component.')
	      return
	    }
	    webComp.reload()
	  }
	
	}
	
	webview._meta = {
	  webview: [{
	    name: 'goBack',
	    args: ['string']
	  }, {
	    name: 'goForward',
	    args: ['string']
	  }, {
	    name: 'reload',
	    args: ['string']
	  }]
	}
	
	module.exports = webview


/***/ },
/* 124 */
/***/ function(module, exports) {

	'use strict'
	
	var timer = {
	
	  setTimeout: function (timeoutCallbackId, delay) {
	    var sender = this.sender
	    var timerId = setTimeout(function () {
	      sender.performCallback(timeoutCallbackId)
	    }, delay)
	  },
	
	  clearTimeout: function (timerId) {
	    clearTimeout(timerId)
	  }
	
	}
	
	timer._meta = {
	  timer: [{
	    name: 'setTimeout',
	    args: ['function', 'number']
	  }, {
	    name: 'clearTimeout',
	    args: ['number']
	  }]
	}
	
	module.exports = timer


/***/ },
/* 125 */
/***/ function(module, exports) {

	'use strict'
	
	var navigator = {
	
	  // config
	  //  - url: the url to push
	  //  - animated: this configuration item is native only
	  //  callback is not currently supported
	  push: function (config, callbackId) {
	    window.location.href = config.url
	    this.sender.performCallback(callbackId)
	  },
	
	  // config
	  //  - animated: this configuration item is native only
	  //  callback is note currently supported
	  pop: function (config, callbackId) {
	    window.history.back()
	    this.sender.performCallback(callbackId)
	  }
	
	}
	
	navigator._meta = {
	  navigator: [{
	    name: 'push',
	    args: ['object', 'function']
	  }, {
	    name: 'pop',
	    args: ['object', 'function']
	  }]
	}
	
	module.exports = navigator


/***/ },
/* 126 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){Object.defineProperty(this,"val",{value:a.toString(),enumerable:!0}),this.gt=function(a){return c.compare(this,a)>0},this.gte=function(a){return c.compare(this,a)>=0},this.lt=function(a){return c.compare(this,a)<0},this.lte=function(a){return c.compare(this,a)<=0},this.eq=function(a){return 0===c.compare(this,a)}}b.env=b.env||{},c.prototype.toString=function(){return this.val},c.prototype.valueOf=function(){for(var a=this.val.split("."),b=[],c=0;c<a.length;c++){var d=parseInt(a[c],10);isNaN(d)&&(d=0);var e=d.toString();e.length<5&&(e=Array(6-e.length).join("0")+e),b.push(e),1===b.length&&b.push(".")}return parseFloat(b.join(""))},c.compare=function(a,b){a=a.toString().split("."),b=b.toString().split(".");for(var c=0;c<a.length||c<b.length;c++){var d=parseInt(a[c],10),e=parseInt(b[c],10);if(window.isNaN(d)&&(d=0),window.isNaN(e)&&(e=0),e>d)return-1;if(d>e)return 1}return 0},b.version=function(a){return new c(a)}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.location.search.replace(/^\?/,"");if(b.env.params={},c)for(var d=c.split("&"),e=0;e<d.length;e++){d[e]=d[e].split("=");try{b.env.params[d[e][0]]=decodeURIComponent(d[e][1])}catch(f){b.env.params[d[e][0]]=d[e][1]}}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;if(c=d.match(/Windows\sPhone\s(?:OS\s)?([\d\.]+)/))b.env.os={name:"Windows Phone",isWindowsPhone:!0,version:c[1]};else if(d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/)))b.env.os={version:c[1]},d.match(/Mobile\s+Safari/)?(b.env.os.name="Android",b.env.os.isAndroid=!0):(b.env.os.name="AndroidPad",b.env.os.isAndroidPad=!0);else if(c=d.match(/(iPhone|iPad|iPod)/)){var e=c[1];c=d.match(/OS ([\d_\.]+) like Mac OS X/),b.env.os={name:e,isIPhone:"iPhone"===e||"iPod"===e,isIPad:"iPad"===e,isIOS:!0,version:c[1].split("_").join(".")}}else b.env.os={name:"unknown",version:"0.0.0"};b.version&&(b.env.os.version=b.version(b.env.os.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;(c=d.match(/(?:UCWEB|UCBrowser\/)([\d\.]+)/))?b.env.browser={name:"UC",isUC:!0,version:c[1]}:(c=d.match(/MQQBrowser\/([\d\.]+)/))?b.env.browser={name:"QQ",isQQ:!0,version:c[1]}:(c=d.match(/Firefox\/([\d\.]+)/))?b.env.browser={name:"Firefox",isFirefox:!0,version:c[1]}:(c=d.match(/MSIE\s([\d\.]+)/))||(c=d.match(/IEMobile\/([\d\.]+)/))?(b.env.browser={version:c[1]},d.match(/IEMobile/)?(b.env.browser.name="IEMobile",b.env.browser.isIEMobile=!0):(b.env.browser.name="IE",b.env.browser.isIE=!0),d.match(/Android|iPhone/)&&(b.env.browser.isIELikeWebkit=!0)):(c=d.match(/(?:Chrome|CriOS)\/([\d\.]+)/))?(b.env.browser={name:"Chrome",isChrome:!0,version:c[1]},d.match(/Version\/[\d+\.]+\s*Chrome/)&&(b.env.browser.name="Chrome Webview",b.env.browser.isWebview=!0)):d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/))?b.env.browser={name:"Android",isAndroid:!0,version:c[1]}:d.match(/iPhone|iPad|iPod/)?d.match(/Safari/)?(c=d.match(/Version\/([\d\.]+)/),b.env.browser={name:"Safari",isSafari:!0,version:c[1]}):(c=d.match(/OS ([\d_\.]+) like Mac OS X/),b.env.browser={name:"iOS Webview",isWebview:!0,version:c[1].replace(/\_/g,".")}):b.env.browser={name:"unknown",version:"0.0.0"},b.version&&(b.env.browser.version=b.version(b.env.browser.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.navigator.userAgent;c.match(/Weibo/i)?b.env.thirdapp={appname:"Weibo",isWeibo:!0}:c.match(/MicroMessenger/i)?b.env.thirdapp={appname:"Weixin",isWeixin:!0}:b.env.thirdapp=!1}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d,e=a.navigator.userAgent;(d=e.match(/WindVane[\/\s]([\d\.\_]+)/))&&(c=d[1]);var f=!1,g="",h="",i="";(d=e.match(/AliApp\(([A-Z\-]+)\/([\d\.]+)\)/i))&&(f=!0,g=d[1],i=d[2],h=g.indexOf("-PD")>0?b.env.os.isIOS?"iPad":b.env.os.isAndroid?"AndroidPad":b.env.os.name:b.env.os.name),!g&&e.indexOf("TBIOS")>0&&(g="TB"),f?b.env.aliapp={windvane:b.version(c||"0.0.0"),appname:g||"unkown",version:b.version(i||"0.0.0"),platform:h||b.env.os.name}:b.env.aliapp=!1,b.env.taobaoApp=b.env.aliapp}(window,window.lib||(window.lib={}));;module.exports = window.lib['env'];

/***/ },
/* 127 */
/***/ function(module, exports) {

	'use strict'
	
	function loadByMtop(pageId, callback) {
	  lib.mtop.request({
	    api: 'mtop.geb.weappplus.viewloader.query',
	    v: '2.0',
	    data: {
	      page: pageId,
	      clientVersion: 10000
	    },
	    ecode: 0
	  }).then(function (result) {
	    var code = result.data && result.data.jsStr
	    if (code) {
	      callback(null, code)
	    }
	  }, function (error) {
	    callback(new Error('load'), error)
	  })
	}
	
	module.exports = {
	  loadByMtop: loadByMtop
	}


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	var event = __webpack_require__(129)
	var pageInfo = __webpack_require__(134)
	var stream = __webpack_require__(135)
	var user = __webpack_require__(138)
	var userTrack = __webpack_require__(139)
	var windvane = __webpack_require__(140)
	
	var api = {
	  init: function (Weex) {
	    Weex.registerApiModule('event', event, event._meta)
	    Weex.registerApiModule('pageInfo', pageInfo, pageInfo._meta)
	    Weex.registerApiModule('stream', stream, stream._meta)
	    Weex.registerApiModule('user', user, user._meta)
	    Weex.registerApiModule('userTrack', userTrack, userTrack._meta)
	    Weex.registerApiModule('windvane', windvane, windvane._meta)
	  }
	}
	
	module.exports = api

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	// require('envd')
	// require('httpurl')
	__webpack_require__(130)
	__webpack_require__(133)
	
	// is url of taoke?
	var url = lib.httpurl(location.href)
	var isInTaoke = url.params['ali_trackid']
	  && url.params['ali_trackid'].indexOf('2:') === 0
	
	// is this app of alibaba inc.?
	var isAliApp = lib.env.aliapp
	
	/**
	 * Call taobao app from a non-alibaba non-taoke app client.
	 * Will add second parameter for telling whether or not to call taobao app
	 * in future. (not supported for now.)
	 */
	function callApp(url) {
	  if (!isAliApp && !isInTaoke) {
	    try {
	      lib.callapp.gotoPage(url)
	    } catch (err) {
	      // do nothing.
	    }
	    setTimeout(function () {
	      location.href = url
	    }, 300)
	  }
	  else {
	    location.href = url
	  }
	}
	
	var event = {
	
	  /**
	   * openUrl
	   * @param  {string} url
	   */
	  openURL: function (url) {
	    if (lib.env.aliapp) {
	      // TM app will create no webview instance when not intentionally
	      // telling it to.
	      // Ali relies on http://g.alicdn.com/hybrid/api/3.0.11/hybrid.min.js
	      if (lib.env.aliapp.appname === 'TM') {
	        Ali.pushWindow(url, function (data) {
	          if (data.errorCode) {
	            window.open(url)
	          }
	        })
	      }
	      // TB ios client will destory current webview because of cpp=1.
	      // Therefor the method openWindow of windvane is needed.
	      else if (lib.env.aliapp.appname === 'TB' && lib.env.os.isIOS) {
	        lib.windvane.call('Base', 'openWindow', {
	          url: url
	        })
	      }
	      else {
	        // callApp(url)
	        location.href = url
	      }
	    }
	    else {
	      // callApp(url)
	      location.href = url
	    }
	  }
	
	}
	
	event._meta = {
	  meta: [{
	    name: 'openURL',
	    args: ['string']
	  }]
	}
	
	module.exports = event

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});__webpack_require__(131);__webpack_require__(132);!function(a,b){function c(a,b){var c=new j(location.href),d=h.getElementById("buried"),e=c.params.ttid,f=c.params.ad_id,g=c.params.source_type,i=c.params.refpid,k=c.params.actparam,l=c.params.actname,m=c.params.ali_trackid,n=c.params.pid,o=h.cookie.match(/(?:^|\s)cna=([^;]+)(?:;|$)/);c.search="",c.hash="";var p={};if(d&&(e=d.value),p.from="h5",e&&(p.ttid=e),i&&(p.refpid=i),k&&(p.actparam=k),l&&(p.actname=l),p.url=c.toString(),n&&(p.pid=n),f&&(p.ad_id=f),g&&(p.source_type=g),m&&(p.ali_trackid=m),o&&(p.h5_uid=o[1]),"object"==typeof b)for(var q in b)p[q]=b[q];return a.params.point=JSON.stringify(p),a}function d(a,b){var c=new j(location.href),d=h.getElementById("buried");for(var e in c.params)a.params.hasOwnProperty(e)||(a.params[e]=c.params[e]);if(d&&(a.params.ttid=d.value),"object"==typeof b)for(var e in b)a.params[e]=b[e];return a}function e(a){o||(o=h.createElement("iframe"),o.id="callapp_iframe_"+Date.now(),o.frameborder="0",o.style.cssText="display:none;border:0;width:0;height:0;",h.body.appendChild(o)),o.src=a}function f(a,b){b.replace===!1||!l&&b.replace!==!0?location.href=a:location.replace(a)}function g(a){var b=document.createElement("a");b.setAttribute("href",a),b.style.display="none",document.body.appendChild(b);var c=document.createEvent("HTMLEvents");c.initEvent("click",!1,!1),b.dispatchEvent(c)}var h=a.document,i=a.navigator.userAgent,j=b.httpurl,k=b.env.os,l=(b.env.params,b.env.aliapp),m=b.env.browser,n={"taobao:":"com.taobao.taobao","taobaowebview:":"com.taobao.taobao","tmall:":"com.tmall.wireless"};b.callapp=b.callapp||{};var o;b.callapp.gotoPage=function(a,b){b=b||{},"undefined"==typeof b.point&&(b.point=!0),"undefined"==typeof b.params&&(b.params=!0);var h=new j(a||location.href);if(a=new j(a),("http:"===a.protocol||"https:"===a.protocol)&&(k.isAndroid&&l&&"TB"===l.appname?(a=new j("taobaowebview://m.taobao.com/"),a.params.weburl=h.toString()):a.protocol="taobao:"),"taobao:"===a.protocol)b.point&&c(a,b.point),b.params&&d(a,b.params);else if("taobaowebview:"===a.protocol){b.point&&c(a,b.point);var o=new j(a.params.weburl);b.params&&d(o,b.params),b.point&&c(o,b.point),a.params.weburl=o.toString()}else"tmall:"!==a.protocol.toLowerCase()&&"kddcpublic:"!==a.protocol.toLowerCase()&&"mdatadwphone:"!==a.protocol.toLowerCase()&&b.params&&d(a,b.params);var p=k.isAndroid&&m.isChrome&&!m.isWebview,q=k.isAndroid&&!!i.match(/samsung/i)&&k.version.gte("4.3")&&k.version.lt("4.5"),r=k.isIPhone&&k.version.gte("9.0")&&m.isSafari;(p||q||b.forceIntent)&&(a.hash="Intent;scheme="+a.protocol.replace(":","")+";package="+(b["package"]||n[a.protocol])+";end",a.protocol="intent:"),r?setTimeout(function(){g(a.toString(),b)},100):l||"intent:"===a.protocol?setTimeout(function(){f(a.toString(),b)},100):e(a.toString())},b.callapp.download=function(a,b){b=b||{},a||(a=k.isIPhone?"http://itunes.apple.com/cn/app/id387682726?mt=8":k.isIPad?"https://itunes.apple.com/app/id438865278":k.isAndroid?"//download.alicdn.com/wireless/taobao4android/latest/taobao4android_703248.apk":""),a=new j(a),k.isAndroid&&a.pathname.match(/\.apk$/)?(a.search="",a.hash=""):b.params&&d(a,b.params),a=a.toString(),f(a,b)}}(window,window.lib||(window.lib={}));;module.exports = window.lib.callapp;

/***/ },
/* 131 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){Object.defineProperty(this,"val",{value:a.toString(),enumerable:!0}),this.gt=function(a){return c.compare(this,a)>0},this.gte=function(a){return c.compare(this,a)>=0},this.lt=function(a){return c.compare(this,a)<0},this.lte=function(a){return c.compare(this,a)<=0},this.eq=function(a){return 0===c.compare(this,a)}}b.env=b.env||{},c.prototype.toString=function(){return this.val},c.prototype.valueOf=function(){for(var a=this.val.split("."),b=[],c=0;c<a.length;c++){var d=parseInt(a[c],10);isNaN(d)&&(d=0);var e=d.toString();e.length<5&&(e=Array(6-e.length).join("0")+e),b.push(e),1===b.length&&b.push(".")}return parseFloat(b.join(""))},c.compare=function(a,b){a=a.toString().split("."),b=b.toString().split(".");for(var c=0;c<a.length||c<b.length;c++){var d=parseInt(a[c],10),e=parseInt(b[c],10);if(window.isNaN(d)&&(d=0),window.isNaN(e)&&(e=0),e>d)return-1;if(d>e)return 1}return 0},b.version=function(a){return new c(a)}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.location.search.replace(/^\?/,"");if(b.env.params={},c)for(var d=c.split("&"),e=0;e<d.length;e++){d[e]=d[e].split("=");try{b.env.params[d[e][0]]=decodeURIComponent(d[e][1])}catch(f){b.env.params[d[e][0]]=d[e][1]}}}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;if(c=d.match(/Windows\sPhone\s(?:OS\s)?([\d\.]+)/))b.env.os={name:"Windows Phone",isWindowsPhone:!0,version:c[1]};else if(d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/)))b.env.os={version:c[1]},d.match(/Mobile\s+Safari/)?(b.env.os.name="Android",b.env.os.isAndroid=!0):(b.env.os.name="AndroidPad",b.env.os.isAndroidPad=!0);else if(c=d.match(/(iPhone|iPad|iPod)/)){var e=c[1];(c=d.match(/OS ([\d_\.]+) like Mac OS X/))&&(b.env.os={name:e,isIPhone:"iPhone"===e||"iPod"===e,isIPad:"iPad"===e,isIOS:!0,version:c[1].split("_").join(".")})}b.env.os||(b.env.os={name:"unknown",version:"0.0.0"}),b.version&&(b.env.os.version=b.version(b.env.os.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d=a.navigator.userAgent;(c=d.match(/(?:UCWEB|UCBrowser\/)([\d\.]+)/))?b.env.browser={name:"UC",isUC:!0,version:c[1]}:(c=d.match(/MQQBrowser\/([\d\.]+)/))?b.env.browser={name:"QQ",isQQ:!0,version:c[1]}:(c=d.match(/(?:Firefox|FxiOS)\/([\d\.]+)/))?b.env.browser={name:"Firefox",isFirefox:!0,version:c[1]}:(c=d.match(/MSIE\s([\d\.]+)/))||(c=d.match(/IEMobile\/([\d\.]+)/))?(b.env.browser={version:c[1]},d.match(/IEMobile/)?(b.env.browser.name="IEMobile",b.env.browser.isIEMobile=!0):(b.env.browser.name="IE",b.env.browser.isIE=!0),d.match(/Android|iPhone/)&&(b.env.browser.isIELikeWebkit=!0)):(c=d.match(/(?:Chrome|CriOS)\/([\d\.]+)/))?(b.env.browser={name:"Chrome",isChrome:!0,version:c[1]},d.match(/Version\/[\d+\.]+\s*Chrome/)&&(b.env.browser.name="Chrome Webview",b.env.browser.isWebview=!0)):d.match(/Safari/)&&(c=d.match(/Android[\s\/]([\d\.]+)/))?b.env.browser={name:"Android",isAndroid:!0,version:c[1]}:d.match(/iPhone|iPad|iPod/)&&(d.match(/Safari/)&&(c=d.match(/Version\/([\d\.]+)/))?b.env.browser={name:"Safari",isSafari:!0,version:c[1]}:(c=d.match(/OS ([\d_\.]+) like Mac OS X/))&&(b.env.browser={name:"iOS Webview",isWebview:!0,version:c[1].replace(/\_/g,".")})),b.env.browser||(b.env.browser={name:"unknown",version:"0.0.0"}),b.version&&(b.env.browser.version=b.version(b.env.browser.version))}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c=a.navigator.userAgent;b.env.thirdapp=c.match(/Weibo/i)?{appname:"Weibo",isWeibo:!0}:c.match(/MicroMessenger/i)?{appname:"Weixin",isWeixin:!0}:!1}(window,window.lib||(window.lib={})),function(a,b){b.env=b.env||{};var c,d,e=a.navigator.userAgent;(d=e.match(/WindVane[\/\s]([\d\.\_]+)/))&&(c=d[1]);var f=!1,g="",h="",i="",j=a._ua_popLayer||"",k=!1,l="";(d=e.match(/AliApp\(([A-Z\-]+)\/([\d\.]+)\)/i))&&(f=!0,g=d[1],i=d[2],h=g.indexOf("-PD")>0?b.env.os.isIOS?"iPad":b.env.os.isAndroid?"AndroidPad":b.env.os.name:b.env.os.name),!g&&e.indexOf("TBIOS")>0&&(g="TB"),j&&(d=j.match(/PopLayer\/([\d\.]+)/i))&&(k=!0,l=d[1]),b.env.aliapp=f?{windvane:b.version(c||"0.0.0"),appname:g||"unkown",version:b.version(i||"0.0.0"),platform:h||b.env.os.name,poplayer:k||!1,poplayerVersion:b.version(l||"0.0.0")}:!1,b.env.taobaoApp=b.env.aliapp}(window,window.lib||(window.lib={}));;module.exports = window.lib['env'];

/***/ },
/* 132 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){var b={};Object.defineProperty(this,"params",{set:function(a){if("object"==typeof a){for(var c in b)delete b[c];for(var c in a)b[c]=a[c]}},get:function(){return b},enumerable:!0}),Object.defineProperty(this,"search",{set:function(a){if("string"==typeof a){0===a.indexOf("?")&&(a=a.substr(1));var c=a.split("&");for(var d in b)delete b[d];for(var e=0;e<c.length;e++){var f=c[e].split("=");if(void 0!==f[1]&&(f[1]=f[1].toString()),f[0])try{b[decodeURIComponent(f[0])]=decodeURIComponent(f[1])}catch(g){b[f[0]]=f[1]}}}},get:function(){var a=[];for(var c in b)if(void 0!==b[c])if(""!==b[c])try{a.push(encodeURIComponent(c)+"="+encodeURIComponent(b[c]))}catch(d){a.push(c+"="+b[c])}else try{a.push(encodeURIComponent(c))}catch(d){a.push(c)}return a.length?"?"+a.join("&"):""},enumerable:!0});var c;Object.defineProperty(this,"hash",{set:function(a){"string"==typeof a&&(a&&a.indexOf("#")<0&&(a="#"+a),c=a||"")},get:function(){return c},enumerable:!0}),this.set=function(a){a=a||"";var b;if(!(b=a.match(new RegExp("^([a-z0-9-]+:)?[/]{2}(?:([^@/:?]+)(?::([^@/:]+))?@)?([^:/?#]+)(?:[:]([0-9]+))?([/][^?#;]*)?(?:[?]([^#]*))?([#][^?]*)?$","i"))))throw new Error("Wrong uri scheme.");this.protocol=b[1]||("object"==typeof location?location.protocol:""),this.username=b[2]||"",this.password=b[3]||"",this.hostname=this.host=b[4],this.port=b[5]||"",this.pathname=b[6]||"/",this.search=b[7]||"",this.hash=b[8]||"",this.origin=this.protocol+"//"+this.hostname},this.toString=function(){var a=this.protocol+"//";return this.username&&(a+=this.username,this.password&&(a+=":"+this.password),a+="@"),a+=this.host,this.port&&"80"!==this.port&&(a+=":"+this.port),this.pathname&&(a+=this.pathname),this.search&&(a+=this.search),this.hash&&(a+=this.hash),a},a&&this.set(a.toString())}b.httpurl=function(a){return new c(a)}}(window,window.lib||(window.lib={}));;module.exports = window.lib.httpurl;

/***/ },
/* 133 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a,b){a=a.toString().split("."),b=b.toString().split(".");for(var c=0;c<a.length||c<b.length;c++){var d=parseInt(a[c],10),e=parseInt(b[c],10);if(window.isNaN(d)&&(d=0),window.isNaN(e)&&(e=0),e>d)return-1;if(d>e)return 1}return 0}var d=a.Promise,e=a.document,f=a.navigator.userAgent,g=/Windows\sPhone\s(?:OS\s)?[\d\.]+/i.test(f)||/Windows\sNT\s[\d\.]+/i.test(f),h=g&&a.WindVane_Win_Private&&a.WindVane_Win_Private.call,i=/iPhone|iPad|iPod/i.test(f),j=/Android/i.test(f),k=f.match(/WindVane[\/\s](\d+[._]\d+[._]\d+)/),l=Object.prototype.hasOwnProperty,m=b.windvane=a.WindVane||(a.WindVane={}),n=(a.WindVane_Native,1),o=[],p=3,q="hybrid",r="wv_hybrid",s="iframe_",t="suc_",u="err_",v="defer_",w="param_",x="chunk_",y=6e5,z=6e5,A=6e4;k=k?(k[1]||"0.0.0").replace(/\_/g,"."):"0.0.0";var B={isAvailable:1===c(k,"0"),call:function(a,b,c,e,f,g){var h,i;return"number"==typeof arguments[arguments.length-1]&&(g=arguments[arguments.length-1]),"function"!=typeof e&&(e=null),"function"!=typeof f&&(f=null),d&&(i={},i.promise=new d(function(a,b){i.resolve=a,i.reject=b})),h=g>0?setTimeout(function(){B.onFailure(h,{ret:"HY_TIMEOUT"})},g):C.getSid(),C.registerCall(h,e,f,i),C.registerGC(h,g),B.isAvailable?C.callMethod(a,b,c,h):B.onFailure(h,{ret:"HY_NOT_IN_WINDVANE"}),i?i.promise:void 0},fireEvent:function(a,b,c){var d=e.createEvent("HTMLEvents");d.initEvent(a,!1,!0),d.param=C.parseData(b||C.getData(c)),e.dispatchEvent(d)},getParam:function(a){return C.getParam(a)},setData:function(a,b){C.setData(a,b)},onSuccess:function(a,b){C.onComplete(a,b,"success")},onFailure:function(a,b){C.onComplete(a,b,"failure")}},C={params:{},chunks:{},calls:{},getSid:function(){return Math.floor(Math.random()*(1<<50))+""+n++},buildParam:function(a){return a&&"object"==typeof a?JSON.stringify(a):a||""},getParam:function(a){return this.params[w+a]||""},setParam:function(a,b){this.params[w+a]=b},parseData:function(a){var b;if(a&&"string"==typeof a)try{b=JSON.parse(a)}catch(c){b={ret:["WV_ERR::PARAM_PARSE_ERROR"]}}else b=a||{};return b},setData:function(){this.chunks[x+sid]=this.chunks[x+sid]||[],this.chunks[x+sid].push(chunk)},getData:function(a){return this.chunks[x+a]?this.chunks[x+a].join(""):""},registerCall:function(a,b,c,d){b&&(this.calls[t+a]=b),c&&(this.calls[u+a]=c),d&&(this.calls[v+a]=d)},unregisterCall:function(a){var b=t+a,c=u+a,d=v+a,e={};return this.calls[b]&&(e.success=this.calls[b],delete this.calls[b]),this.calls[c]&&(e.failure=this.calls[c],delete this.calls[c]),this.calls[d]&&(e.deferred=this.calls[d],delete this.calls[d]),e},useIframe:function(a,b){var c=s+a,d=o.pop();d||(d=e.createElement("iframe"),d.setAttribute("frameborder","0"),d.style.cssText="width:0;height:0;border:0;display:none;"),d.setAttribute("id",c),d.setAttribute("src",b),d.parentNode||setTimeout(function(){e.body.appendChild(d)},5)},retrieveIframe:function(a){var b=s+a,c=e.querySelector("#"+b);o.length>=p?e.body.removeChild(c):o.push(c)},callMethod:function(b,c,d,e){if(d=C.buildParam(d),g)h?a.WindVane_Win_Private.call(b,c,e,d):this.onComplete(e,{ret:"HY_NO_HANDLER_ON_WP"},"failure");else{var f=q+"://"+b+":"+e+"/"+c+"?"+d;if(i)this.setParam(e,d),this.useIframe(e,f);else if(j){var k=r+":";window.prompt(f,k)}else this.onComplete(e,{ret:"HY_NOT_SUPPORT_DEVICE"},"failure")}},registerGC:function(a,b){var c=this,d=Math.max(b||0,y),e=Math.max(b||0,A),f=Math.max(b||0,z);setTimeout(function(){c.unregisterCall(a)},d),i?setTimeout(function(){c.params[w+a]&&delete c.params[w+a]},e):j&&setTimeout(function(){c.chunks[x+a]&&delete c.chunks[x+a]},f)},onComplete:function(a,b,c){clearTimeout(a);var d=this.unregisterCall(a),e=d.success,f=d.failure,g=d.deferred;b=b?b:this.getData(a),b=this.parseData(b);var h=b.ret;"string"==typeof h&&(b=b.value||b,b.ret||(b.ret=[h])),"success"===c?(e&&e(b),g&&g.resolve(b)):"failure"===c&&(f&&f(b),g&&g.reject(b)),i?(this.retrieveIframe(a),this.params[w+a]&&delete this.params[w+a]):j&&this.chunks[x+a]&&delete this.chunks[x+a]}};for(var D in B)l.call(m,D)||(m[D]=B[D])}(window,window.lib||(window.lib={}));;module.exports = window.lib['windvane'];

/***/ },
/* 134 */
/***/ function(module, exports) {

	'use strict'
	
	var pageInfo = {
	
	  setTitle: function (title) {
	    title = title || 'Weex HTML5'
	    try {
	      title = decodeURIComponent(title)
	    } catch (e) {}
	    document.title = title
	    if (lib.env.taobaoApp
	        && lib.env.taobaoApp.appname == 'TB'
	        && lib.windvane) {
	      lib.windvane.call('WebAppInterface'
	                        ,'setCustomPageTitle'
	                        ,{ title: title })
	    }
	  },
	
	  setSpm: function (a, b) {
	    if (a) {
	      var meta = document.querySelector('meta[name="data-spm"]')
	      if (!meta) {
	        meta = document.createElement('meta')
	        meta.setAttribute('name', 'data-spm')
	        document.head.appendChild(meta)
	      }
	      meta.setAttribute('content', a)
	    }
	
	    if (b) {
	      document.body.setAttribute('data-spm', b)
	    }
	  }
	}
	
	pageInfo._meta = {
	  pageInfo: [{
	    name: 'setTitle',
	    args: ['string']
	  }, {
	    name: 'setSpm',
	    args: ['string', 'string']
	  }]
	}
	
	module.exports = pageInfo

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict'
	
	var weex = __webpack_require__(9)
	var extend = weex.utils.extend
	
	// require('envd')
	__webpack_require__(133)
	__webpack_require__(136)
	__webpack_require__(137)
	
	var stream = {
	  /**
	   * sendMtop
	   * @param  {obj}   config
	   *   string api 请求的 API 名称。(optional: apiName)
	   *   string ecode (可选)是否使用 ecode 签名，需要与服务端 API 约定，
	   *     '1' 表示使用，'0' 表示不使用。默认为 '0'。
	   *   string isHttps (可选)是否使用 Https，'1' 表示使用，'0' 表示不
	   *     使用。默认为 '0'。
	   *   string isSec (可选)是否使用 WUA，（是否走黑匣子加签，是底层决定
	   *     的），'1' 表示使用，'0' 表示不使用。默认为 '0'。
	   *   object param (可选)请求的参数，JSON 对象。
	   *   string (post)(可选)是否使用 POST 方式请求，'1' 表示使用，'0' 表
	   *     示不使用。默认为 '0'。
	   *   int timer (可选)发送网络请求的超时时间（毫秒），如果在指定时间内
	   *     网络请求没有回来，则自动走缓存；如果没有缓存，则返回超时错误。-1
	   *     或不传表示不设置超时，总是会等待网络请求。
	   *   string v (可选)API 版本号，默认为 '*'。(optional: apiVersion)
	   *   string sessionOption (可选)如果请求的 API 需要登录，是否拉起登
	   *     录界面。'AutoLoginOnly' 表示只做自动登录，
	   *     'AutoLoginAndManualLogin' 做自动登录，登录失败则拉起登录界面，
	   *     默认为'AutoLoginOnly'（手淘 iOS 5.2.8 或更高，Android 平台
	   *     总是允许拉起登录界面）
	   * @param  {string} callbackId
	   */
	  sendMtop: function (config, callbackId) {
	
	    var reqBody, needLogin
	    var self = this
	
	    if (typeof config === 'string') {
	      try {
	        config = JSON.parse(config)
	      } catch (e) {
	        // console.error('mtop 请求参数错误, 请处理!')
	        return
	      }
	    }
	    if (typeof config !== 'object' || (!config.api && !config.apiName)) {
	      // console.error('mtop 请求参数不全, 请处理!')
	      return
	    }
	
	
	    reqBody = extend({}, config)
	
	    // 整理请求参数
	    reqBody.api = reqBody.api || reqBody.apiName
	    reqBody.v = reqBody.v || reqBody.apiVersion
	    needLogin = typeof reqBody.needLogin === 'boolean'
	              ? reqBody.needLogin
	              : reqBody.sessionOption === 'AutoLoginAndManualLogin'
	    reqBody.data = reqBody.param || reqBody.requestParams
	    reqBody.ecode = reqBody.ecode ? parseInt(reqBody.ecode) : 0
	    delete reqBody.apiName
	    delete reqBody.apiVersion
	    delete reqBody.needLogin
	    delete reqBody.isHttps
	    delete reqBody.post
	    delete reqBody.sessionOption
	    delete reqBody.param
	    delete reqBody.requestParams
	
	    // 在纯H5环境，且有 ecode 时，要加 ua 参数用于安全校验
	    var appname = lib.env.aliapp && lib.env.aliapp.appname
	    var isTBTM = appname === 'TB' || appname === 'TM'
	    if (reqBody.ecode
	        && !isTBTM
	        && global['UA_Opt']
	        && (typeof global.getUA === 'function')
	      ) {
	      reqBody.data.ua = getUA()
	    }
	
	    // 只有在 acds 且 客户端版本达到时(只有 TB&5.4 或 TM&5.10 之后才有 acds 插件)，才会真正的发 acds
	    var aliapp = lib.env.aliapp
	    var appname = aliapp && aliapp.appname
	    var version = aliapp && aliapp.version
	    var realRequestType =
	        reqBody.requestType === 'acds' && aliapp &&
	        ((appname === 'TB' && version.gte('5.4')) ||
	        (appname === 'TM' && version.gte('5.10'))) ?
	        'acds' : 'mtop'
	
	    // 包装回调函数
	    var reqCb = function (resp) {
	      // var m = Object.create(null)
	      // m.errCode = resp.retType
	      // m.errMsg = resp.ret
	      // m.data = resp.data
	
	      // 如果是 acds 因为版本不够降到了h5，则需要 mock acds 的返回，因为 js-framework 根据 不同的请求抹平了差异
	      if (reqBody.requestType === 'acds' && realRequestType === 'mtop') {
	        resp = resp.data
	      }
	
	      // resp = JSON.stringify(resp)
	      self.sender.performCallback(callbackId, resp)
	    }
	
	    // 发送请求
	    if (realRequestType === 'acds') {
	      lib.windvane.call('HCWVPlugin', 'getCategrid', {}, function (ret) {
	        // FIXED: ret.result 是一个 stringify 后的 JSON
	        // 坑：当第一次通过此插件访问 acds 数据时
	        // 在 Android Hybrid 中返回的是 ret: {result: '}
	        // 在 iOS Hybrid 中返回的是 ret: {result: '{}'}
	        ret = JSON.parse(ret.result || '{}')
	        reqCb(ret)
	      }, reqCb)
	    }
	    // 如果需要登录，且在纯 H5 环境，使用 loginRequest
	    else if (needLogin && !aliapp) {
	      lib.mtop.loginRequest(reqBody).then(reqCb, reqCb)
	    }
	    // 在 Hybrid 下，windvane 会判断未登录拉起登录界面，直接发请求即可
	    else {
	      lib.mtop.request(reqBody).then(reqCb, reqCb)
	    }
	  }
	
	}
	
	stream._meta = {
	  stream: [{
	    name: 'sendMtop',
	    args: ['object', 'function']
	  }]
	}
	
	module.exports = stream
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 136 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b,c){function d(a){var b=new RegExp("(?:^|;\\s*)"+a+"\\=([^;]+)(?:;\\s*|$)").exec(v.cookie);return b?b[1]:c}function e(a){return a.preventDefault(),!1}function f(b,c){var d=this,f=a.dpr||1,g=document.createElement("div"),h=document.documentElement.getBoundingClientRect(),i=Math.max(h.width,window.innerWidth)/f,j=Math.max(h.height,window.innerHeight)/f;g.style.cssText=["-webkit-transform:scale("+f+") translateZ(0)","-ms-transform:scale("+f+") translateZ(0)","transform:scale("+f+") translateZ(0)","-webkit-transform-origin:0 0","-ms-transform-origin:0 0","transform-origin:0 0","width:"+i+"px","height:"+j+"px","z-index:999999","position:absolute","left:0","top:0px","background:#FFF","display:none"].join(";");var k=document.createElement("div");k.style.cssText=["width:100%","height:52px","background:#EEE","line-height:52px","text-align:left","box-sizing:border-box","padding-left:20px","position:absolute","left:0","top:0","font-size:16px","font-weight:bold","color:#333"].join(";"),k.innerText=b;var l=document.createElement("a");l.style.cssText=["display:block","position:absolute","right:0","top:0","height:52px","line-height:52px","padding:0 20px","color:#999"].join(";"),l.innerText="关闭";var m=document.createElement("iframe");m.style.cssText=["width:100%","height:100%","border:0","overflow:hidden"].join(";"),k.appendChild(l),g.appendChild(k),g.appendChild(m),v.body.appendChild(g),m.src=c,l.addEventListener("click",function(){d.hide();var a=v.createEvent("HTMLEvents");a.initEvent("close",!1,!1),g.dispatchEvent(a)},!1),this.addEventListener=function(){g.addEventListener.apply(g,arguments)},this.removeEventListener=function(){g.removeEventListener.apply(g,arguments)},this.show=function(){document.addEventListener("touchmove",e,!1),g.style.display="block",window.scrollTo(0,0)},this.hide=function(){document.removeEventListener("touchmove",e),window.scrollTo(0,-h.top),v.body.removeChild(g)}}function g(a){if(!a||"function"!=typeof a||!b.mtop){var d=this.getUserNick();return!!d}b.mtop.request({api:"mtop.user.getUserSimple",v:"1.0",data:{isSec:0},H5Request:!0},function(d){d.retType===b.mtop.RESPONSE_TYPE.SUCCESS?a(!0,d):d.retType===b.mtop.RESPONSE_TYPE.SESSION_EXPIRED?a(!1,d):a(c,d)})}function h(a){var b;return u&&(b={},b.promise=new u(function(a,c){b.resolve=a,b.reject=c})),this.isLogin(function(c,d){a&&a(c,d),c===!0?b&&b.resolve(d):b&&b.reject(d)}),b?b.promise:void 0}function i(a){if(!a||"function"!=typeof a){var b="",e=d("_w_tb_nick"),f=d("_nk_")||d("snk"),g=d("sn");return e&&e.length>0&&"null"!=e?b=decodeURIComponent(e):f&&f.length>0&&"null"!=f?b=unescape(unescape(f).replace(/\\u/g,"%u")):g&&g.length>0&&"null"!=g&&(b=decodeURIComponent(g)),b=b.replace(/\</g,"&lt;").replace(/\>/g,"&gt;")}this.isLogin(function(b,d){a(b===!0&&d&&d.data&&d.data.nick?d.data.nick:b===!1?"":c)})}function j(a){var b;return u&&(b={},b.promise=new u(function(a,c){b.resolve=a,b.reject=c})),this.getUserNick(function(c){a&&a(c),c?b&&b.resolve(c):b&&b.reject()}),b?b.promise:void 0}function k(a,b){var c="//"+G+"."+H.subDomain+"."+E+"/"+H[(a||"login")+"Name"];if(b){var d=[];for(var e in b)d.push(e+"="+encodeURIComponent(b[e]));c+="?"+d.join("&")}return c}function l(a,b){if(b)location.replace(a);else{var c=v.createElement("a"),d=v.createEvent("HTMLEvents");c.style.display="none",c.href=a,v.body.appendChild(c),d.initEvent("click",!1,!0),c.dispatchEvent(d)}}function m(b,c,d){function e(b){j.removeEventListener("close",e),a.removeEventListener("message",g),d("CANCEL")}function g(b){var c=b.data||{};c&&"child"===c.type&&c.content.indexOf("SUCCESS")>-1?(j.removeEventListener("close",e),a.removeEventListener("message",g),j.hide(),d("SUCCESS")):d("FAILURE")}var h=location.protocol+"//h5."+H.subDomain+".taobao.com/"+("waptest"===H.subDomain?"src":"other")+"/"+b+"end.html?origin="+encodeURIComponent(location.protocol+"//"+location.hostname),i=k(b,{ttid:"h5@iframe",tpl_redirect_url:h}),j=new f(c.title||"您需要登录才能继续访问",i);j.addEventListener("close",e,!1),a.addEventListener("message",g,!1),j.show()}function n(b,c,d){var e=k(b,{wvLoginCallback:"wvLoginCallback"});a.wvLoginCallback=function(b){delete a.wvLoginCallback,d(b.indexOf(":SUCCESS")>-1?"SUCCESS":b.indexOf(":CANCEL")>-1?"CANCEL":"FAILURE")},l(e)}function o(a,b,c){if("function"==typeof b?(c=b,b=null):"string"==typeof b&&(b={redirectUrl:b}),b=b||{},c&&A)n(a,b,c);else if(c&&!z&&"login"===a)m(a,b,c);else{var d=k(a,{tpl_redirect_url:b.redirectUrl||location.href});l(d,b.replace)}}function p(a,b,c){var d;return u&&(d={},d.promise=new u(function(a,b){d.resolve=a,d.reject=b})),o(a,b,function(a){c&&c(a),"SUCCESS"===a?d&&d.resolve(a):d&&d.reject(a)}),d?d.promise:void 0}function q(a){o("login",a)}function r(a){return p("login",a)}function s(a){o("logout",a)}function t(a){return p("logout",a)}var u=a.Promise,v=a.document,w=a.navigator.userAgent,x=location.hostname,y=(a.location.search,w.match(/WindVane[\/\s]([\d\.\_]+)/)),z=w.match(/AliApp\(([^\/]+)\/([\d\.\_]+)\)/i),A=!!(z&&"TB"===z[1]&&y&&parseFloat(y[1])>5.2),B=["taobao.net","taobao.com"],C=new RegExp("([^.]*?)\\.?((?:"+B.join(")|(?:").replace(/\./g,"\\.")+"))","i"),D=x.match(C)||[],E=function(){var a=D[2]||"taobao.com";return a.match(/\.?taobao\.net$/)?"taobao.net":"taobao.com"}(),F=function(){var a=E,b=D[1]||"m";return"taobao.net"===a&&(b="waptest"),b}(),G="login";b.login=b.login||{};var H={loginName:"login.htm",logoutName:"logout.htm",subDomain:F};b.login.config=H,b.login.isLogin=g,b.login.isLoginAsync=h,b.login.getUserNick=i,b.login.getUserNickAsync=j,b.login.generateUrl=k,b.login.goLogin=q,b.login.goLoginAsync=r,b.login.goLogout=s,b.login.goLogoutAsync=t}(window,window.lib||(window.lib={}));;module.exports = window.lib.login;

/***/ },
/* 137 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(){var a={},b=new m(function(b,c){a.resolve=b,a.reject=c});return a.promise=b,a}function d(a,b){for(var c in b)void 0===a[c]&&(a[c]=b[c]);return a}function e(a){var b=document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]||document.firstElementChild||document;b.appendChild(a)}function f(a){var b=[];for(var c in a)a[c]&&b.push(c+"="+encodeURIComponent(a[c]));return b.join("&")}function g(a){function b(a,b){return a<<b|a>>>32-b}function c(a,b){var c,d,e,f,g;return e=2147483648&a,f=2147483648&b,c=1073741824&a,d=1073741824&b,g=(1073741823&a)+(1073741823&b),c&d?2147483648^g^e^f:c|d?1073741824&g?3221225472^g^e^f:1073741824^g^e^f:g^e^f}function d(a,b,c){return a&b|~a&c}function e(a,b,c){return a&c|b&~c}function f(a,b,c){return a^b^c}function g(a,b,c){return b^(a|~c)}function h(a,e,f,g,h,i,j){return a=c(a,c(c(d(e,f,g),h),j)),c(b(a,i),e)}function i(a,d,f,g,h,i,j){return a=c(a,c(c(e(d,f,g),h),j)),c(b(a,i),d)}function j(a,d,e,g,h,i,j){return a=c(a,c(c(f(d,e,g),h),j)),c(b(a,i),d)}function k(a,d,e,f,h,i,j){return a=c(a,c(c(g(d,e,f),h),j)),c(b(a,i),d)}function l(a){for(var b,c=a.length,d=c+8,e=(d-d%64)/64,f=16*(e+1),g=new Array(f-1),h=0,i=0;c>i;)b=(i-i%4)/4,h=i%4*8,g[b]=g[b]|a.charCodeAt(i)<<h,i++;return b=(i-i%4)/4,h=i%4*8,g[b]=g[b]|128<<h,g[f-2]=c<<3,g[f-1]=c>>>29,g}function m(a){var b,c,d="",e="";for(c=0;3>=c;c++)b=a>>>8*c&255,e="0"+b.toString(16),d+=e.substr(e.length-2,2);return d}function n(a){a=a.replace(/\r\n/g,"\n");for(var b="",c=0;c<a.length;c++){var d=a.charCodeAt(c);128>d?b+=String.fromCharCode(d):d>127&&2048>d?(b+=String.fromCharCode(d>>6|192),b+=String.fromCharCode(63&d|128)):(b+=String.fromCharCode(d>>12|224),b+=String.fromCharCode(d>>6&63|128),b+=String.fromCharCode(63&d|128))}return b}var o,p,q,r,s,t,u,v,w,x=[],y=7,z=12,A=17,B=22,C=5,D=9,E=14,F=20,G=4,H=11,I=16,J=23,K=6,L=10,M=15,N=21;for(a=n(a),x=l(a),t=1732584193,u=4023233417,v=2562383102,w=271733878,o=0;o<x.length;o+=16)p=t,q=u,r=v,s=w,t=h(t,u,v,w,x[o+0],y,3614090360),w=h(w,t,u,v,x[o+1],z,3905402710),v=h(v,w,t,u,x[o+2],A,606105819),u=h(u,v,w,t,x[o+3],B,3250441966),t=h(t,u,v,w,x[o+4],y,4118548399),w=h(w,t,u,v,x[o+5],z,1200080426),v=h(v,w,t,u,x[o+6],A,2821735955),u=h(u,v,w,t,x[o+7],B,4249261313),t=h(t,u,v,w,x[o+8],y,1770035416),w=h(w,t,u,v,x[o+9],z,2336552879),v=h(v,w,t,u,x[o+10],A,4294925233),u=h(u,v,w,t,x[o+11],B,2304563134),t=h(t,u,v,w,x[o+12],y,1804603682),w=h(w,t,u,v,x[o+13],z,4254626195),v=h(v,w,t,u,x[o+14],A,2792965006),u=h(u,v,w,t,x[o+15],B,1236535329),t=i(t,u,v,w,x[o+1],C,4129170786),w=i(w,t,u,v,x[o+6],D,3225465664),v=i(v,w,t,u,x[o+11],E,643717713),u=i(u,v,w,t,x[o+0],F,3921069994),t=i(t,u,v,w,x[o+5],C,3593408605),w=i(w,t,u,v,x[o+10],D,38016083),v=i(v,w,t,u,x[o+15],E,3634488961),u=i(u,v,w,t,x[o+4],F,3889429448),t=i(t,u,v,w,x[o+9],C,568446438),w=i(w,t,u,v,x[o+14],D,3275163606),v=i(v,w,t,u,x[o+3],E,4107603335),u=i(u,v,w,t,x[o+8],F,1163531501),t=i(t,u,v,w,x[o+13],C,2850285829),w=i(w,t,u,v,x[o+2],D,4243563512),v=i(v,w,t,u,x[o+7],E,1735328473),u=i(u,v,w,t,x[o+12],F,2368359562),t=j(t,u,v,w,x[o+5],G,4294588738),w=j(w,t,u,v,x[o+8],H,2272392833),v=j(v,w,t,u,x[o+11],I,1839030562),u=j(u,v,w,t,x[o+14],J,4259657740),t=j(t,u,v,w,x[o+1],G,2763975236),w=j(w,t,u,v,x[o+4],H,1272893353),v=j(v,w,t,u,x[o+7],I,4139469664),u=j(u,v,w,t,x[o+10],J,3200236656),t=j(t,u,v,w,x[o+13],G,681279174),w=j(w,t,u,v,x[o+0],H,3936430074),v=j(v,w,t,u,x[o+3],I,3572445317),u=j(u,v,w,t,x[o+6],J,76029189),t=j(t,u,v,w,x[o+9],G,3654602809),w=j(w,t,u,v,x[o+12],H,3873151461),v=j(v,w,t,u,x[o+15],I,530742520),u=j(u,v,w,t,x[o+2],J,3299628645),t=k(t,u,v,w,x[o+0],K,4096336452),w=k(w,t,u,v,x[o+7],L,1126891415),v=k(v,w,t,u,x[o+14],M,2878612391),u=k(u,v,w,t,x[o+5],N,4237533241),t=k(t,u,v,w,x[o+12],K,1700485571),w=k(w,t,u,v,x[o+3],L,2399980690),v=k(v,w,t,u,x[o+10],M,4293915773),u=k(u,v,w,t,x[o+1],N,2240044497),t=k(t,u,v,w,x[o+8],K,1873313359),w=k(w,t,u,v,x[o+15],L,4264355552),v=k(v,w,t,u,x[o+6],M,2734768916),u=k(u,v,w,t,x[o+13],N,1309151649),t=k(t,u,v,w,x[o+4],K,4149444226),w=k(w,t,u,v,x[o+11],L,3174756917),v=k(v,w,t,u,x[o+2],M,718787259),u=k(u,v,w,t,x[o+9],N,3951481745),t=c(t,p),u=c(u,q),v=c(v,r),w=c(w,s);var O=m(t)+m(u)+m(v)+m(w);return O.toLowerCase()}function h(a){var b=new RegExp("(?:^|;\\s*)"+a+"\\=([^;]+)(?:;\\s*|$)").exec(document.cookie);return b?b[1]:void 0}function i(a,b,c){var d=new Date;d.setTime(d.getTime()-864e5);var e="/";doc.cookie=a+"=;path="+e+";domain=."+b+";expires="+d.toGMTString(),doc.cookie=a+"=;path="+e+";domain=."+c+"."+b+";expires="+d.toGMTString()}function j(){var b=a.location.hostname,c=["taobao.net","taobao.com","tmall.com","tmall.hk","etao.com"],d=new RegExp("([^.]*?)\\.?((?:"+c.join(")|(?:").replace(/\./g,"\\.")+"))","i"),e=b.match(d)||[],f=e[2]||"taobao.com",g=e[1]||"m";"taobao.net"!==f||"x"!==g&&"waptest"!==g&&"daily"!==g?"taobao.net"===f&&"demo"===g?g="demo":"waptest"!==g&&"wapa"!==g&&"m"!==g&&(g="m"):g="waptest";var h="etao.com"===f?"apie":"api";r.mainDomain=f,r.subDomain=g,r.prefix=h}function k(){var b=a.navigator.userAgent,c=b.match(/WindVane[\/\s]([\d\.\_]+)/);c&&(r.WindVaneVersion=c[1]);var d=b.match(/AliApp\(([^\/]+)\/([\d\.\_]+)\)/i);d&&(r.AliAppName=d[1],r.AliAppVersion=d[2])}function l(a){this.id=++u,this.params=d(a||{},{v:"*",data:{},type:"get",dataType:"jsonp"}),this.params.type=this.params.type.toLowerCase(),"object"==typeof this.params.data&&(this.params.data=JSON.stringify(this.params.data)),this.middlewares=s.slice(0)}var m=a.Promise;if(!m){var n="当前浏览器不支持Promise，请参考文档（http://gitlab.alibaba-inc.com/mtb/lib-es6polyfill/tree/master）中的解决方案";return b.mtop={ERROR:n},void console.error(n)}var o=m.resolve(),p=a.localStorage;if(p)try{p.setItem("@private","false")}catch(q){p=!1}var r={useAlipayJSBridge:!1},s=[],t={ERROR:-1,SUCCESS:0,TOKEN_EXPIRED:1,SESSION_EXPIRED:2};j(),k();var u=0;l.prototype.use=function(a){if(!a)throw new Error("middleware is undefined");return this.middlewares.push(a),this},l.prototype.__processRequestMethod=function(a){var b=this.params,c=this.options;"get"===b.type&&"jsonp"===b.dataType?c.getJSONP=!0:"get"===b.type&&"json"===b.dataType?c.getJSON=!0:"post"===b.type&&(c.postJSON=!0),a()},l.prototype.__processRequestType=function(a){var c=this,d=this.options;if(r.H5Request===!0&&(d.H5Request=!0),r.WindVaneRequest===!0&&(d.WindVaneRequest=!0),d.H5Request===!1&&d.WindVaneRequest===!0){if(!b.windvane||parseFloat(d.WindVaneVersion)<5.4)throw new Error("WINDVANE_NOT_FOUND::缺少WindVane环境")}else d.H5Request===!0?d.WindVaneRequest=!1:"undefined"==typeof d.WindVaneRequest&&"undefined"==typeof d.H5Request&&(b.windvane&&parseFloat(d.WindVaneVersion)>=5.4?d.WindVaneRequest=!0:d.H5Request=!0);a().then(function(){var a=d.retJson.ret;return a instanceof Array&&(a=a.join(",")),d.WindVaneRequest===!0&&(!a||a.indexOf("HY_FAILED")>-1||a.indexOf("HY_NO_HANDLER")>-1||a.indexOf("HY_CLOSED")>-1||a.indexOf("HY_EXCEPTION")>-1||a.indexOf("HY_NO_PERMISSION")>-1)?(r.H5Request=!0,c.__sequence([c.__processRequestType,c.__processToken,c.__processRequestUrl,c.__processUnitPrefix,c.middlewares,c.__processRequest])):void 0})};var v="_m_h5_tk",w="_m_h5_tk_enc";l.prototype.__getTokenFromAlipay=function(){var b=c(),d=this.options,e=(a.navigator.userAgent,!!location.protocol.match(/^https?\:$/)),f="AP"===d.AliAppName&&parseFloat(d.AliAppVersion)>=8.2;return d.useAlipayJSBridge===!0&&!e&&f&&a.AlipayJSBridge&&a.AlipayJSBridge.call?a.AlipayJSBridge.call("getMtopToken",function(a){a&&a.token&&(d.token=a.token),b.resolve()},function(){b.resolve()}):b.resolve(),b.promise},l.prototype.__getTokenFromCookie=function(){var a=this.options;return a.token=a.token||h(v),a.token&&(a.token=a.token.split("_")[0]),m.resolve()},l.prototype.__processToken=function(a){{var b=this,c=this.options;this.params}return c.token&&delete c.token,c.WindVaneRequest!==!0?o.then(function(){return b.__getTokenFromAlipay()}).then(function(){return b.__getTokenFromCookie()}).then(a).then(function(){var a=c.retJson,d=a.ret;if(d instanceof Array&&(d=d.join(",")),d.indexOf("TOKEN_EMPTY")>-1||d.indexOf("TOKEN_EXOIRED")>-1){if(c.maxRetryTimes=c.maxRetryTimes||5,c.failTimes=c.failTimes||0,c.H5Request&&++c.failTimes<c.maxRetryTimes)return b.__sequence([b.__processToken,b.__processRequestUrl,b.__processUnitPrefix,b.middlewares,b.__processRequest]);maxRetryTimes>0&&(i(v,c.mainDomain,c.subDomain),i(w,c.mainDomain,c.subDomain)),a.retType=t.TOKEN_EXPIRED}}):void a()},l.prototype.__processRequestUrl=function(a){var b=this.params,c=this.options;if(c.H5Request===!0){var d="//"+(c.prefix?c.prefix+".":"")+(c.subDomain?c.subDomain+".":"")+c.mainDomain+"/h5/"+b.api.toLowerCase()+"/"+b.v.toLowerCase()+"/",e=b.appKey||("waptest"===c.subDomain?"4272":"12574478"),f=(new Date).getTime(),h=g(c.token+"&"+f+"&"+e+"&"+b.data),i={appKey:e,t:f,sign:h},j={data:b.data,ua:b.ua};Object.keys(b).forEach(function(a){"undefined"==typeof i[a]&&"undefined"==typeof j[a]&&(i[a]=b[a])}),c.getJSONP?i.type="jsonp":(c.getJSON||c.postJSON)&&(i.type="originaljson"),c.querystring=i,c.postdata=j,c.path=d}a()},l.prototype.__processUnitPrefix=function(b){var c=this.params,d=this.options;if(p&&d.H5Request===!0){var f=c.api,g=!1,i=h("_m_user_unitinfo_"),j=p.getItem("unitinfo");i&&i.split("|")[0].indexOf("center")<0&&j&&j.indexOf(f.toLowerCase())>=0&&(g=i.split("|")[1]),g&&d.path&&(d.path=d.path.replace(/^\/\//,"//"+g+".")),b().then(function(){if(p){var b=h("_m_unitapi_v_"),c=p.getItem("unitinfo");if(b){var f=c?JSON.parse(c):{};if(!c||b!==f.version){var g=!1,i="//h5."+d.subDomain+".taobao.com/js/mtop/unit/"+b+"/unitApi.js",j=document.createElement("script");j.src=i;var k=function(){g||(g=!0,j.onload=j.onerror=null,j.parentNode&&j.parentNode.removeChild(j))};j.onerror=function(){k()},a.jsonp_unitapi||(a.jsonp_unitapi=function(a){k(),p.setItem("unitinfo",JSON.stringify(a))}),e(j)}}}})}else b()};var x=0;l.prototype.__requestJSONP=function(a){function b(a){if(k&&clearTimeout(k),l.parentNode&&l.parentNode.removeChild(l),"TIMEOUT"===a)window[j]=function(){window[j]=void 0;try{delete window[j]}catch(a){}};else{window[j]=void 0;try{delete window[j]}catch(b){}}}var d=c(),g=this.params,h=this.options,i=g.timeout||2e4,j="mtopjsonp"+ ++x,k=setTimeout(function(){b("TIMEOUT"),a("TIMEOUT::接口超时")},i);h.querystring.callback=j;var l=document.createElement("script");return l.src=h.path+"?"+f(h.querystring)+"&"+f(h.postdata),l.async=!0,l.onerror=function(){b("ABORT"),a("ABORT::接口异常退出")},window[j]=function(){h.results=Array.prototype.slice.call(arguments),b(),d.resolve()},e(l),d.promise},l.prototype.__requestJSON=function(b){function d(a){k&&clearTimeout(k),"TIMEOUT"===a&&i.abort()}var e=c(),g=this.params,h=this.options,i=new a.XMLHttpRequest,j=g.timeout||2e4,k=setTimeout(function(){d("TIMEOUT"),b("TIMEOUT::接口超时")},j);i.onreadystatechange=function(){if(4==i.readyState){var a,c,f=i.status;if(f>=200&&300>f||304==f){d(),a=i.responseText,c=i.getAllResponseHeaders()||"";try{a=/^\s*$/.test(a)?{}:JSON.parse(a),a.responseHeaders=c,h.results=[a],e.resolve()}catch(g){b("PARSE_JSON_ERROR::解析JSON失败")}}else d("ABORT"),b("ABORT::接口异常退出")}};var l,m,n=h.path+"?"+f(h.querystring);if(h.getJSON?(l="GET",n+="&"+f(h.postdata)):h.postJSON&&(l="POST",m=f(h.postdata)),i.open(l,n,!0),i.withCredentials=!0,i.setRequestHeader("Accept","application/json"),i.setRequestHeader("Content-type","application/x-www-form-urlencoded"),g.headers)for(var o in g.headers)i.setRequestHeader(o,g.headers[o]);return i.send(m),e.promise},l.prototype.__requestWindVane=function(a){function d(a){j.results=[a],h.resolve()}var e,f,g,h=c(),i=this.params,j=this.options,k=i.data,l=i.api,m=i.v,n=j.postJSON?1:0,o=j.getJSON||j.postJSON?"orginaljson":"",p="https"===location.protocol?1:0,q=i.isSec||0,r=i.sessionOption||"AutoLoginOnly";if("undefined"==typeof i.ecode)throw new Error("UNEXCEPT_PARAM_ECODE::缺少ecode参数");return e=parseInt(i.ecode),g="undefined"!=typeof i.timer?parseInt(i.timer):"undefined"!=typeof i.timeout?parseInt(i.timeout):2e4,f=2*g,b.windvane.call("MtopWVPlugin","send",{api:l,v:m,post:String(n),type:o,isHttps:String(p),ecode:String(e),isSec:String(q),param:JSON.parse(k),timer:g,sessionOption:r},d,d,f),h.promise},l.prototype.__processRequest=function(a,b){var c=this;return o.then(function(){var a=c.options;if(a.H5Request&&a.getJSONP)return c.__requestJSONP(b);if(a.H5Request&&(a.getJSON||a.postJSON))return c.__requestJSON(b);if(a.WindVaneRequest)return c.__requestWindVane(b);throw new Error("UNEXCEPT_REQUEST::错误的请求类型")}).then(a).then(function(){var a=c.options,b=(c.params,a.results[0]),d=b&&b.ret||[];b.ret=d,d instanceof Array&&(d=d.join(",")),d.indexOf("SUCCESS")>-1?b.retType=t.SUCCESS:b.retType=t.ERROR,a.retJson=b})},l.prototype.__sequence=function(a){function b(a){if(a instanceof Array)a.forEach(b);else{var g,h=c(),i=c();e.push(function(){return h=c(),g=a.call(d,function(a){return h.resolve(a),i.promise},function(a){return h.reject(a),i.promise}),g&&(g=g["catch"](function(a){h.reject(a)})),h.promise}),f.push(function(a){return i.resolve(a),g})}}var d=this,e=[],f=[];a.forEach(b);for(var g,h=o;g=e.shift();)h=h.then(g);for(;g=f.pop();)h=h.then(g);return h};var y=function(a){a()},z=function(a){a()};l.prototype.request=function(a){var b=this;this.options=d(a||{},r);var c=m.resolve([y,z]).then(function(a){var c=a[0],d=a[1];return b.__sequence([c,b.__processRequestMethod,b.__processRequestType,b.__processToken,b.__processRequestUrl,b.__processUnitPrefix,b.middlewares,b.__processRequest,d])}).then(function(){var a=b.options.retJson;return a.retType!==t.SUCCESS?m.reject(a):b.options.successCallback?void b.options.successCallback(a):m.resolve(a)})["catch"](function(a){var c;return a instanceof Error?(console.error(a.stack),c={ret:[a.message],stack:[a.stack],retJson:t.ERROR}):c="string"==typeof a?{ret:[a],retJson:t.ERROR}:void 0!==a?a:b.options.retJson,b.options.failureCallback?void b.options.failureCallback(c):m.reject(c)});return y=function(a){c.then(a)["catch"](a)},c},b.mtop=function(a){return new l(a)},b.mtop.request=function(a,b,c){var d={H5Request:a.H5Request,WindVaneRequest:a.WindVaneRequest,LoginRequest:a.LoginRequest,AntiCreep:a.AntiCreep,AntiFlood:a.AntiFlood,successCallback:b,failureCallback:c||b};return new l(a).request(d)},b.mtop.H5Request=function(a,b,c){var d={H5Request:!0,successCallback:b,failureCallback:c||b};return new l(a).request(d)},b.mtop.middlewares=s,b.mtop.config=r,b.mtop.RESPONSE_TYPE=t,b.mtop.CLASS=l}(window,window.lib||(window.lib={})),function(a,b){function c(a){return a.preventDefault(),!1}function d(b,d){var e=this,f=a.dpr||1,g=document.createElement("div"),h=document.documentElement.getBoundingClientRect(),i=Math.max(h.width,window.innerWidth)/f,j=Math.max(h.height,window.innerHeight)/f;g.style.cssText=["-webkit-transform:scale("+f+") translateZ(0)","-ms-transform:scale("+f+") translateZ(0)","transform:scale("+f+") translateZ(0)","-webkit-transform-origin:0 0","-ms-transform-origin:0 0","transform-origin:0 0","width:"+i+"px","height:"+j+"px","z-index:999999","position:absolute","left:0","top:0px","background:#FFF","display:none"].join(";");var k=document.createElement("div");k.style.cssText=["width:100%","height:52px","background:#EEE","line-height:52px","text-align:left","box-sizing:border-box","padding-left:20px","position:absolute","left:0","top:0","font-size:16px","font-weight:bold","color:#333"].join(";"),k.innerText=b;var l=document.createElement("a");l.style.cssText=["display:block","position:absolute","right:0","top:0","height:52px","line-height:52px","padding:0 20px","color:#999"].join(";"),l.innerText="关闭";var m=document.createElement("iframe");m.style.cssText=["width:100%","height:100%","border:0","overflow:hidden"].join(";"),k.appendChild(l),g.appendChild(k),g.appendChild(m),document.body.appendChild(g),m.src=d,l.addEventListener("click",function(){e.hide();var a=document.createEvent("HTMLEvents");a.initEvent("close",!1,!1),g.dispatchEvent(a)},!1),this.addEventListener=function(){g.addEventListener.apply(g,arguments)},this.removeEventListener=function(){g.removeEventListener.apply(g,arguments)},this.show=function(){document.addEventListener("touchmove",c,!1),g.style.display="block",window.scrollTo(0,0)},this.hide=function(){document.removeEventListener("touchmove",c),window.scrollTo(0,-h.top),g.parentNode&&g.parentNode.removeChild(g)}}function e(a){{var c=this,d=this.options;this.params}return a().then(function(){var a=d.retJson,e=a.ret;if(e instanceof Array&&(e=e.join(",")),(e.indexOf("SESSION_EXPIRED")>-1||e.indexOf("SID_INVALID")>-1||e.indexOf("AUTH_REJECT")>-1||e.indexOf("NEED_LOGIN")>-1)&&(a.retType=k.SESSION_EXPIRED,!d.WindVaneRequest&&(j.LoginRequest===!0||d.LoginRequest===!0))){if(!b.login)throw new Error("LOGIN_NOT_FOUND::缺少lib.login");return b.login.goLoginAsync().then(function(a){return c.__sequence([c.__processToken,c.__processRequestUrl,c.__processUnitPrefix,c.middlewares,c.__processRequest])})["catch"](function(a){throw new Error("CANCEL"===a?"LOGIN_CANCEL::用户取消登录":"LOGIN_FAILURE::用户登录失败")})}})}function f(a){{var b=this.options;this.params}return b.AliAppName||b.AliAppVersion||j.AntiFlood!==!0&&b.AntiFlood!==!0?void a():a().then(function(){var a=b.retJson,c=a.ret;c instanceof Array&&(c=c.join(",")),c.indexOf("FAIL_SYS_USER_VALIDATE")>-1&&a.data.url&&(location.href=a.data.url)})}function g(b){var c=this,e=this.options,f=this.params;return e.AliAppName||e.AliAppVersion||j.AntiCreep!==!0&&e.AntiCreep!==!0?void b():b().then(function(){var b=e.retJson,g=b.ret;return g instanceof Array&&(g=g.join(",")),g.indexOf("RGV587_ERROR::SM")>-1&&b.data.url?new h(function(e,g){function h(){k.removeEventListener("close",h),a.removeEventListener("message",i),g("USER_INPUT_CANCEL::用户取消输入")}function i(b){k.removeEventListener("close",h),a.removeEventListener("message",i),k.hide();var d;try{d=JSON.parse(b.data)||{}}catch(j){}if(d&&"child"===d.type){var l;try{l=JSON.parse(decodeURIComponent(d.content)),"string"==typeof l&&(l=JSON.parse(l));for(var m in l)f[m]=l[m];c.__sequence([c.__processToken,c.__processRequestUrl,c.__processUnitPrefix,c.middlewares,c.__processRequest]).then(e)}catch(j){g("USER_INPUT_FAILURE::用户输入失败")}}else e()}var j=b.data.url,k=new d("",j);k.addEventListener("close",i,!1),a.addEventListener("message",i,!1),k.show()}):void 0})}var h=a.Promise,i=b.mtop.CLASS,j=b.mtop.config,k=b.mtop.RESPONSE_TYPE;b.mtop.middlewares.push(e),b.mtop.loginRequest=function(a,b,c){var d={LoginRequest:!0,H5Request:!0,successCallback:b,failureCallback:c||b};return new i(a).request(d)},b.mtop.antiFloodRequest=function(a,b,c){var d={AntiFlood:!0,successCallback:b,failureCallback:c||b};return new i(a).request(d)},b.mtop.middlewares.push(f),b.mtop.antiCreepRequest=function(a,b,c){var d={AntiCreep:!0,successCallback:b,failureCallback:c||b};return new i(a).request(d)},b.mtop.middlewares.push(g)}(window,window.lib||(window.lib={}));;module.exports = window.lib.mtop;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	// require('envd')
	__webpack_require__(133)
	__webpack_require__(136)
	__webpack_require__(137)
	
	var user = {
	  /**
	   * get current user info.
	   *   response format: {'isLogin':'true','userId':'userid','nick':'jb'｝
	   * @param  {string} calllbackId
	   */
	  getUserInfo: function (callbackId) {
	    var self = this
	    var performCb = function (isLogin, info) {
	      self.sender.performCallback(callbackId, {
	        isLogin: isLogin + '',
	        userId: info.userNumId,
	        nick: info.nick
	      })
	    }
	    lib.login.isLoginAsync(function (res, info) {
	      var data = info ? info.data || {} : {}
	      if (res) {
	        performCb(true, data)
	      } else {
	        performCb(false, data)
	      }
	    })
	
	  },
	
	  /**
	   * callback返回参数：status：string；info：jsonMap
	   * 参数值：登录状态Success、failure 用户信息｛'userid':'userId','nick':'jb'｝
	   * @param  {string} callback
	   */
	  login: function (callbackId) {
	    var self = this
	    lib.login.goLoginAsync().then(function (status) {
	      var performCb = function (status, info) {
	        self.sender.performCallback(callbackId, {
	          status: status,
	          info: info
	        })
	      }
	      if ((status + '').match(/success/i)) {
	        lib.login.isLoginAsync(function (res, info) {
	          var data = info ? info.data || {} : info
	          if (res) {
	            performCb('success', { userid: data.userNumId, nick: data.nick })
	          } else {
	            performCb('failure')
	          }
	        })
	      } else {
	        performCb('failure')
	      }
	    }).catch(function (err) {
	      console && console.error(err)
	    })
	  },
	
	  /**
	   * logout (response: { status：string })
	   * 参数值success、failure
	   */
	  logout: function (callbackId) {
	    var self = this
	    lib.login.goLogoutAsync(function (status) {
	      if ((status + '').match(/success/i)) {
	        status = 'success'
	      } else {
	        status = 'failure'
	      }
	      self.sender.performCallback(callbackId, {
	        status: status
	      })
	    })
	  }
	
	}
	
	user._meta = {
	  user: [{
	    name: 'getUserInfo',
	    args: ['function']
	  }, {
	    name: 'login',
	    args: ['function']
	  }, {
	    name: 'logout',
	    args: ['function']
	  }]
	}
	
	module.exports = user

/***/ },
/* 139 */
/***/ function(module, exports) {

	'use strict'
	
	// ref: 'http://gitlab.alibaba-inc.com/aplus/aplus_technical_manual'
	// + '/raw/master/_book/aplus/cdn.html'
	var userTrack = {
	  /**
	   * commit 埋点
	   * @param  {string} type 埋点类型: enter, click, expose, updateNextProp
	   * @param  {string} name 页面名称
	   * @param  {string} ctrlName 控件名称: 以ut定义的类型为标准 Button Text Image
	   * @param  {obj} param 页面参数(监控平台显示)
	   */
	  commit: function (type, pageName, ctrlName, param) {
	    // 处理 params
	    var gokey = ''
	    if (Object.prototype.toString.call(param).slice(8, -1) === 'Object') {
	      gokey = Object.keys(param).reduce(function (result, item, index, array) {
	        var key = item
	        var value = result.param[item]
	        result.result.push(key + '=' + encodeURIComponent(value))
	
	        return result
	      }, { param: param, result: [] })
	      gokey = gokey.result.join('&')
	    }
	
	    // 有可能页面没有 goldlog 方法，需要 try
	    try {
	      // enter 2001
	      if (type === 'enter') {
	        // 如果是 2001 事件，需要判断是否有 waiting 标识，如果没有的话 spm.js 已经发出了 2001，不应该再发
	        var meta = document.querySelector('meta[name="aplus-waiting"]')
	        if (meta) {
	          goldlog.launch(params)
	        }
	      }
	      // 点击埋点
	      // else if (type === 'click') {
	      //  // TODO
	      //  //goldlog.record(appname, "", gokey, "")
	      // }
	      // // 曝光埋点
	      // else if (type === 'expose') {
	      //  // TODO
	      //  //goldlog.record(appname, "", gokey, "")
	      // }
	    }
	    catch (err) {
	    }
	  }
	}
	
	userTrack._meta = {
	  userTrack: [{
	    name: 'commit',
	    args: ['string', 'string', 'string', 'object']
	  }]
	}
	
	module.exports = userTrack

/***/ },
/* 140 */
/***/ function(module, exports) {

	'use strict'
	
	var windvane = {
	
	  /**
	   * @param  {obj} config
	   *         class
	   *         method
	   *         data
	   * @param  {[type]} callbackId [description]
	   * @return {[type]}            [description]
	   */
	  call: function (config, callbackId) {
	
	    var self = this
	
	    var cb = function (resp) {
	
	      self.sender.performCallback(callbackId, resp)
	
	    }
	
	    if (lib.windvane) {
	
	      lib.windvane.call(config.class, config.method, config.data)
	        .then(function (res) {
	          cb(res)
	        }, function (err) {
	          console.log('windvane call error: ', err)
	          cb(err)
	        })
	
	    } else {
	      console.error('lib.windvane not found.')
	    }
	  }
	}
	
	windvane._meta = {
	  windvane: [{
	    name: 'call',
	    args: ['object', 'function']
	  }]
	}
	
	module.exports = windvane


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var Image = __webpack_require__(142)
	var Slider = __webpack_require__(149)
	
	var components = {
	  init: function (Weex) {
	    Weex.registerComponent('image', Image)
	    Weex.registerComponent('slider', Slider)
	  }
	}
	
	module.exports = components

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var weex = __webpack_require__(9)
	var Component = weex.Component
	var LazyLoad = __webpack_require__(143)
	
	__webpack_require__(147)
	
	var DEFAULT_SIZE = 200
	var RESIZE_MODES = ['stretch', 'cover', 'contain']
	var DEFAULT_RESIZE_MODE = 'stretch'
	
	var QUALITIES = {
	  low: [
	    {
	      name: 'data-q-normal',
	      value: 'q50'
	    }, {
	      name: 'data-q-weak',
	      value: 'q50'
	    }
	  ],
	  normal: [
	    {
	      name: 'data-q-normal',
	      value: 'q75'
	    }, {
	      name: 'data-q-weak',
	      value: 'q50'
	    }
	  ],
	  high: [
	    {
	      name: 'data-q-normal',
	      value: 'q90'
	    }, {
	      name: 'data-q-weak',
	      value: 'q75'
	    }
	  ],
	  original: [
	    {
	      name: 'data-q-normal',
	      value: 'original'
	    }, {
	      name: 'data-q-weak',
	      value: 'original'
	    }
	  ]
	}
	var SHAPREN = {
	  sharpen: 's150',
	  unsharpen: 'original'
	}
	
	/**
	 * resize=cover|contain|stretch default:stretch
	 * src=url
	 * quality=normal(q75)|low(q50)|high(q90)|origin default:low
	 * sharpen=unsharpen|sharpen(s150) default:unsharpen
	 */
	function Image (data) {
	  var quality, sharpen, origin
	  var attr = data.attr
	  if (attr) {
	    quality = attr.quality || attr.imageQuality
	    sharpen = attr.sharpen || attr.imageSharpen
	    origin = attr.origin || attr.dataOrigin
	  }
	  this.quality = QUALITIES[quality]
	  this.sharpen = SHAPREN[sharpen]
	  this.origin = origin && origin !== 'false' ? true : false
	  Component.call(this, data)
	}
	
	Image.prototype = Object.create(Component.prototype)
	
	Image.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('weex-img')
	  // if 'quality'/'sharpen' is not specified it will
	  // use default config of lib.img which is set in lazyload.js
	  if (this.quality) {
	    for (var i = 0, l = this.quality.length; i < l; i++) {
	      var attr = this.quality[i]
	      node.setAttribute(attr.name, attr.value)
	    }
	  }
	  if (this.sharpen) {
	    node.setAttribute('data-sharpen', this.sharpen)
	  }
	  node.setAttribute('data-original', this.origin ? 'true' : 'false')
	  return node
	}
	
	Image.prototype.style = weex.utils.extend(
	    Object.create(Component.prototype.style), {
	  width: function (val) {
	    val = parseFloat(val) * this.data.scale
	    if (val < 0 || val !== val) {
	      val = DEFAULT_SIZE
	    }
	    this.node.style.width = val + 'px'
	    var _dpr = window.devicePixelRatio
	    if (window.dpr === 1 && _dpr !== 1) {
	      val = val * _dpr
	    }
	    this.node.setAttribute('data-width', val)
	  },
	
	  height: function (val) {
	    val = parseFloat(val) * this.data.scale
	    if (val < 0 || val !== val) {
	      val = DEFAULT_SIZE
	    }
	    this.node.style.height = val + 'px'
	    var _dpr = window.devicePixelRatio
	    if (window.dpr === 1 && _dpr !== 1) {
	      val = val * _dpr
	    }
	    this.node.setAttribute('data-height', val)
	  }
	})
	
	Image.prototype.attr = {
	  src: function (val) {
	    if (!this.src) {
	      this.src = lib.img.defaultSrc
	      this.node.style.backgroundImage = 'url(' + this.src + ')'
	    }
	    LazyLoad.makeImageLazy(this.node, val)
	  },
	
	  resize: function (val) {
	    if (RESIZE_MODES.indexOf(val) === -1) {
	      val = 'stretch'
	    }
	    this.node.style.backgroundSize = val === 'stretch'
	                                    ? '100% 100%'
	                                    : val
	  }
	}
	
	Image.prototype.clearAttr = function () {
	  this.src = ''
	  this.node.style.backgroundImage = ''
	}
	
	Image.prototype.appendChild = function (data) {
	  // do nothing
	  return
	}
	
	Image.prototype.insertBefore = function (child, before) {
	  // do nothing
	  return
	}
	
	Image.prototype.removeChild = function (child) {
	  // do nothing
	  return
	}
	
	module.exports = Image
	


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	__webpack_require__(144)
	
	var DEFAULT_DESIGN_WIDTH = 750
	
	var lazyloadTimer
	var isConfigSetup = false
	
	var LazyLoad = {
	
	  makeImageLazy: function (image, src) {
	
	    image.removeAttribute('img-src')
	    image.removeAttribute('i-lazy-src')
	    image.style.backgroundImage = ''
	    image.setAttribute('img-src', src)
	    // should replace 'src' with 'img-src'. but for now lib.img.fire is
	    // not working for the situation that the appear event has been
	    // already triggered.
	    this.fire()
	  },
	
	  // TODO: make it a decent impl
	  // because we don't know when all image are appended
	  // just use setTimeout to do delay lazyload
	  //
	  // -- actually everytime we add a element or update styles,
	  // the component manager will call startIfNeed to fire
	  // lazyload once again in the handleAppend function. so there
	  // is no way that any image element can miss it. See source
	  // code in componentMangager.js.
	  startIfNeeded: function (component) {
	    if (component.data.type === 'image') {
	      if (!lazyloadTimer) {
	        lazyloadTimer = setTimeout(function () {
	          lib.img.fire()
	          clearTimeout(lazyloadTimer)
	          lazyloadTimer = null
	        }, 16)
	      }
	    }
	  },
	
	  loadIfNeeded: function (elementScope) {
	    var notPreProcessed = elementScope.querySelectorAll('[img-src]')
	    // image elements which have attribute 'i-lazy-src' were elements
	    // that had been preprocessed by lib-img-core, but not loaded yet, and
	    // must be loaded when 'appear' events were fired. It turns out the
	    // 'appear' event was not fired correctly in the css-translate-transition
	    // situation, so 'i-lazy-src' must be checked and lazyload must be
	    // fired manually.
	    var preProcessed = elementScope.querySelectorAll('[i-lazy-src]')
	    if (notPreProcessed.length > 0 || preProcessed.length > 0) {
	      lib.img.fire()
	    }
	  },
	
	  // fire lazyload.
	  fire: function () {
	    if (!isConfigSetup) {
	      lib.img.setConfig({
	        baseDpr: ({ 750: 2, 1125: 3 })[DEFAULT_DESIGN_WIDTH] || 1,
	        autoSize: true,
	        defaultAttr: {
	          qNormal: 'q90',
	          qWeak: 'q60'
	        }
	      })
	      isConfigSetup = true
	    }
	    lib.img.fire()
	  }
	
	}
	
	module.exports = LazyLoad


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(25)
	__webpack_require__(145)
	
	; (function (win, lib) {
	
	  var adapter = {}
	  var appearInstance
	  var runtimeFlags = {}
	
	  var config = {
	    defaultAttr: {
	      qNormal: 'q50', // 强网质量
	      qWeak: 'q30', // 弱网质量
	      sharpen: 's150', // 锐化参数
	      lazy: true, // 懒加载开关
	      width: 400, // 宽度
	      height: 400, // 高度
	      type: 'square', // 裁剪类型
	      original: false // 仅仅收敛CDN域名, 不添加任何质量控制后缀
	    },
	    // 启用自动尺寸: 若未通过元素attibute指定大小, 则获取坑位大小;
	    // 禁用自动尺寸: 若未通过元素attibute指定大小, 则采用defaultAttr中指定的大小;
	    autoSize: true,
	    dataSrc: 'img-src', // 指定图片地址的attribute名, 兼做lazy-class的作用
	    lazyHeight: 0, // 以此高度提前触发懒加载
	    lazyWidth: 0, // 以此宽度提前触发懒加载
	    baseDpr: 2, // 指定尺寸的基础dpr
	    ignoreGif: true, // 是否忽略gif图，默认区分并且不做任何处理
	    ignorePng: false, // 是否忽略png图片
	    filterDomains: [
	      'a.tbcdn.cn',
	      'assets.alicdn.com',
	      'wwc.taobaocdn.com',
	      'wwc.alicdn.com'
	    ] // 自定义过滤的域名命令，适用于不能收敛的域名url
	  }
	
	
	  function extendStrict(main, sub) {
	    var ret = {}
	    for (var k in main) {
	      if (main.hasOwnProperty(k)) {
	        ret[k] = sub.hasOwnProperty(k) ? sub[k] : main[k]
	      }
	    }
	    return ret
	  }
	
	  function extendSimple(main, sub) {
	    for (var k in sub) {
	      if (sub.hasOwnProperty(k)) {
	        main[k] = sub[k]
	      }
	    }
	    return main
	  }
	
	
	  function detectNetwork() {
	    if (!(navigator.userAgent.match(/WindVane/i) && win.WindVane)) {
	      return
	    }
	    WindVane.call('WVNetwork', 'getNetworkType', {}, function (info) {
	      if (info && info.type) {
	        runtimeFlags.isWiFi = (info.type.toLowerCase() == 'wifi')
	      }
	    }, function () {})
	  }
	
	  function detectLibs() {
	    if (!win.lib || !win.lib.flexible) {
	      console.warn('lib-img: 未检测到 lib-flexible, autoSize 特性可能不能正常工作')
	    } else {
	      runtimeFlags.flexibleSupport = true
	    }
	  }
	
	  function detectWebp() {
	    try {
	      var webP = new Image()
	      webP.src = 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdAS'
	       + 'oCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA'
	      webP.onload = function () {
	        if (webP.height === 2) {
	          runtimeFlags.webpSupport = true
	        }
	      }
	    } catch (e) {
	
	    }
	  }
	
	  function calcAutoSize(item) {
	    var height = item.offsetHeight
	    var width = item.offsetWidth
	
	    if (runtimeFlags.flexibleSupport && win.lib.flexible.dpr == 1) {
	      height = height * win.devicePixelRatio
	      width = width * win.devicePixelRatio
	    }
	    return {
	      width: Math.round(width),
	      height: Math.round(height)
	    }
	  }
	
	  function applySrc(item, processedSrc) {
	    if (!processedSrc) {
	      return
	    }
	    if (item.nodeName.toUpperCase() == 'IMG') {
	      item.setAttribute('src', processedSrc)
	    } else {
	      item.style.backgroundImage = 'url("' + processedSrc + '")'
	    }
	  }
	
	
	  function processSrc(item, originalSrc) {
	    if (!originalSrc) {
	      return
	    }
	    var param = extendStrict(config.defaultAttr, item.dataset)
	    if (typeof param.original != 'boolean') {
	      param.original = (param.original == 'true')
	    }
	    if (config.autoSize && !param.original
	        && !(item.dataset.width && item.dataset.height)) {
	      extendSimple(param, calcAutoSize(item))
	    } else {
	      param.height = Math.round(parseInt(param.height, 10)
	        * window.devicePixelRatio / config.baseDpr)
	      param.width = Math.round(parseInt(param.width, 10)
	        * window.devicePixelRatio / config.baseDpr)
	    }
	
	    if (typeof runtimeFlags.isWiFi === 'undefined') {
	      param.q = param.qNormal
	    } else {
	      param.q = runtimeFlags.isWiFi ? param.qNormal : param.qWeak
	    }
	    param.webpSupport = runtimeFlags.webpSupport ? true : false
	    param.ignoreGif = config.ignoreGif
	    param.ignorePng = config.ignorePng
	    param.filterDomains = config.filterDomains
	
	    return lib.imgcore.getNewUrl(originalSrc, param)
	  }
	
	
	
	  function init() {
	    appearInstance = lib.appear.init({
	      cls: 'imgtmp', // 可选，需要遍历的元素
	      once: true, // 可选，是否只触发一次
	      x: config.lazyWidth, // 可选，容器右边距离x以内的元素加载，默认为0
	      y: config.lazyHeight, // 可选，容器底部距离y以内的元素加载，默认为0
	      onAppear: function (evt) {
	        var item = this
	        applySrc(item, processSrc(item, item.getAttribute('i-lazy-src')))
	        item.removeAttribute('i-lazy-src')
	      }
	    })
	    if (runtimeFlags.isWiFi
	        && navigator.userAgent.match(/(iPhone|iPad|iPod)/)) {
	      config.defaultAttr.lazy = false
	    }
	  }
	
	
	  adapter.logConfig = function () {
	    console.log('lib-img Config\n',
	      config,
	      '\nlib-img Runtime\n',
	      runtimeFlags)
	  }
	
	  adapter.setConfig = function (newCfg) {
	    if (newCfg.defaultAttr) {
	      newCfg.defaultAttr = extendStrict(config.defaultAttr, newCfg.defaultAttr)
	    }
	    if (newCfg.filterDomains) {
	      newCfg.filterDomains = newCfg.filterDomains.concat(config.filterDomains)
	    }
	    config = extendStrict(config, newCfg)
	  }
	
	  adapter.fire = function () {
	
	    if (!appearInstance) {
	      init()
	    }
	
	    var label = 'i_' + Date.now() % 100000
	    var domList = document.querySelectorAll('[' + config.dataSrc + ']')
	
	    ; [].forEach.call(domList, function (item) {
	      if (item.dataset.lazy == 'false'
	        || !config.defaultAttr.lazy
	        && item.dataset.lazy != 'true') {
	        applySrc(item, processSrc(item, item.getAttribute(config.dataSrc)))
	      } else {
	        item.classList.add(label)
	        item.setAttribute('i-lazy-src', item.getAttribute(config.dataSrc))
	      }
	      item.removeAttribute(config.dataSrc)
	    })
	
	    appearInstance.bind('.' + label)
	    appearInstance.fire()
	  }
	
	  adapter.defaultSrc = 'data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAA'
	    + 'ABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=='
	
	  lib.img = adapter
	  exports.module = lib.img
	  detectWebp()
	  document.addEventListener('DOMContentLoaded', function () {
	    detectNetwork()
	    detectLibs()
	  })
	
	})(window, window['lib'] || (window['lib'] = {}))


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"undefined"==typeof window&&(window={ctrl:{},lib:{}}),!window.ctrl&&(window.ctrl={}),!window.lib&&(window.lib={}),__webpack_require__(146),function(){function t(t,e){for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);return t}function e(t){var e,i=t.width,r=t.height,a=t.type,n=t.dpr||2;a=a||o;var s=d.square;if(!(i+"").match(/^\d+$/)||!(r+"").match(/^\d+$/))throw new Error("height or width is not number");switch(e=a==c?r:i>=r?i:r,a){case h:s=d.widths;break;case c:s=d.heights;break;case p:s=d.xzs}var l=s[s.length-1],w=s[0],f=0,u=g.baseDpr;if(e=parseInt(n*e/u),e>=l)return l;if(w>=e)return w;for(var m=s.length;m>=0;m--)if(s[m]<=e){s[m]==e?f=e:m<s.length-1&&(f=s[m+1]);break}return f}function i(t){var i="",r="",a=g.q,n=g.sharpen,d=(g.defaultSize,o),s=t.width||g.width,l=t.height||g.height;switch(t&&t.type&&t.type.match(new RegExp("^("+[o,h,c,p].join("|")+")$"))&&(d=t.type),i=e({width:s,height:l,type:d}),d){case o:i=i+"x"+i;break;case h:i+="x10000";break;case c:i="10000x"+i;break;case p:i=i+"x"+i+"xz"}return r="_"+i,"original"===a&&(a=""),"original"===n&&(n=""),r+=a+n+".jpg"}function r(r,o){var o=o||{};if(t(g,o),!r||"string"!=typeof r)return"";g.defaultSize=g.defaultSize||e({height:o.height,width:o.width,dpr:o.dpr});var h=g.defaultSize+"x"+g.defaultSize,c=g.q,p="_"+h+c+g.sharpen+".jpg";try{var s=new lib.httpurl(r)}catch(l){return console.log("[error]wrong img url:",r),r}var w=s.host,f=s.pathname;if(s.protocol="",d.filterDomains=d.filterDomains.concat(g.filterDomains),-1!=d.filterDomains.indexOf(w))return/alicdn/.test(w)||(s.protocol="http:"),s.toString();var u=w.match(/(.+\.(?:alicdn|taobaocdn|taobao|mmcdn)\.com)/);if(u&&u[0]!=a&&(s.host=a),o&&o.original)return s.toString();var m=f.match(n),b=f.match(/-(\d+)-(\d+)\.(?:jpg|png|gif)/);if(b){var x,v;x=parseInt(b[1])<parseInt(g.defaultSize)?g.defaultSize:b[1]>760?760:b[1],v=e({height:x,width:x,dpr:o.dpr}),p="_"+v+"x"+v+c+g.sharpen+".jpg"}return o&&"string"==typeof o?p=i({size:o}):o&&"object"==typeof o&&Object.keys(o).length>0&&(p=i(o)),/\.png/.test(f)&&(p=p.replace(/(q\d+)(s\d+)/,"")),/\.gif/.test(f)&&o.ignoreGif?s.toString():/\.png/.test(f)&&o.ignorePng?s.toString():(o.webpSupport&&(p+="_.webp"),m?m[1]||m[2]||m[3]||m[4]?s.pathname=f.replace(n,p):m[0].match(/_\.(jpg|png|gif|jpef)/)&&(s.pathname+=p):f.match(/_\.webp$/g)?s.pathname=f.replace(/_\.webp$/g,p):s.pathname=f+p,s.toString())}lib||(lib={});var a="gw.alicdn.com",n=/_(\d+x\d+|cy\d+i\d+|sum|m|b)?(xz|xc)?(q\d+)?(s\d+)?(\.jpg)?(_\.webp)?$/i,o="square",h="widthFixed",c="heightFixed",p="xz",d={};d.widths=[110,150,170,220,240,290,450,570,580,620,790],d.heights=[170,220,340,500],d.xzs=[72,80,88,90,100,110,120,145,160,170,180,200,230,270,290,310,360,430,460,580,640],d.square=[16,20,24,30,32,36,40,48,50,60,64,70,72,80,88,90,100,110,120,125,128,145,180,190,200,200,210,220,230,240,250,270,300,310,315,320,336,360,468,490,540,560,580,600,640,720,728,760,970],d.filterDomains=["a.tbcdn.cn","assets.alicdn.com","wwc.taobaocdn.com","wwc.alicdn.com","cbu01.alicdn.com"];var g={width:320,height:320,webpSupport:!1,ignoreGif:!0,ignorePng:!1,sharpen:"s150",q:"q50",baseDpr:2,original:!1,filterDomains:[]},s={getNewUrl:r};lib.imgcore=s,module.exports=s}();

/***/ },
/* 146 */
/***/ function(module, exports) {

	(typeof window === 'undefined') && (window = {ctrl: {}, lib: {}});!window.ctrl && (window.ctrl = {});!window.lib && (window.lib = {});!function(a,b){function c(a){var b={};Object.defineProperty(this,"params",{set:function(a){if("object"==typeof a){for(var c in b)delete b[c];for(var c in a)b[c]=a[c]}},get:function(){return b},enumerable:!0}),Object.defineProperty(this,"search",{set:function(a){if("string"==typeof a){0===a.indexOf("?")&&(a=a.substr(1));var c=a.split("&");for(var d in b)delete b[d];for(var e=0;e<c.length;e++){var f=c[e].split("=");if(void 0!==f[1]&&(f[1]=f[1].toString()),f[0])try{b[decodeURIComponent(f[0])]=decodeURIComponent(f[1])}catch(g){b[f[0]]=f[1]}}}},get:function(){var a=[];for(var c in b)if(void 0!==b[c])if(""!==b[c])try{a.push(encodeURIComponent(c)+"="+encodeURIComponent(b[c]))}catch(d){a.push(c+"="+b[c])}else try{a.push(encodeURIComponent(c))}catch(d){a.push(c)}return a.length?"?"+a.join("&"):""},enumerable:!0});var c;Object.defineProperty(this,"hash",{set:function(a){"string"==typeof a&&(a&&a.indexOf("#")<0&&(a="#"+a),c=a||"")},get:function(){return c},enumerable:!0}),this.set=function(a){a=a||"";var b;if(!(b=a.match(new RegExp("^([a-z0-9-]+:)?[/]{2}(?:([^@/:?]+)(?::([^@/:]+))?@)?([^:/?#]+)(?:[:]([0-9]+))?([/][^?#;]*)?(?:[?]([^#]*))?([#][^?]*)?$","i"))))throw new Error("Wrong uri scheme.");this.protocol=b[1]||("object"==typeof location?location.protocol:""),this.username=b[2]||"",this.password=b[3]||"",this.hostname=this.host=b[4],this.port=b[5]||"",this.pathname=b[6]||"/",this.search=b[7]||"",this.hash=b[8]||"",this.origin=this.protocol+"//"+this.hostname},this.toString=function(){var a=this.protocol+"//";return this.username&&(a+=this.username,this.password&&(a+=":"+this.password),a+="@"),a+=this.host,this.port&&"80"!==this.port&&(a+=":"+this.port),this.pathname&&(a+=this.pathname),this.search&&(a+=this.search),this.hash&&(a+=this.hash),a},a&&this.set(a.toString())}b.httpurl=function(a){return new c(a)}}(window,window.lib||(window.lib={}));;module.exports = window.lib.httpurl;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(148);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./image.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./image.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".weex-img {\n\tbox-sizing: border-box;\n  position: relative;\n  background-repeat: no-repeat;\n  background-size: 100% 100%;\n  background-position: 50%;\n}", ""]);
	
	// exports


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var weex = __webpack_require__(9)
	var utils = weex.utils
	var extend = utils.extend
	var Component = weex.Component
	var ComponentManager = weex.ComponentManager
	__webpack_require__(150)
	
	var DEFAULT_DESIGN_WIDTH = 750
	
	var defaults = {
	  baseDpr: ({ 750: 2, 1125: 3 })[DEFAULT_DESIGN_WIDTH] || 1,
	  qNormal: 'q90',
	  qWeak: 'q60'
	}
	
	// opts:
	//  - autoPlay
	//  - playstatus
	function Slider (data) {
	  this.autoPlay = false  // default value is false.
	  this.direction = 'row' // 'column' is not temporarily supported.
	  this.children = []
	  this.isPageShow = true
	  this.isDomRendering = true
	
	  // bind event 'pageshow' and 'pagehide' on window.
	  this._idleWhenPageDisappear()
	  // bind event 'renderBegin' and 'renderEnd' on window.
	  this._idleWhenDomRendering()
	
	  Component.call(this, data)
	}
	
	Slider.prototype = Object.create(Component.prototype)
	
	Slider.prototype._idleWhenPageDisappear = function () {
	  var _this = this
	  window.addEventListener('pageshow', function () {
	    _this.isPageShow = true
	    _this.autoPlay && !_this.isDomRendering && _this.play()
	  })
	  window.addEventListener('pagehide', function () {
	    _this.isPageShow = false
	    _this.stop()
	  })
	}
	
	Slider.prototype._idleWhenDomRendering = function () {
	  var _this = this
	  window.addEventListener('renderend', function () {
	    _this.isDomRendering = false
	    _this.autoPlay && _this.isPageShow && _this.play()
	  })
	  window.addEventListener('renderbegin', function () {
	    _this.isDomRendering = true
	    _this.stop()
	  })
	}
	
	Slider.prototype.attr = {
	  interval: function (val) {
	    this.interval = parseInt(val) || 3000
	    if (this.carrousel) {
	      this.carrousel.playInterval = this.interval
	    }
	  },
	
	  playstatus: function (val) {
	    this.playstatus = val && val !== 'false' ? true : false
	    this.autoPlay = this.playstatus
	    if (this.carrousel) {
	      if (this.playstatus) {
	        this.play()
	      } else {
	        this.stop()
	      }
	    }
	  },
	
	  // support playstatus' alias auto-play for compatibility
	  autoPlay: function (val) {
	    this.attr.playstatus.call(this, val)
	  }
	}
	
	Slider.prototype.create = function () {
	  var node = document.createElement('div')
	  node.classList.add('slider')
	  node.style.position = 'relative'
	  node.style.overflow = 'hidden'
	  return node
	}
	
	Slider.prototype._doRender = function () {
	  var _this = this
	  _this.createChildren()
	  _this.onAppend()
	}
	
	Slider.prototype.removeChild = function (child) {
	  var children = this.data.children
	  if (children) {
	    for (var i = 0; i < children.length; i++) {
	      if (child.data.ref === children[i].ref) {
	        children.splice(i, 1)
	        break
	      }
	    }
	  }
	
	  this._doRender()
	}
	
	Slider.prototype.insertBefore = function (child, before) {
	  var children = this.data.children
	  var childIndex = -1
	  for (var i = 0, l = children.length; i < l; i++) {
	    if (children[i].ref === before.data.ref) {
	      childIndex = i
	      break
	    }
	  }
	  children.splice(childIndex, 0, child.data)
	
	  this._doRender()
	  if (this.children.length > 0) {
	    return this.children[this.children.length - 1]
	  }
	}
	
	Slider.prototype.appendChild = function (data) {
	  var children = this.data.children || (this.data.children = [])
	  children.push(data)
	  this._doRender()
	  if (this.children.length > 0) {
	    return this.children[this.children.length - 1]
	  }
	}
	
	Slider.prototype.createChildren = function () {
	
	  // recreate slider container.
	  if (this.sliderContainer) {
	    this.node.removeChild(this.sliderContainer)
	  }
	  if (this.indicator) {
	    this.indicator.node.parentNode.removeChild(this.indicator.node)
	  }
	  this.children = []
	
	  var sliderContainer = document.createElement('ul')
	  sliderContainer.style.listStyle = 'none'
	  this.node.appendChild(sliderContainer)
	  this.sliderContainer = sliderContainer
	
	  var componentManager = this.getComponentManager()
	
	  var children = this.data.children
	  var scale = this.data.scale
	  var fragment = document.createDocumentFragment()
	  var indicatorData, width, height
	  var childWidth = 0
	  var childHeight = 0
	
	  if (children && children.length) {
	    for (var i = 0; i < children.length; i++) {
	      var child
	      children[i].scale = this.data.scale
	      children[i].instanceId = this.data.instanceId
	      if (children[i].type === 'indicator') {
	        indicatorData = extend(children[i], {
	          extra: {
	            amount: children.length - 1,
	            index: 0
	          }
	        })
	      } else {
	        child = componentManager.createElement(children[i], 'li')
	        this.children.push(child)
	        fragment.appendChild(child.node)
	        width = child.data.style.width || 0
	        height = child.data.style.height || 0
	        width > childWidth && (childWidth = width)
	        height > childHeight && (childHeight = height)
	        child.parentRef = this.data.ref
	      }
	    }
	    // append indicator
	    if (indicatorData) {
	      indicatorData.extra.width = this.data.style.width || childWidth
	      indicatorData.extra.height = this.data.style.height || childHeight
	      this.indicator = componentManager.createElement(indicatorData)
	      this.indicator.parentRef = this.data.ref
	      this.indicator.slider = this
	      this.node.appendChild(this.indicator.node)
	    }
	
	    sliderContainer.style.height = scale * this.data.style.height + 'px'
	    sliderContainer.appendChild(fragment)
	  }
	}
	
	Slider.prototype.onAppend = function () {
	  if (this.carrousel) {
	    this.carrousel.removeEventListener('change', this._getSliderChangeHandler())
	    this.carrousel.stop()
	    this.carrousel = null
	  }
	  this.carrousel = new lib.carrousel(this.sliderContainer, {
	    autoplay: this.autoPlay,
	    useGesture: true
	  })
	
	  this.carrousel.playInterval = this.interval
	  this.carrousel.addEventListener('change', this._getSliderChangeHandler())
	
	  this.currentIndex = 0
	
	  // preload all images for slider
	  // because:
	  // 1. lib-img doesn't listen to event transitionend
	  // 2. even if we fire lazy load in slider's change event handler,
	  //    the next image still won't be preloaded utill the moment it
	  //    slides into the view, which is too late.
	  if (this.preloadImgsTimer) {
	    clearTimeout(this.preloadImgsTimer)
	  }
	  // The time just before the second slide appear and enough
	  // for all child elements to append is ok.
	  var preloadTime = 0.8
	  this.preloadImgsTimer = setTimeout(function () {
	    var imgs = this.carrousel.element.querySelectorAll('.weex-img')
	    for (var i = 0, l = imgs.length; i < l; i++) {
	      var img = imgs[i]
	      var iLazySrc = img.getAttribute('i-lazy-src')
	      var imgSrc = img.getAttribute('img-src')
	      var realSrc = iLazySrc || imgSrc
	      // transfer the imgUrl to a cdn suffixed url.
	      realSrc && (realSrc = lib.imgcore.getNewUrl(realSrc, {
	        dpr: defaults.baseDpr,
	        webpSupport: utils.detectWebp(),
	        ignoreGif: true,
	        ignorePng: false,
	        width: ~~img.getAttribute('data-width') || 320,
	        height: ~~img.getAttribute('data-height') || 320,
	        sharpen: img.getAttribute('data-sharpen') || 's150',
	        q: img.getAttribute('data-q-normal') || defaults.qNormal
	      }))
	      realSrc && (img.style.backgroundImage = 'url(' + realSrc + ')')
	      img.removeAttribute('i-lazy-src')
	      img.removeAttribute('img-src')
	    }
	  }.bind(this), preloadTime * 1000)
	
	  // avoid page scroll when panning
	  var panning = false
	  this.carrousel.element.addEventListener('panstart', function (e) {
	    if (!e.isVertical) {
	      panning = true
	    }
	  })
	  this.carrousel.element.addEventListener('panend', function (e) {
	    if (!e.isVertical) {
	      panning = false
	    }
	  })
	
	  document.addEventListener('touchmove', function (e) {
	    if (panning) {
	      e.preventDefault()
	      return false
	    }
	    return true
	  }.bind(this))
	
	}
	
	Slider.prototype._updateIndicators = function () {
	  this.indicator && this.indicator.setIndex(this.currentIndex)
	}
	
	Slider.prototype._getSliderChangeHandler = function (e) {
	  if (!this.sliderChangeHandler) {
	    this.sliderChangeHandler = (function (e) {
	      var index = this.carrousel.items.index
	      this.currentIndex = index
	
	      // updateIndicators
	      this._updateIndicators()
	
	      this.dispatchEvent('change', { index: index })
	    }).bind(this)
	  }
	  return this.sliderChangeHandler
	}
	
	Slider.prototype.play = function () {
	  this.carrousel.play()
	}
	
	Slider.prototype.stop = function () {
	  this.carrousel.stop()
	}
	
	Slider.prototype.slideTo = function (index) {
	  var offset = index - this.currentIndex
	  this.carrousel.items.slide(offset)
	}
	
	module.exports = Slider
	


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(151);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(13)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./slider.css", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./slider.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(12)();
	// imports
	
	
	// module
	exports.push([module.id, ".slider {\n  position: relative;\n}\n\n.slider .indicator-container {\n  position: absolute;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-box-align: center;\n  box-align: center;\n  -webkit-align-items: center;\n  align-items: center;\n  -webkit-box-pack: center;\n  box-pack: center;\n  -webkit-justify-content: center;\n  justify-content: center;\n  font-size: 0;\n}\n.slider .indicator-container .indicator {\n  border-radius: 50%;\n}\n.slider .indicator-container.row {\n  -webkit-box-orient: horizontal;\n  box-orient: horizontal;\n  -webkit-flex-direction: row;\n  flex-direction: row;\n}\n.slider .indicator-container.column {\n  -webkit-box-orient: vertical;\n  box-orient: vertical;\n  -webkit-flex-direction: column;\n  flex-direction: column;\n}\n", ""]);
	
	// exports


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	// For debug: require the latest version which is not published
	// to the npm yet.
	
	__webpack_require__(153)
	
	// For release: require the npm published version of jsframework.
	// require('@ali/weex-jsframework')
	
	__webpack_require__(3)
	
	var weex = __webpack_require__(8)

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by godsong on 16/6/15.
	 */
	var WebsocketClient=__webpack_require__(154);
	var websocketClient=new WebsocketClient('ws://'+location.host+'/debugProxy/native');
	[
	    'createInstance',
	    'refreshInstance',
	    'destroyInstance',
	    'registerComponents',
	    'registerModules',
	    'registerMethods',
	    'getRoot',
	    'callJS'
	].forEach(function(name){
	    window[name]=function(){
	        var args=Array.prototype.slice.call(arguments);
	        websocketClient.send({
	            method:'WxDebug.callJS',
	            params:{
	                method:name,
	                args:args
	            }
	        })
	    }
	});
	websocketClient.on('WxDebug.callNative',function(message){
	    window.callNative(message.params.instance,message.params.tasks,message.params.callback);
	});
	websocketClient.send({
	    method:"WxDebug.initJSRuntime"
	});

/***/ },
/* 154 */
/***/ function(module, exports) {

	/**
	 * Created by godsong on 16/6/14.
	 */
	class WebsocketClient {
	    constructor(url) {
	        this._handlers = {};
	        this.connect(url);
	        this.context={};
	    }
	    connect(url){
	        let This=this;
	        This.isSocketReady=false;
	        if(This.ws){
	            This.ws.onopen=null;
	            This.ws.onmessage=null;
	            This.ws.onclose=null;
	            if(This.ws.readyState==WebSocket.OPEN){
	                This.ws.close();
	            }
	
	        }
	        let ws = new WebSocket(url);
	        This.ws=ws;
	        ws.onopen = function () {
	            This.isSocketReady=true;
	            This.emit('socketOpened');
	        };
	        ws.onmessage = function (e) {
	            let message = JSON.parse(e.data);
	            if (message.method) {
	                This.emit(message.method, message);
	            }
	        };
	        ws.onclose=function(){
	            This.isSocketReady=false;
	            setTimeout(function(){
	                This.connect(url);
	            },800);
	        };
	
	    }
	    send(data){
	        if(this.isSocketReady){
	            this.ws.send(JSON.stringify(data));
	        }
	        else{
	            this.once('socketOpened',()=>{this.ws.send(JSON.stringify(data))});
	        }
	    }
	    off(method,handler){
	        if(handler){
	            for(let i=0;i<this._handlers[method].length;i++){
	                if(this._handlers[method][i]===handler){
	                    this._handlers[method].splice(i,1);
	                    i--;
	                }
	            }
	        }
	        else{
	            this._handlers[method]=[];
	        }
	    }
	    once(method,handler){
	        let self = this;
	        let fired = false;
	
	        function g() {
	            self.off(method, g);
	            if (!fired) {
	                fired = true;
	                handler.apply(self, Array.prototype.slice.call(arguments));
	            }
	        }
	
	        this.on(method, g);
	    }
	    on(method, handler) {
	        if (this._handlers[method]) {
	            this._handlers[method].push(handler);
	        }
	        else {
	            this._handlers[method] = [handler];
	        }
	    }
	
	    _emit(method, args,context) {
	        let handlers = this._handlers[method];
	        if (handlers && handlers.length > 0) {
	            handlers.forEach(handler=>handler.apply(context, args));
	            return true;
	        }
	        else {
	            return false;
	        }
	    }
	
	    emit(method, ...args) {
	        let context={};
	        if (!this._emit(method, args,context)) {
	            this._emit('$default', args,context)
	        }
	        this._emit('$finally', args,context);
	        return context;
	    }
	}
	module.exports=WebsocketClient;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYTQwYjc3YmM4NGRiMDA4Y2ViY2Q/MzNhNSIsIndlYnBhY2s6Ly8vLi9+L2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanM/Yzk5MyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL34vbm9kZS1saWJzLWJyb3dzZXIvfi9wcm9jZXNzL2Jyb3dzZXIuanM/NmYwZSIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2MzYzIiLCJ3ZWJwYWNrOi8vL3ZlcnR4IChpZ25vcmVkKT82MWYxIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzPzBiYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FsaXdlZXguanM/YWEzYiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3dlZXguanM/OTg3MSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9iYXNlLmNzcz80MDc1KiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9iYXNlLmNzcz9hNjY1Iiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/ZGEwNCIsIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanM/Yjk4MCIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3BvbHlmaWxsLmpzP2M3M2MiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9sb2dnZXIuanM/ZjA3NiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2NvbmZpZy5qcz9hNjQzIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvdXRpbHMuanM/NDI3NSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2xvYWRlci5qcz8zMWM5Iiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvcHJvdG9jb2wuanM/ZmVkYyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudE1hbmFnZXIuanM/Y2RiYyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2ZyYW1lVXBkYXRlci5qcz9mMmMwIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvYXBwZWFyV2F0Y2hlci5qcz85MTZiIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvbGF6eUxvYWQuanM/NzFjOSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9sYXp5aW1nL2J1aWxkL2ltZy5jb21tb24uanM/NmU2ZSIsIndlYnBhY2s6Ly8vLi9+L2FwcGVhcmpzL2J1aWxkL2FwcGVhci5jb21tb24uanM/ZGMwMyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2FuaW1hdGlvbi5qcz9mZGQ4Iiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9jb21wb25lbnQuanM/ZjhjNSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2ZsZXhib3guanM/MzUzMyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3ZhbHVlRmlsdGVyLmpzP2Y3NjAiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L34vZml4ZWRzdGlja3kvYnVpbGQvc3RpY2t5LmNvbW1vbi5qcz84MWIyIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvYnJpZGdlL3NlbmRlci5qcz82YTM0Iiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvYnJpZGdlL3JlY2VpdmVyLmpzP2RmODkiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2luZGV4LmpzPzcyYWMiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3Jvb3QuanM/ZmUyYyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvY29udGFpbmVyLmpzPzMxMzQiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvY29udGFpbmVyLmNzcz9jYzQxKiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9jb250YWluZXIuY3NzPzJmYmEiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2ltYWdlLmpzPzlmMzUiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2F0b21pYy5qcz8yYjlmIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2ltYWdlLmNzcz85MTNhKiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9pbWFnZS5jc3M/YzQ3NiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvdGV4dC5qcz80M2YxIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy92bGlzdC5qcz9hNTRmIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9saXN0LmpzP2RlNDYiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvbGlzdC5jc3M/ZTllZSoiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvbGlzdC5jc3M/MWM0MiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3Njcm9sbC5qcz83YTNiIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvbW90aW9uLmpzP2NkZTIiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2hsaXN0LmpzP2JiYTgiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2NvdW50ZG93bi5qcz9jMWZhIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9+L2tvdW50ZG93bi9idWlsZC9jb3VudGRvd24uanM/MzM1ZSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvbWFycXVlZS5qcz9hNTAxIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9zbGlkZXIuanM/NzVlNSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9jYXJyb3VzZWwvYnVpbGQvY2Fycm91c2VsLmNvbW1vbi5qcz9lYjBhIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9+L2FuaW1hdGlvbmpzL2J1aWxkL2FuaW1hdGlvbi5jb21tb24uanM/ZTRiNCIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9jdWJpY2Jlemllci9idWlsZC9jdWJpY2Jlemllci5jb21tb24uanM/NzExYyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9jYXJyb3VzZWwvfi9nZXN0dXJlanMvYnVpbGQvZ2VzdHVyZWpzLmNvbW1vbi5qcz9hMDE4Iiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3NsaWRlci5jc3M/MTc1MCoiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvc2xpZGVyLmNzcz84OTk4Iiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9pbmRpY2F0b3IuanM/MDJkZiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9pbmRpY2F0b3IuY3NzPzk3NjMqIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2luZGljYXRvci5jc3M/OGI0YiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvdGFiaGVhZGVyLmpzPzEyN2UiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9tZXNzYWdlUXVldWUuanM/MzQ3MSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy90YWJoZWFkZXIuY3NzPzhmNTcqIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3RhYmhlYWRlci5jc3M/ODYyYSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvc2Nyb2xsZXIuanM/MTg2OCIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9zY3JvbGxlci5jc3M/OTFjOCoiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvc2Nyb2xsZXIuY3NzPzMxODciLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2lucHV0LmpzP2JhYWMiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3NlbGVjdC5qcz81MjRiIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9kYXRlcGlja2VyLmpzPzk1ODQiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3RpbWVwaWNrZXIuanM/NWFjNyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvdmlkZW8uanM/YzQxNiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy92aWRlby5jc3M/ODg3ZCoiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvdmlkZW8uY3NzP2I3ODkiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3N3aXRjaC5qcz9iYWVkIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3N3aXRjaC5jc3M/MzI2MSoiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvc3dpdGNoLmNzcz84ZTg2Iiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9hLmpzP2Y2MWIiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2VtYmVkLmpzPzI3NzIiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3JlZnJlc2guanM/ZmVkNCIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9yZWZyZXNoLmNzcz82ZWI4KiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9yZWZyZXNoLmNzcz84NDgzIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9sb2FkaW5nLmpzP2JjYWUiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvbG9hZGluZy5jc3M/OTk2ZCoiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvbG9hZGluZy5jc3M/YWMzMiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvc3Bpbm5lci5qcz84ZDUwIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3NwaW5uZXIuY3NzPzJjOTMqIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3NwaW5uZXIuY3NzPzAzNDciLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3dlYi5qcz8xY2VlIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvYXBpL2luZGV4LmpzP2IxNWYiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9hcGkvZG9tLmpzP2I5NDIiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JvbGwtdG8vaW5kZXguanM/NDMwNCIsIndlYnBhY2s6Ly8vLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9pbmRleC5qcz8wY2NlIiwid2VicGFjazovLy8uL34vc2Nyb2xsLXRvL34vY29tcG9uZW50LXR3ZWVuL34vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanM/NDljNCIsIndlYnBhY2s6Ly8vLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9+L2NvbXBvbmVudC1jbG9uZS9pbmRleC5qcz85YmMzIiwid2VicGFjazovLy8uL34vc2Nyb2xsLXRvL34vY29tcG9uZW50LXR3ZWVuL34vY29tcG9uZW50LXR5cGUvaW5kZXguanM/NjU0ZCIsIndlYnBhY2s6Ly8vLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9+L2Vhc2UtY29tcG9uZW50L2luZGV4LmpzPzZmNzgiLCJ3ZWJwYWNrOi8vLy4vfi9zY3JvbGwtdG8vfi9jb21wb25lbnQtcmFmL2luZGV4LmpzPzY1ODUiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9hcGkvZXZlbnQuanM/MDk0MCIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2FwaS9wYWdlSW5mby5qcz82NGYzIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9zcmMvYXBpL3N0cmVhbS5qcz83MjQyIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9+L2h0dHB1cmwvYnVpbGQvaHR0cHVybC5jb21tb24uanM/ZmYzYSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2FwaS9tb2RhbC5qcz8wNTRmIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9+L21vZGFscy9zcmMvaW5kZXguanM/MjM5NSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3JjL2FsZXJ0LmpzPzkxMDEiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3NyYy9tb2RhbC5qcz8zODE5Iiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9+L21vZGFscy9zdHlsZXMvbW9kYWwuY3NzPzdmZDYqIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9+L21vZGFscy9zdHlsZXMvbW9kYWwuY3NzPzY4MGIiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3N0eWxlcy9hbGVydC5jc3M/NzMxZioiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3N0eWxlcy9hbGVydC5jc3M/NzY4NyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3JjL2NvbmZpcm0uanM/N2Q2YyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3R5bGVzL2NvbmZpcm0uY3NzPzA5MWIqIiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9+L21vZGFscy9zdHlsZXMvY29uZmlybS5jc3M/MGU4ZiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3JjL3Byb21wdC5qcz82Zjc0Iiwid2VicGFjazovLy8uL34vd2VleC1odG1sNS9+L21vZGFscy9zdHlsZXMvcHJvbXB0LmNzcz8xMjQ3KiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3R5bGVzL3Byb21wdC5jc3M/NGYyNiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3JjL3RvYXN0LmpzPzE3NmMiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3N0eWxlcy90b2FzdC5jc3M/NWMxZioiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3N0eWxlcy90b2FzdC5jc3M/N2YxZiIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2FwaS9hbmltYXRpb24uanM/N2EyNyIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2FwaS93ZWJ2aWV3LmpzPzBkOTQiLCJ3ZWJwYWNrOi8vLy4vfi93ZWV4LWh0bWw1L3NyYy9hcGkvdGltZXIuanM/Y2ExYSIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvc3JjL2FwaS9uYXZpZ2F0b3IuanM/ZTRmMCIsIndlYnBhY2s6Ly8vLi9+L3dlZXgtaHRtbDUvfi9lbnZkL2J1aWxkL2VudmQuY29tbW9uLmpzPzJkODIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xvYWRlci5qcz9jZjA4Iiwid2VicGFjazovLy8uL3NyYy9hcGkvaW5kZXguanM/ODMyMyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2V2ZW50LmpzPzQ2ZDAiLCJ3ZWJwYWNrOi8vLy4vfi9AYWxpL2xpYi1jYWxsYXBwL2J1aWxkL2NhbGxhcHAuY29tbW9uLmpzPzdlYzYiLCJ3ZWJwYWNrOi8vLy4vfi9AYWxpL2xpYi1jYWxsYXBwL34vQGFsaS9saWItZW52L2J1aWxkL2Vudi5jb21tb24uanM/ZTZlZiIsIndlYnBhY2s6Ly8vLi9+L0BhbGkvbGliLWNhbGxhcHAvfi9AYWxpL2xpYi1odHRwdXJsL2J1aWxkL2h0dHB1cmwuY29tbW9uLmpzP2ZmMTkiLCJ3ZWJwYWNrOi8vLy4vfi9AYWxpL2xpYi13aW5kdmFuZS9idWlsZC93aW5kdmFuZS5jb21tb24uanM/OTA5MCIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3BhZ2VJbmZvLmpzP2U2OTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9zdHJlYW0uanM/ZGY3OCIsIndlYnBhY2s6Ly8vLi9+L0BhbGkvbGliLWxvZ2luL2J1aWxkL2xvZ2luLmNvbW1vbi5qcz9hNDgwIiwid2VicGFjazovLy8uL34vQGFsaS9saWItbXRvcC9idWlsZC9tdG9wLmNvbW1vbi5qcz9hMDVkIiwid2VicGFjazovLy8uL3NyYy9hcGkvdXNlci5qcz9iY2MyIiwid2VicGFjazovLy8uL3NyYy9hcGkvdXNlclRyYWNrLmpzP2MwMzYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS93aW5kdmFuZS5qcz81ZDkyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2luZGV4LmpzPzZjNjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvaW1hZ2UuanM/YzM5MSIsIndlYnBhY2s6Ly8vLi9zcmMvbGF6eUxvYWQuanM/MzM3ZiIsIndlYnBhY2s6Ly8vLi9zcmMvaW1nUHJvY2Vzc29yLmpzP2QzZjQiLCJ3ZWJwYWNrOi8vLy4vfi9AYWxpL2xpYi1pbWctY29yZS9idWlsZC9pbWdjb3JlLmNvbW1vbi5qcz8wNzMwIiwid2VicGFjazovLy8uL34vQGFsaS9saWItaW1nLWNvcmUvfi9AYWxpL2xpYi1odHRwdXJsL2J1aWxkL2h0dHB1cmwuY29tbW9uLmpzP2YyZDciLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9pbWFnZS5jc3M/Njg1MSoiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9pbWFnZS5jc3M/NGZmYiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zbGlkZXIuanM/NDdjZCIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzL3NsaWRlci5jc3M/MzM1YyoiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlcy9zbGlkZXIuY3NzPzVjNmYiLCJ3ZWJwYWNrOi8vLy4vd2VleGJ1bmRsZS1kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9ydW50aW1lLXByb3h5LmpzIiwid2VicGFjazovLy8uL1dlYnNvY2tldENsaWVudC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7K0NDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLHNCQUFzQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsK0JBQStCO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVM7QUFDVCx3QkFBdUIsUUFBUTtBQUMvQjs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUVBQWtFLFFBQVE7O0FBRTFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBa0UsUUFBUTtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDLFFBQVE7O0FBRTdDOztBQUVBLHNCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPO0FBQ1A7QUFDQTtBQUNBLDBCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBLGVBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87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Ozs7O0FDNzdCRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixVQUFVOzs7Ozs7O0FDN0Z0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBLGdCOzs7Ozs7QUNBQSw4QkFBNkIsbURBQW1EOzs7Ozs7O0FDQWhGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDbkJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7O0FBRVIsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDM0tBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQkFBZ0I7O0FBRWhCO0FBQ0EsWUFBVzs7QUFFWDtBQUNBLGdCQUFlOztBQUVmO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRUFBQzs7QUFFRDs7Ozs7OztBQ3BJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLG9C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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFOzs7Ozs7QUNsQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxnQ0FBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QixpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVILFdBQVU7O0FBRVY7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLE9BQU87QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDbllBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7Ozs7OztBQ2pEQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6Q0EsK0NBQThDLFFBQVEsVUFBVSxFQUFFLGlDQUFpQyxFQUFFLCtCQUErQixFQUFFLGlCQUFpQixjQUFjLCtFQUErRSxnQkFBZ0Isa0NBQWtDLG9DQUFvQyxrQkFBa0IsMkJBQTJCLHFHQUFxRyxjQUFjLFNBQVMsMENBQTBDLGdCQUFnQixFQUFFLElBQUksZ0JBQWdCLG1DQUFtQyx3RUFBd0UsV0FBVyw0RkFBNEYsK0pBQStKLHVDQUF1Qyx1Q0FBdUMsZ0JBQWdCLG1DQUFtQyxHQUFHLGFBQWEsOEJBQThCLGlDQUFpQyw2TEFBNkwsd0JBQXdCLDBKQUEwSixzQkFBc0IsWUFBWSxXQUFXLDJCQUEyQixvQkFBb0IsV0FBVyxxQ0FBcUMsNkJBQTZCLHNDQUFzQyx5Q0FBeUMsK0NBQStDLGdFQUFnRSxrTkFBa04saUxBQWlMLGlDQUFpQyxTQUFTLDRCQUE0Qix3VkFBd1YseURBQXlELFNBQVMsNkNBQTZDLHNDQUFzQyxvQkFBb0Isd01BQXdNLE1BQU0sdURBQXVELGtDQUFrQyxnREFBZ0Qsb0JBQW9CLHVCQUF1Qix3Q0FBd0MsNEJBQTRCLG9GQUFvRixvQkFBb0IsV0FBVyxZQUFZLHNCQUFzQiw0SEFBNEgsWUFBWSwyQ0FBMkMsSUFBSSxzQzs7Ozs7O0FDQXRqSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUEsd0I7Ozs7OztBQ3pEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDekRBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1B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QSxNQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDs7QUFFQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87O0FBRVA7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87O0FBRVA7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7Ozs7OztBQ3RwQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU8sbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFpQjtBQUNqQjs7QUFFQSx3Qjs7Ozs7O0FDOUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCOzs7Ozs7QUNUQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1REEsZ0JBQWUsY0FBYyxNQUFNLHdDQUF3Qyw0QkFBNEIsc0NBQXNDLFNBQVMsdURBQXVELGlCQUFpQiwyQkFBMkIscUdBQXFHLDRCQUE0QixnQkFBZ0IsOENBQThDLDZCQUE2QixzQ0FBc0MsZ0ZBQWdGLGdEQUFnRCxFQUFFLHdDQUF3Qyw0Q0FBNEMsa0JBQWtCLFFBQVEsMEJBQTBCLHVEQUF1RCx3TUFBd00scUNBQXFDLGFBQWEsaUJBQWlCLFdBQVcsbUVBQW1FLFlBQVksZ0JBQWdCLG9CQUFvQiwwSUFBMEksNFFBQTRRLGlCQUFpQixXQUFXLDBFQUEwRSx3QkFBd0IsV0FBVyx5QkFBeUIseUJBQXlCLGlCQUFpQixrQ0FBa0MsRzs7Ozs7O0FDQXowRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLDJCQUEyQjtBQUMxQyxhQUFZLGdDQUFnQztBQUM1QyxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZixhQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25CLG9CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hSQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7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Z0NBQStCLFFBQVE7QUFDdkM7O0FBRUEsOEJBQTZCLFdBQVc7O0FBRXhDO0FBQ0EsTUFBSzs7QUFFTDtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7O0FDNVhBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLOztBQUVMOzs7Ozs7O0FDMU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlFO0FBQ3pFO0FB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QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDaEtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeERBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNoQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6S0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLHVCOzs7Ozs7QUNwQkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLDBCOzs7Ozs7QUNwQkE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOzs7Ozs7O0FDbkVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQ0FBK0I7QUFDL0I7O0FBRUEsdUI7Ozs7OztBQzlCQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOzs7Ozs7O0FDaERBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTs7Ozs7OztBQ2xFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUE0RTtBQUM1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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQSwyQjs7Ozs7O0FDM0RBOztBQUVBOztBQUVBO0FBQ0EsZUFBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGVBQWMsT0FBTztBQUNyQixlQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVM7O0FBRVQsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBOzs7Ozs7O0FDN0NBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCOzs7Ozs7QUNWQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDbktBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzVFQTtBQUNBOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsTUFBSyxnQkFBZ0I7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FB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QTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxtQ0FBbUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsZ0NBQWdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDIiwiZmlsZSI6IndlZXgtZGVidWcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGE0MGI3N2JjODRkYjAwOGNlYmNkXG4gKiovIiwiLyohXG4gKiBAb3ZlcnZpZXcgZXM2LXByb21pc2UgLSBhIHRpbnkgaW1wbGVtZW50YXRpb24gb2YgUHJvbWlzZXMvQSsuXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAoYykgMjAxNCBZZWh1ZGEgS2F0eiwgVG9tIERhbGUsIFN0ZWZhbiBQZW5uZXIgYW5kIGNvbnRyaWJ1dG9ycyAoQ29udmVyc2lvbiB0byBFUzYgQVBJIGJ5IEpha2UgQXJjaGliYWxkKVxuICogQGxpY2Vuc2UgICBMaWNlbnNlZCB1bmRlciBNSVQgbGljZW5zZVxuICogICAgICAgICAgICBTZWUgaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pha2VhcmNoaWJhbGQvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgMy4yLjFcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRvYmplY3RPckZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc01heWJlVGhlbmFibGUoeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5O1xuICAgIGlmICghQXJyYXkuaXNBcnJheSkge1xuICAgICAgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHV0aWxzJCRpc0FycmF5ID0gbGliJGVzNiRwcm9taXNlJHV0aWxzJCRfaXNBcnJheTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiA9IDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR2ZXJ0eE5leHQ7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRjdXN0b21TY2hlZHVsZXJGbjtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2xpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW5dID0gY2FsbGJhY2s7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArIDFdID0gYXJnO1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGxlbiArPSAyO1xuICAgICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4obGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcihzY2hlZHVsZUZuKSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwKGFzYXBGbikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXAgPSBhc2FwRm47XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwgPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3NlcldpbmRvdyB8fCB7fTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGJyb3dzZXJHbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBsaWIkZXM2JHByb21pc2UkYXNhcCQkYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNOb2RlID0gdHlwZW9mIHNlbGYgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG5cbiAgICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkYXNhcCQkaXNXb3JrZXIgPSB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyBub2RlXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCkge1xuICAgICAgLy8gbm9kZSB2ZXJzaW9uIDAuMTAueCBkaXNwbGF5cyBhIGRlcHJlY2F0aW9uIHdhcm5pbmcgd2hlbiBuZXh0VGljayBpcyB1c2VkIHJlY3Vyc2l2ZWx5XG4gICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB2ZXJ0eFxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0KGxpYiRlczYkcHJvbWlzZSRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIG9ic2VydmVyID0gbmV3IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRCcm93c2VyTXV0YXRpb25PYnNlcnZlcihsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2gpO1xuICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZWIgd29ya2VyXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQobGliJGVzNiRwcm9taXNlJGFzYXAkJGZsdXNoLCAxKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkZmx1c2goKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2ldO1xuICAgICAgICB2YXIgYXJnID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHF1ZXVlW2krMV07XG5cbiAgICAgICAgY2FsbGJhY2soYXJnKTtcblxuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRxdWV1ZVtpKzFdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkbGVuID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXR0ZW1wdFZlcnR4KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHIgPSByZXF1aXJlO1xuICAgICAgICB2YXIgdmVydHggPSByKCd2ZXJ0eCcpO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VWZXJ0eFRpbWVyKCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoO1xuICAgIC8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG4gICAgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc05vZGUpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkYXNhcCQkQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRpc1dvcmtlcikge1xuICAgICAgbGliJGVzNiRwcm9taXNlJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSBsaWIkZXM2JHByb21pc2UkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2UgaWYgKGxpYiRlczYkcHJvbWlzZSRhc2FwJCRicm93c2VyV2luZG93ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzY2hlZHVsZUZsdXNoID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGF0dGVtcHRWZXJ0eCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkc2NoZWR1bGVGbHVzaCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSR0aGVuJCR0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcblxuICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmIChjaGlsZFtsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG1ha2VQcm9taXNlKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gcGFyZW50Ll9zdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1tzdGF0ZSAtIDFdO1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChmdW5jdGlvbigpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGludm9rZUNhbGxiYWNrKHN0YXRlLCBjaGlsZCwgY2FsbGJhY2ssIHBhcmVudC5fcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdGhlbiQkZGVmYXVsdCA9IGxpYiRlczYkcHJvbWlzZSR0aGVuJCR0aGVuO1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJHJlc29sdmUob2JqZWN0KSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgICAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCBvYmplY3QpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkcmVzb2x2ZTtcbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUFJPTUlTRV9JRCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wKCkge31cblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICAgPSB2b2lkIDA7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCA9IDE7XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEICA9IDI7XG5cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IgPSBuZXcgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4ocHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbikge1xuICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGZ1bmN0aW9uKHByb21pc2UpIHtcbiAgICAgICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBpZiAoc2VhbGVkKSB7IHJldHVybjsgfVxuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG5cbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgICAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUpIHtcbiAgICAgIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIGlmICh0aGVuYWJsZS5fc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlLCB0aGVuKSB7XG4gICAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3RvciAmJlxuICAgICAgICAgIHRoZW4gPT09IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0ICYmXG4gICAgICAgICAgY29uc3RydWN0b3IucmVzb2x2ZSA9PT0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGVuID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCBtYXliZVRoZW5hYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkc2VsZkZ1bGZpbGxtZW50KCkpO1xuICAgICAgfSBlbHNlIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGdldFRoZW4odmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgICAgaWYgKHByb21pc2UuX29uZXJyb3IpIHtcbiAgICAgICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cblxuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdmFsdWU7XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRDtcblxuICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBFTkRJTkcpIHsgcmV0dXJuOyB9XG4gICAgICBwcm9taXNlLl9zdGF0ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gICAgICBsaWIkZXM2JHByb21pc2UkYXNhcCQkYXNhcChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgICAgIHN1YnNjcmliZXJzW2xlbmd0aCArIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEXSAgPSBvblJlamVjdGlvbjtcblxuICAgICAgaWYgKGxlbmd0aCA9PT0gMCAmJiBwYXJlbnQuX3N0YXRlKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSRhc2FwJCRhc2FwKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHB1Ymxpc2gsIHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcHVibGlzaChwcm9taXNlKSB7XG4gICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwcm9taXNlLl9zdWJzY3JpYmVycztcbiAgICAgIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCA9IHByb21pc2UuX3Jlc3VsdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcblxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEVycm9yT2JqZWN0KCkge1xuICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUiA9IG5ldyBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkdHJ5Q2F0Y2goY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SLmVycm9yID0gZTtcbiAgICAgICAgcmV0dXJuIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XG4gICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICB2YWx1ZSA9IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SKSB7XG4gICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IHZhbHVlLmVycm9yO1xuICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAvLyBub29wXG4gICAgICB9IGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmFpbGVkKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGxlZCA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZShwcm9taXNlLCByZXNvbHZlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzb2x2ZXIoZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpe1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGlkID0gMDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRuZXh0SWQoKSB7XG4gICAgICByZXR1cm4gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaWQrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gICAgICBwcm9taXNlW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaWQrKztcbiAgICAgIHByb21pc2UuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgcHJvbWlzZS5fc3Vic2NyaWJlcnMgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbChlbnRyaWVzKSB7XG4gICAgICByZXR1cm4gbmV3IGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0KHRoaXMsIGVudHJpZXMpLnByb21pc2U7XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGRlZmF1bHQgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRhbGwkJGFsbDtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRyYWNlKGVudHJpZXMpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICBpZiAoIWxpYiRlczYkcHJvbWlzZSR1dGlscyQkaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmFjZSQkcmFjZTtcbiAgICBmdW5jdGlvbiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZWplY3QkJHJlamVjdChyZWFzb24pIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuICAgICAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG4gICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkcmVqZWN0JCRyZWplY3Q7XG5cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2U7XG4gICAgLyoqXG4gICAgICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gICAgICBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLCB3aGljaFxuICAgICAgcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgVGVybWlub2xvZ3lcbiAgICAgIC0tLS0tLS0tLS0tXG5cbiAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gICAgICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgICAgIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgICAgIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gICAgICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICAgICAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gICAgICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgICAgIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgICAgIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgICAgIEJhc2ljIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIGBgYGpzXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbiBzdWNjZXNzXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIG9uIGZhaWx1cmVcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgICAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICAgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQGNsYXNzIFByb21pc2VcbiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgICB0aGlzW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdID0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbmV4dElkKCk7XG4gICAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICB0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicgJiYgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKTtcbiAgICAgICAgdGhpcyBpbnN0YW5jZW9mIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlID8gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkaW5pdGlhbGl6ZVByb21pc2UodGhpcywgcmVzb2x2ZXIpIDogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzTmV3KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UuYWxsID0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkYWxsJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyYWNlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlc29sdmUgPSBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJlamVjdCA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlamVjdCQkZGVmYXVsdDtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0U2NoZWR1bGVyID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJHNldFNjaGVkdWxlcjtcbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5fc2V0QXNhcCA9IGxpYiRlczYkcHJvbWlzZSRhc2FwJCRzZXRBc2FwO1xuICAgIGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLl9hc2FwID0gbGliJGVzNiRwcm9taXNlJGFzYXAkJGFzYXA7XG5cbiAgICBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogbGliJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGxpYiRlczYkcHJvbWlzZSR0aGVuJCRkZWZhdWx0LFxuXG4gICAgLyoqXG4gICAgICBgY2F0Y2hgIGlzIHNpbXBseSBzdWdhciBmb3IgYHRoZW4odW5kZWZpbmVkLCBvblJlamVjdGlvbilgIHdoaWNoIG1ha2VzIGl0IHRoZSBzYW1lXG4gICAgICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuXG4gICAgICBgYGBqc1xuICAgICAgZnVuY3Rpb24gZmluZEF1dGhvcigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkbid0IGZpbmQgdGhhdCBhdXRob3InKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3luY2hyb25vdXNcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbmRBdXRob3IoKTtcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9XG5cbiAgICAgIC8vIGFzeW5jIHdpdGggcHJvbWlzZXNcbiAgICAgIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQG1ldGhvZCBjYXRjaFxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgICdjYXRjaCc6IGZ1bmN0aW9uKG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3Rpb24pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3I7XG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IoQ29uc3RydWN0b3IsIGlucHV0KSB7XG4gICAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgQ29uc3RydWN0b3IobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkbm9vcCk7XG5cbiAgICAgIGlmICghdGhpcy5wcm9taXNlW2xpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFBST01JU0VfSURdKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaWIkZXM2JHByb21pc2UkdXRpbHMkJGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0ICAgICA9IGlucHV0O1xuICAgICAgICB0aGlzLmxlbmd0aCAgICAgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9yZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggfHwgMDtcbiAgICAgICAgICB0aGlzLl9lbnVtZXJhdGUoKTtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHJlamVjdCh0aGlzLnByb21pc2UsIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCR2YWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJHZhbGlkYXRpb25FcnJvcigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fZW51bWVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoICA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIGlucHV0ICAgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRQRU5ESU5HICYmIGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9lYWNoRW50cnkoaW5wdXRbaV0sIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgICB2YXIgcmVzb2x2ZSA9IGMucmVzb2x2ZTtcblxuICAgICAgaWYgKHJlc29sdmUgPT09IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJHJlc29sdmUkJGRlZmF1bHQpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRnZXRUaGVuKGVudHJ5KTtcblxuICAgICAgICBpZiAodGhlbiA9PT0gbGliJGVzNiRwcm9taXNlJHRoZW4kJGRlZmF1bHQgJiZcbiAgICAgICAgICAgIGVudHJ5Ll9zdGF0ZSAhPT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgIHRoaXMuX3NldHRsZWRBdChlbnRyeS5fc3RhdGUsIGksIGVudHJ5Ll9yZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG4gICAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gZW50cnk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbGliJGVzNiRwcm9taXNlJHByb21pc2UkJGRlZmF1bHQpIHtcbiAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBjKGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGhhbmRsZU1heWJlVGhlbmFibGUocHJvbWlzZSwgZW50cnksIHRoZW4pO1xuICAgICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQobmV3IGMoZnVuY3Rpb24ocmVzb2x2ZSkgeyByZXNvbHZlKGVudHJ5KTsgfSksIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZShlbnRyeSksIGkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsaWIkZXM2JHByb21pc2UkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgICBpZiAoc3RhdGUgPT09IGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJFJFSkVDVEVEKSB7XG4gICAgICAgICAgbGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliJGVzNiRwcm9taXNlJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbihwcm9taXNlLCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgIGxpYiRlczYkcHJvbWlzZSQkaW50ZXJuYWwkJHN1YnNjcmliZShwcm9taXNlLCB1bmRlZmluZWQsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdChsaWIkZXM2JHByb21pc2UkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIHZhbHVlKTtcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQobGliJGVzNiRwcm9taXNlJCRpbnRlcm5hbCQkUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkcG9seWZpbGwoKSB7XG4gICAgICB2YXIgbG9jYWw7XG5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxvY2FsID0gZ2xvYmFsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsb2NhbCA9IHNlbGY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9seWZpbGwgZmFpbGVkIGJlY2F1c2UgZ2xvYmFsIG9iamVjdCBpcyB1bmF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgUCA9IGxvY2FsLlByb21pc2U7XG5cbiAgICAgIGlmIChQICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChQLnJlc29sdmUoKSkgPT09ICdbb2JqZWN0IFByb21pc2VdJyAmJiAhUC5jYXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9jYWwuUHJvbWlzZSA9IGxpYiRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0O1xuICAgIH1cbiAgICB2YXIgbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0ID0gbGliJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRwb2x5ZmlsbDtcblxuICAgIHZhciBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlID0ge1xuICAgICAgJ1Byb21pc2UnOiBsaWIkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCxcbiAgICAgICdwb2x5ZmlsbCc6IGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lOnRydWUgbW9kdWxlOnRydWUgd2luZG93OiB0cnVlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbGliJGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTsgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGVbJ2V4cG9ydHMnXSkge1xuICAgICAgbW9kdWxlWydleHBvcnRzJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzWydFUzZQcm9taXNlJ10gPSBsaWIkZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH1cblxuICAgIGxpYiRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdCgpO1xufSkuY2FsbCh0aGlzKTtcblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZXM2LXByb21pc2UvZGlzdC9lczYtcHJvbWlzZS5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvKiAoaWdub3JlZCkgKi9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIHZlcnR4IChpZ25vcmVkKVxuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpOyB9O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqICh3ZWJwYWNrKS9idWlsZGluL2FtZC1kZWZpbmUuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG4vLyBpbXBvcnQgb3BlbiBzb3VyY2UgdmVyc2lvbiBvZiB3ZWV4LWh0bWw1XG4vLyB2YXIgd2VleCA9IHJlcXVpcmUoJ3dlZXgtaHRtbDUnKVxudmFyIHdlZXggPSByZXF1aXJlKCd3ZWV4LWh0bWw1JylcblxuLy8gZXh0ZW5kIGxvYWRlclxudmFyIGxvYWRCeU10b3AgPSByZXF1aXJlKCcuL2xvYWRlcicpLmxvYWRCeU10b3BcblxudmFyIGFwaXMgPSByZXF1aXJlKCcuL2FwaScpXG53ZWV4Lmluc3RhbGwoYXBpcylcblxudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMnKVxud2VleC5pbnN0YWxsKGNvbXBvbmVudHMpXG5cbi8vIHJlZ2lzdGVyIGxvYWRlcnNcbndlZXgucmVnaXN0ZXJMb2FkZXIoJ2xvYWRCeU10b3AnLCBsb2FkQnlNdG9wKVxuXG5nbG9iYWwud2VleCA9IHdlZXhcbm1vZHVsZS5leHBvcnRzID0gd2VleFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hbGl3ZWV4LmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxucmVxdWlyZSgnLi9zdHlsZXMvYmFzZS5jc3MnKVxuXG5yZXF1aXJlKCcuL3BvbHlmaWxsJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpXG52YXIgTG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKVxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG52YXIgcHJvdG9jb2wgPSByZXF1aXJlKCcuL3Byb3RvY29sJylcbnZhciBDb21wb25lbnRNYW5hZ2VyID0gcmVxdWlyZSgnLi9jb21wb25lbnRNYW5hZ2VyJylcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvY29tcG9uZW50JylcbnZhciBTZW5kZXIgPSByZXF1aXJlKCcuL2JyaWRnZS9zZW5kZXInKVxudmFyIHJlY2VpdmVyID0gcmVxdWlyZSgnLi9icmlkZ2UvcmVjZWl2ZXInKVxuXG4vLyBDb21wb25lbnRzIGFuZCBhcGlzLlxudmFyIGNvbXBvbmVudHMgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMnKVxudmFyIGFwaSA9IHJlcXVpcmUoJy4vYXBpJylcbnJlcXVpcmUoJ2VudmQnKVxucmVxdWlyZSgnaHR0cHVybCcpXG5cbnZhciBXRUFQUF9TVFlMRV9JRCA9ICd3ZWFwcC1zdHlsZSdcblxudmFyIERFRkFVTFRfREVTSUdOX1dJRFRIID0gNzUwXG52YXIgREVGQVVMVF9TQ0FMRSA9IHdpbmRvdy5pbm5lcldpZHRoIC8gREVGQVVMVF9ERVNJR05fV0lEVEhcbnZhciBERUZBVUxUX1JPT1RfSUQgPSAnd2VleCdcbnZhciBERUZBVUxUX0pTT05QX0NBTExCQUNLX05BTUUgPSAnd2VleEpzb25wQ2FsbGJhY2snXG5cbndpbmRvdy5XWEVudmlyb25tZW50ID0ge1xuICB3ZWV4VmVyc2lvbjogY29uZmlnLndlZXhWZXJzaW9uLFxuICBhcHBOYW1lOiBsaWIuZW52LmFsaWFwcCA/IGxpYi5lbnYuYWxpYXBwLmFwcG5hbWUgOiBudWxsLFxuICBhcHBWZXJzaW9uOiBsaWIuZW52LmFsaWFwcCA/IGxpYi5lbnYuYWxpYXBwLnZlcnNpb24udmFsIDogbnVsbCxcbiAgcGxhdGZvcm06ICdXZWInLFxuICBvc05hbWU6IGxpYi5lbnYuYnJvd3NlciA/IGxpYi5lbnYuYnJvd3Nlci5uYW1lIDogbnVsbCxcbiAgb3NWZXJzaW9uOiBsaWIuZW52LmJyb3dzZXIgPyBsaWIuZW52LmJyb3dzZXIudmVyc2lvbi52YWwgOiBudWxsLFxuICBkZXZpY2VXaWR0aDogREVGQVVMVF9ERVNJR05fV0lEVEgsXG4gIGRldmljZUhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IC8gREVGQVVMVF9TQ0FMRVxufVxuXG52YXIgX2luc3RhbmNlTWFwID0ge31cbnZhciBfZG93bmdyYWRlcyA9IHt9XG5cbnZhciBkb3duZ3JhZGFibGUgPSBbJ2xpc3QnLCAnc2Nyb2xsZXInXVxuXG47IChmdW5jdGlvbiBpbml0aWFsaXplV2l0aFVybFBhcmFtcygpIHtcblxuICB2YXIgcGFyYW1zID0gbGliLmh0dHB1cmwobG9jYXRpb24uaHJlZikucGFyYW1zXG4gIGZvciAodmFyIGsgaW4gcGFyYW1zKSB7XG4gICAgLy8gR2V0IGdsb2JhbCBfZG93bmdyYWRlcyBmcm9tIHVybCdzIHBhcmFtcy5cbiAgICB2YXIgbWF0Y2ggPSBrLm1hdGNoKC9kb3duZ3JhZGVfKFxcdyspLylcbiAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaFsxXSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKHBhcmFtc1trXSAhPT0gdHJ1ZSAmJiBwYXJhbXNba10gIT09ICd0cnVlJykge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIGRvd25rID0gbWF0Y2hbMV1cbiAgICBpZiAoZG93bmsgJiYgKGRvd25ncmFkYWJsZS5pbmRleE9mKGRvd25rKSAhPT0gLTEpKSB7XG4gICAgICBfZG93bmdyYWRlc1tkb3dua10gPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGdsb2JhbCAnZGVidWcnIGNvbmZpZyB0byB0cnVlIGlmIHRoZXJlJ3MgYSBkZWJ1ZyBmbGFnIGluIGN1cnJlbnQgdXJsLlxuICB2YXIgZGVidWcgPSBwYXJhbXNbJ2RlYnVnJ11cbiAgaWYgKGRlYnVnID09PSB0cnVlIHx8IGRlYnVnID09PSAndHJ1ZScpIHtcbiAgICBjb25maWcuZGVidWcgPSB0cnVlXG4gIH1cblxufSkoKVxuXG5yZXF1aXJlKCcuL2xvZ2dlcicpLmluaXQoKVxuXG5mdW5jdGlvbiBXZWV4KG9wdGlvbnMpIHtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV2VleCkpIHtcbiAgICByZXR1cm4gbmV3IFdlZXgob3B0aW9ucylcbiAgfVxuXG4gIC8vIFdpZHRoIG9mIHRoZSByb290IGNvbnRhaW5lci4gRGVmYXVsdCBpcyB3aW5kb3cuaW5uZXJXaWR0aC5cbiAgdGhpcy53aWR0aCA9IG9wdGlvbnMud2lkdGggfHwgd2luZG93LmlubmVyV2lkdGhcbiAgdGhpcy5idW5kbGVVcmwgPSBvcHRpb25zLmJ1bmRsZVVybCB8fCBsb2NhdGlvbi5ocmVmXG4gIHRoaXMuaW5zdGFuY2VJZCA9IG9wdGlvbnMuYXBwSWRcbiAgdGhpcy5yb290SWQgPSBvcHRpb25zLnJvb3RJZCB8fCAoREVGQVVMVF9ST09UX0lEICsgdXRpbHMuZ2V0UmFuZG9tKDEwKSlcbiAgdGhpcy5kZXNpZ25XaWR0aCA9IG9wdGlvbnMuZGVzaWduV2lkdGggfHwgREVGQVVMVF9ERVNJR05fV0lEVEhcbiAgdGhpcy5qc29ucENhbGxiYWNrID0gb3B0aW9ucy5qc29ucENhbGxiYWNrIHx8IERFRkFVTFRfSlNPTlBfQ0FMTEJBQ0tfTkFNRVxuICB0aGlzLnNvdXJjZSA9IG9wdGlvbnMuc291cmNlXG4gIHRoaXMubG9hZGVyID0gb3B0aW9ucy5sb2FkZXJcbiAgdGhpcy5lbWJlZCA9IG9wdGlvbnMuZW1iZWQgPyB0cnVlIDogZmFsc2VcblxuICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGFcblxuICB0aGlzLmluaXREb3duZ3JhZGVzKG9wdGlvbnMuZG93bmdyYWRlKVxuICB0aGlzLmluaXRTY2FsZSgpXG4gIHRoaXMuaW5pdENvbXBvbmVudE1hbmFnZXIoKVxuICB0aGlzLmluaXRCcmlkZ2UoKVxuICBXZWV4LmFkZEluc3RhbmNlKHRoaXMpXG5cbiAgcHJvdG9jb2wuaW5qZWN0V2VleEluc3RhbmNlKHRoaXMpXG5cbiAgdGhpcy5sb2FkQnVuZGxlKGZ1bmN0aW9uIChlcnIsIGFwcENvZGUpIHtcbiAgICBpZiAoIWVycikge1xuICAgICAgdGhpcy5jcmVhdGVBcHAoY29uZmlnLCBhcHBDb2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdsb2FkIGJ1bmRsZSBlcnI6JywgZXJyKVxuICAgIH1cbiAgfS5iaW5kKHRoaXMpKVxuXG59XG5cbldlZXguaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmICh1dGlscy5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgIG5ldyBXZWV4KGNvbmZpZylcbiAgICB9KVxuICB9IGVsc2UgaWYgKFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGlvbnMpLnNsaWNlKDgsIC0xKSA9PT0gJ09iamVjdCdcbiAgICApIHtcbiAgICBuZXcgV2VleChvcHRpb25zKVxuICB9XG59XG5cbldlZXguYWRkSW5zdGFuY2UgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgX2luc3RhbmNlTWFwW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2Vcbn1cblxuV2VleC5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XG4gIHJldHVybiBfaW5zdGFuY2VNYXBbaW5zdGFuY2VJZF1cbn1cblxuV2VleC5wcm90b3R5cGUgPSB7XG5cbiAgaW5pdERvd25ncmFkZXM6IGZ1bmN0aW9uIChkZykge1xuICAgIHRoaXMuZG93bmdyYWRlcyA9IHV0aWxzLmV4dGVuZCh7fSwgX2Rvd25ncmFkZXMpXG4gICAgLy8gR2V0IGRvd25ncmFkZSBjb21wb25lbnQgdHlwZSBmcm9tIHVzZXIncyBzcGVjaWZpY2F0aW9uXG4gICAgLy8gaW4gd2VleCdzIGluaXQgb3B0aW9ucy5cbiAgICBpZiAoIXV0aWxzLmlzQXJyYXkoZGcpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBkb3duayA9IGRnW2ldXG4gICAgICBpZiAoZG93bmdyYWRhYmxlLmluZGV4T2YoZG93bmspICE9PSAtMSkge1xuICAgICAgICB0aGlzLmRvd25ncmFkZXNbZG93bmtdID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBpbml0QnJpZGdlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmVjZWl2ZXIuaW5pdCh0aGlzKVxuICAgIHRoaXMuc2VuZGVyID0gbmV3IFNlbmRlcih0aGlzKVxuICB9LFxuXG4gIGxvYWRCdW5kbGU6IGZ1bmN0aW9uIChjYikge1xuICAgIExvYWRlci5sb2FkKHtcbiAgICAgIGpzb25wQ2FsbGJhY2s6IHRoaXMuanNvbnBDYWxsYmFjayxcbiAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICBsb2FkZXI6IHRoaXMubG9hZGVyXG4gICAgfSwgY2IpXG4gIH0sXG5cbiAgY3JlYXRlQXBwOiBmdW5jdGlvbiAoY29uZmlnLCBhcHBDb2RlKSB7XG4gICAgdmFyIHJvb3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIHRoaXMucm9vdElkKVxuICAgIGlmICghcm9vdCkge1xuICAgICAgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICByb290LmlkID0gdGhpcy5yb290SWRcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm9vdClcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IHdpbmRvdy5jcmVhdGVJbnN0YW5jZShcbiAgICAgIHRoaXMuaW5zdGFuY2VJZFxuICAgICAgLCBhcHBDb2RlXG4gICAgICAsIHtcbiAgICAgICAgYnVuZGxlVXJsOiB0aGlzLmJ1bmRsZVVybCxcbiAgICAgICAgZGVidWc6IGNvbmZpZy5kZWJ1Z1xuICAgICAgfVxuICAgICAgLCB0aGlzLmRhdGFcbiAgICApXG5cbiAgICBpZiAoUHJvbWlzZSAmJiBwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2VleC5faW5zdGFuY2VzW3RoaXMuaW5zdGFuY2VJZF0gPSB0aGlzLnJvb3RcbiAgICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIGNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIERvIG5vdCBkZXN0cm95IGluc3RhbmNlIGhlcmUsIGJlY2F1c2UgaW4gbW9zdCBicm93c2VyXG4gICAgLy8gcHJlc3MgYmFjayBidXR0b24gdG8gYmFjayB0byB0aGlzIHBhZ2Ugd2lsbCBub3QgcmVmcmVzaFxuICAgIC8vIHRoZSB3aW5kb3cgYW5kIHRoZSBpbnN0YW5jZSB3aWxsIG5vdCBiZSByZWNyZWF0ZWQgdGhlbi5cbiAgICAvLyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAvLyB9KVxuXG4gIH0sXG5cbiAgaW5pdFNjYWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zY2FsZSA9IHRoaXMud2lkdGggLyB0aGlzLmRlc2lnbldpZHRoXG4gIH0sXG5cbiAgaW5pdENvbXBvbmVudE1hbmFnZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jb21wb25lbnRNYW5hZ2VyID0gbmV3IENvbXBvbmVudE1hbmFnZXIodGhpcylcbiAgfSxcblxuICBnZXRDb21wb25lbnRNYW5hZ2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudE1hbmFnZXJcbiAgfSxcblxuICBnZXRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5yb290SWQpXG4gIH1cbn1cblxuV2VleC5hcHBlbmRTdHlsZSA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgdXRpbHMuYXBwZW5kU3R5bGUoY3NzLCBXRUFQUF9TVFlMRV9JRClcbn0sXG5cbi8vIFJlZ2lzdGVyIGEgbmV3IGNvbXBvbmVudCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbldlZXgucmVnaXN0ZXJDb21wb25lbnQgPSBmdW5jdGlvbiAobmFtZSwgY29tcCkge1xuICBDb21wb25lbnRNYW5hZ2VyLnJlZ2lzdGVyQ29tcG9uZW50KG5hbWUsIGNvbXApXG59LFxuXG4vLyBSZWdpc3RlciBhIG5ldyBhcGkgbW9kdWxlLlxuLy8gSWYgdGhlIG1vZHVsZSBhbHJlYWR5IGV4aXN0cywganVzdCBhZGQgbWV0aG9kcyBmcm9tIHRoZVxuLy8gbmV3IG1vZHVsZSB0byB0aGUgb2xkIG9uZS5cbldlZXgucmVnaXN0ZXJBcGlNb2R1bGUgPSBmdW5jdGlvbiAobmFtZSwgbW9kdWxlLCBtZXRhKSB7XG4gIGlmICghcHJvdG9jb2wuYXBpTW9kdWxlW25hbWVdKSB7XG4gICAgcHJvdG9jb2wuYXBpTW9kdWxlW25hbWVdID0gbW9kdWxlXG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIga2V5IGluIG1vZHVsZSkge1xuICAgICAgaWYgKG1vZHVsZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHByb3RvY29sLmFwaU1vZHVsZVtuYW1lXVtrZXldID0gbW9kdWxlW2tleV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gcmVnaXN0ZXIgQVBJIG1vZHVsZSdzIG1ldGEgaW5mbyB0byBqc2ZyYW1ld29ya1xuICBpZiAobWV0YSkge1xuICAgIHByb3RvY29sLnNldEFwaU1vZHVsZU1ldGEobWV0YSlcbiAgICB3aW5kb3cucmVnaXN0ZXJNb2R1bGVzKHByb3RvY29sLmdldEFwaU1vZHVsZU1ldGEobmFtZSksIHRydWUpXG4gIH1cbn0sXG5cbi8vIFJlZ2lzdGVyIGEgbmV3IGFwaSBtZXRob2QgZm9yIHRoZSBzcGVjaWZpZWQgbW9kdWxlLlxuLy8gb3B0czpcbi8vICAtIGFyZ3M6IHR5cGUgb2YgYXJndW1lbnRzIHRoZSBBUEkgbWV0aG9kIHRha2VzIHN1Y2hcbi8vICAgIGFzIFsnc3RyaW5nJywgJ2Z1bmN0aW9uJ11cbldlZXgucmVnaXN0ZXJBcGkgPSBmdW5jdGlvbiAobW9kdWxlTmFtZSwgbmFtZSwgbWV0aG9kLCBhcmdzKSB7XG4gIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFwcm90b2NvbC5hcGlNb2R1bGVbbW9kdWxlTmFtZV0pIHtcbiAgICBwcm90b2NvbC5hcGlNb2R1bGVbbW9kdWxlTmFtZV0gPSB7fVxuICAgIHByb3RvY29sLl9tZXRhW21vZHVsZU5hbWVdID0gW11cbiAgfVxuICBwcm90b2NvbC5hcGlNb2R1bGVbbW9kdWxlTmFtZV1bbmFtZV0gPSBtZXRob2RcbiAgaWYgKCFhcmdzKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gcmVnaXN0ZXIgQVBJIG1ldGEgaW5mbyB0byBqc2ZyYW1ld29ya1xuICBwcm90b2NvbC5zZXRBcGlNZXRhKG1vZHVsZU5hbWUsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGFyZ3M6IGFyZ3NcbiAgfSlcbiAgd2luZG93LnJlZ2lzdGVyTW9kdWxlcyhwcm90b2NvbC5nZXRBcGlNb2R1bGVNZXRhKG1vZHVsZU5hbWUsIG1ldGEpLCB0cnVlKVxufSxcblxuLy8gUmVnaXN0ZXIgYSBuZXcgd2VleC1idW5kbGUtbG9hZGVyLlxuV2VleC5yZWdpc3RlckxvYWRlciA9IGZ1bmN0aW9uIChuYW1lLCBsb2FkZXJGdW5jKSB7XG4gIExvYWRlci5yZWdpc3RlckxvYWRlcihuYW1lLCBsb2FkZXJGdW5jKVxufVxuXG4vLyBUbyBpbnN0YWxsIGNvbXBvbmVudHMgYW5kIHBsdWdpbnMuXG5XZWV4Lmluc3RhbGwgPSBmdW5jdGlvbiAobW9kKSB7XG4gIG1vZC5pbml0KFdlZXgpXG59XG5cbldlZXguc3RvcFRoZVdvcmxkID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpbnN0YW5jZUlkIGluIF9pbnN0YW5jZU1hcCkge1xuICAgIGlmIChfaW5zdGFuY2VNYXAuaGFzT3duUHJvcGVydHkoaW5zdGFuY2VJZCkpIHtcbiAgICAgIHdpbmRvdy5kZXN0cm95SW5zdGFuY2UoaW5zdGFuY2VJZClcbiAgICB9XG4gIH1cbn1cblxuKGZ1bmN0aW9uIHN0YXJ0UmVmcmVzaENvbnRyb2xsZXIoKSB7XG4gIGlmIChsb2NhdGlvbi5zZWFyY2guaW5kZXhPZignaG90LXJlbG9hZF9jb250cm9sbGVyJykgPT09IC0xKSAge1xuICAgIHJldHVyblxuICB9XG4gIGlmICghd2luZG93LldlYlNvY2tldCkge1xuICAgIGNvbnNvbGUuaW5mbygnYXV0byByZWZyZXNoIG5lZWQgV2ViU29ja2V0IHN1cHBvcnQnKVxuICAgIHJldHVyblxuICB9XG4gIHZhciBob3N0ID0gbG9jYXRpb24uaG9zdG5hbWVcbiAgdmFyIHBvcnQgPSA4MDgyXG4gIHZhciBjbGllbnQgPSBuZXcgV2ViU29ja2V0KCd3czovLycgKyBob3N0ICsgJzonICsgcG9ydCArICcvJyxcbiAgICAnZWNoby1wcm90b2NvbCdcbiAgKVxuICBjbGllbnQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZygncmVmcmVzaCBjb250cm9sbGVyIHdlYnNvY2tldCBjb25uZWN0aW9uIGVycm9yJylcbiAgfVxuICBjbGllbnQub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQ6IFxcJycgKyBlLmRhdGEgKyAnXFwnJylcbiAgICBpZiAoZS5kYXRhICA9PT0gJ3JlZnJlc2gnKSB7XG4gICAgICBsb2NhdGlvbi5yZWxvYWQoKVxuICAgIH1cbiAgfVxufSgpKVxuXG4vLyBXZWV4Lmluc3RhbGwocmVxdWlyZSgnd2VleC1jb21wb25lbnRzJykpXG5XZWV4Lmluc3RhbGwoY29tcG9uZW50cylcbldlZXguaW5zdGFsbChhcGkpXG5cbldlZXguQ29tcG9uZW50ID0gQ29tcG9uZW50XG5XZWV4LkNvbXBvbmVudE1hbmFnZXIgPSBDb21wb25lbnRNYW5hZ2VyXG5XZWV4LnV0aWxzID0gdXRpbHNcbldlZXguY29uZmlnID0gY29uZmlnXG5cbmdsb2JhbC53ZWV4ID0gV2VleFxubW9kdWxlLmV4cG9ydHMgPSBXZWV4XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy93ZWV4LmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYmFzZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jhc2UuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9iYXNlLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2Jhc2UuY3NzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIioge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIHRleHQtc2l6ZS1hZGp1c3Q6IG5vbmU7XFxufVxcblxcbnVsLCBvbCB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvYmFzZS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbiAqKiBtb2R1bGUgaWQgPSAxMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMCxcclxuXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XHJcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcclxuXHR9XHJcblxyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxyXG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcclxuXHJcblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cclxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xyXG5cclxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xyXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xyXG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcclxuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYobmV3TGlzdCkge1xyXG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QpO1xyXG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XHJcblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcclxuXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xyXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcclxuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0aWYoZG9tU3R5bGUpIHtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XHJcblx0dmFyIHN0eWxlcyA9IFtdO1xyXG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xyXG5cdFx0dmFyIGlkID0gaXRlbVswXTtcclxuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xyXG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcclxuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xyXG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xyXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXHJcblx0XHRcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcclxuXHR9XHJcblx0cmV0dXJuIHN0eWxlcztcclxufVxyXG5cclxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcclxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xyXG5cdFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XHJcblx0XHRcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgaGVhZC5maXJzdENoaWxkKTtcclxuXHRcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH1cclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcclxuXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXCIpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xyXG5cdHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0dmFyIGlkeCA9IHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGVFbGVtZW50KTtcclxuXHRpZihpZHggPj0gMCkge1xyXG5cdFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCk7XHJcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucykge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdGxpbmtFbGVtZW50LnJlbCA9IFwic3R5bGVzaGVldFwiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XHJcblx0cmV0dXJuIGxpbmtFbGVtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcclxuXHJcblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XHJcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcclxuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xyXG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XHJcblx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcclxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxyXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXHJcblx0XHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XHJcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcclxuXHJcblx0aWYoc291cmNlTWFwKSB7XHJcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxyXG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xyXG5cdH1cclxuXHJcblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XHJcblxyXG5cdHZhciBvbGRTcmMgPSBsaW5rRWxlbWVudC5ocmVmO1xyXG5cclxuXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHJcblx0aWYob2xkU3JjKVxyXG5cdFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJylcblxuaWYgKCF3aW5kb3cuUHJvbWlzZSkge1xuICBsb2dnZXIud2FybignbmF0aXZlIFByb21pc2UgaXMgbWlzc2luZywgdXNpbmcgcG9seWZpbGwgaW5zdGVhZC4nKVxuICByZXF1aXJlKCdlczYtcHJvbWlzZScpXG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvcG9seWZpbGwuanNcbiAqKiBtb2R1bGUgaWQgPSAxNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKVxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5cbnZhciBfaW5pdGlhbGl6ZWQgPSBmYWxzZVxuXG52YXIgbG9nZ2VyID0ge1xuICBsb2c6IGZ1bmN0aW9uICgpIHt9LFxuICB3YXJuOiBmdW5jdGlvbiAoKSB7fSxcbiAgZXJyb3I6IGZ1bmN0aW9uICgpIHt9XG59XG5cbmZ1bmN0aW9uIGhpamFjayhrKSB7XG4gIGlmICh1dGlscy5pc0FycmF5KGspKSB7XG4gICAgay5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGhpamFjayhrZXkpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoY29uc29sZVtrXSkge1xuICAgICAgbG9nZ2VyW2tdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlW2tdLmFwcGx5KFxuICAgICAgICAgIGNvbnNvbGUsXG4gICAgICAgICAgWydbaDUtcmVuZGVyXSddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmxvZ2dlci5pbml0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2luaXRpYWxpemVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgX2luaXRpYWxpemVkID0gdHJ1ZVxuICBpZiAoY29uZmlnLmRlYnVnICYmIGNvbnNvbGUpIHtcbiAgICBoaWphY2soWydsb2cnLCAnd2FybicsICdlcnJvciddKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nZ2VyXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvbG9nZ2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBjb25maWcgPSB7XG5cbiAgd2VleFZlcnNpb246ICcwLjUuMCcsXG5cbiAgZGVidWc6IGZhbHNlXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25maWdcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb25maWcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIFdFQVBQX1NUWUxFX0lEID0gJ3dlYXBwLXN0eWxlJ1xuXG52YXIgX2lzV2VicFN1cHBvcnRlZCA9IGZhbHNlXG5cbjsgKGZ1bmN0aW9uIGlzU3VwcG9ydFdlYnAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHdlYlAgPSBuZXcgSW1hZ2UoKVxuICAgIHdlYlAuc3JjID0gJ2RhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1Jqb0FBQUJYUlVKUVZsQTRJQzRBQUFDeUFnQ2RBJ1xuICAgICAgICAgICAgICArICdTb0NBQUlBTG1rMG1rMGlJaUlpSWdCb1N5Z0FCYzZXV2dBQS92ZWZmLzBQUDhiQS8vTHdZQUFBJ1xuICAgIHdlYlAub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHdlYlAuaGVpZ2h0ID09PSAyKSB7XG4gICAgICAgIF9pc1dlYnBTdXBwb3J0ZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZG8gbm90aGluZy5cbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBleHRlbmQodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1trZXldID0gZnJvbVtrZXldXG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5XG4gICAgPyBBcnJheS5pc0FycmF5KGFycilcbiAgICA6IChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbn1cblxuZnVuY3Rpb24gYXBwZW5kU3R5bGUoY3NzLCBzdHlsZUlkLCByZXBsYWNlKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0eWxlSWQpXG4gIGlmIChzdHlsZSAmJiByZXBsYWNlKSB7XG4gICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSlcbiAgICBzdHlsZSA9IG51bGxcbiAgfVxuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2NzcydcbiAgICBzdHlsZUlkICYmIChzdHlsZS5pZCA9IHN0eWxlSWQpXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZSlcbiAgfVxuICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxufVxuXG5mdW5jdGlvbiBnZXRVbmlxdWVGcm9tQXJyYXkoYXJyKSB7XG4gIGlmICghaXNBcnJheShhcnIpKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHJlcyA9IFtdXG4gIHZhciB1bmlxdWUgPSB7fVxuICB2YXIgdmFsXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhbCA9IGFycltpXVxuICAgIGlmICh1bmlxdWVbdmFsXSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdW5pcXVlW3ZhbF0gPSB0cnVlXG4gICAgcmVzLnB1c2godmFsKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbml6ZShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgdHJhbnNpdGlvbnMgPSBbXVxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB0cmFuc2l0aW9ucy5wdXNoKGtleSArICcgJyArIHByb3BzW2tleV0pXG4gIH1cbiAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbnMuam9pbignLCAnKVxuICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9ucy5qb2luKCcsICcpXG59XG5cbmZ1bmN0aW9uIGRldGVjdFdlYnAoKSB7XG4gIHJldHVybiBfaXNXZWJwU3VwcG9ydGVkXG59XG5cbmZ1bmN0aW9uIGdldFJhbmRvbShudW0pIHtcbiAgdmFyIF9kZWZhdWx0TnVtID0gMTBcbiAgaWYgKHR5cGVvZiBudW0gIT09ICdudW1iZXInIHx8IG51bSA8PSAwKSB7XG4gICAgbnVtID0gX2RlZmF1bHROdW1cbiAgfVxuICB2YXIgX21heCA9IE1hdGgucG93KDEwLCBudW0pXG4gIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgKyBNYXRoLnJhbmRvbSgpICogX21heCkgJSBfbWF4XG59XG5cbmZ1bmN0aW9uIGdldFJnYihjb2xvcikge1xuICB2YXIgbWF0Y2hcbiAgY29sb3IgPSBjb2xvciArICcnXG4gIGlmIChtYXRjaCA9IGNvbG9yLm1hdGNoKC8jKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pLykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogcGFyc2VJbnQobWF0Y2hbMV0sIDE2KSxcbiAgICAgIGc6IHBhcnNlSW50KG1hdGNoWzJdLCAxNiksXG4gICAgICBiOiBwYXJzZUludChtYXRjaFszXSwgMTYpXG4gICAgfVxuICB9XG4gIGlmIChtYXRjaCA9IGNvbG9yLm1hdGNoKC9yZ2JcXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspXFwpLykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcjogcGFyc2VJbnQobWF0Y2hbMV0pLFxuICAgICAgZzogcGFyc2VJbnQobWF0Y2hbMl0pLFxuICAgICAgYjogcGFyc2VJbnQobWF0Y2hbM10pXG4gICAgfVxuICB9XG59XG5cbi8vIGRpcmVjdGlvbjogJ2wnIHwgJ3InLCBkZWZhdWx0IGlzICdyJ1xuLy8gbnVtOiBob3cgbWFueSB0aW1lcyB0byBsb29wLCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyXG5mdW5jdGlvbiBsb29wQXJyYXkoYXJyLCBudW0sIGRpcmVjdGlvbikge1xuICBpZiAoIWlzQXJyYXkoYXJyKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBpc0xlZnQgPSAoZGlyZWN0aW9uICsgJycpLnRvTG93ZXJDYXNlKCkgPT09ICdsJ1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aFxuICBudW0gPSBudW0gJSBsZW5cbiAgaWYgKG51bSA8IDApIHtcbiAgICBudW0gPSAtbnVtXG4gICAgaXNMZWZ0ID0gIWlzTGVmdFxuICB9XG4gIGlmIChudW0gPT09IDApIHtcbiAgICByZXR1cm4gYXJyXG4gIH1cbiAgdmFyIHJlcywgbHAsIHJwXG4gIGlmIChpc0xlZnQpIHtcbiAgICBscCA9IGFyci5zbGljZSgwLCBudW0pXG4gICAgcnAgPSBhcnIuc2xpY2UobnVtKVxuICB9IGVsc2Uge1xuICAgIGxwID0gYXJyLnNsaWNlKDAsIGxlbiAtIG51bSlcbiAgICBycCA9IGFyci5zbGljZShsZW4gLSBudW0pXG4gIH1cbiAgcmV0dXJuIHJwLmNvbmNhdChscClcbn1cblxuLy8gcGFkIGEgaW50ZWdlciBudW1iZXIgd2l0aCB6ZXJvcyBvbiB0aGUgbGVmdC5cbi8vIGV4YW1wbGU6IGZpbGxJbnQoMTIsIDMpIC0+ICcwMTInXG4vLyAtIG51bTogdGhlIG51bWJlciB0byBwYWRcbi8vIC0gbGVuOiB0aGUgc3BlY2lmaWVkIGxlbmd0aFxuZnVuY3Rpb24gbGVmdFBhZChudW0sIGxlbikge1xuICBpZiAobGVuIDw9IDApIHtcbiAgICByZXR1cm4gbnVtXG4gIH1cbiAgdmFyIG51bUxlbiA9IChudW0gKyAnJykubGVuZ3RoXG4gIGlmIChudW1MZW4gPj0gbGVuKSB7XG4gICAgcmV0dXJuIG51bVxuICB9XG4gIHJldHVybiBuZXcgQXJyYXkobGVuIC0gbnVtTGVuICsgMSkuam9pbignMCcpICsgbnVtXG59XG5cbi8vIGdldCBEYXRlU3RyIHdpdGggc3BlY2lmaWVkIHNlcGFyYXRvciBsaWtlICcyMDE2LTA2LTAzJ1xuZnVuY3Rpb24gZ2V0RGF0ZVN0cihzZXBhcmF0b3IpIHtcbiAgdmFyIGR0ID0gbmV3IERhdGUoKVxuICB2YXIgeSA9IGR0LmdldEZ1bGxZZWFyKClcbiAgdmFyIG0gPSBsZWZ0UGFkKGR0LmdldE1vbnRoKCkgKyAxLCAyKVxuICB2YXIgZCA9IGxlZnRQYWQoZHQuZ2V0RGF0ZSgpLCAyKVxuICByZXR1cm4gW3ksIG0sIGRdLmpvaW4oc2VwYXJhdG9yIHx8ICcnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGFwcGVuZFN0eWxlOiBhcHBlbmRTdHlsZSxcbiAgZ2V0VW5pcXVlRnJvbUFycmF5OiBnZXRVbmlxdWVGcm9tQXJyYXksXG4gIHRyYW5zaXRpb25pemU6IHRyYW5zaXRpb25pemUsXG4gIGRldGVjdFdlYnA6IGRldGVjdFdlYnAsXG4gIGdldFJhbmRvbTogZ2V0UmFuZG9tLFxuICBnZXRSZ2I6IGdldFJnYixcbiAgbG9vcEFycmF5OiBsb29wQXJyYXksXG4gIGxlZnRQYWQ6IGxlZnRQYWQsXG4gIGdldERhdGVTdHI6IGdldERhdGVTdHJcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy91dGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBsb2FkQnlYSFIoY29uZmlnLCBjYWxsYmFjaykge1xuICBpZiAoIWNvbmZpZy5zb3VyY2UpIHtcbiAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ3hociBsb2FkZXI6IG1pc3NpbmcgY29uZmlnLnNvdXJjZS4nKSlcbiAgfVxuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgeGhyLm9wZW4oJ0dFVCcsIGNvbmZpZy5zb3VyY2UpXG4gIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgdGhpcy5yZXNwb25zZVRleHQpXG4gIH1cbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBjYWxsYmFjayhlcnJvcilcbiAgfVxuICB4aHIuc2VuZCgpXG59XG5cbmZ1bmN0aW9uIGxvYWRCeUpzb25wKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgaWYgKCFjb25maWcuc291cmNlKSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKCdqc29ucCBsb2FkZXI6IG1pc3NpbmcgY29uZmlnLnNvdXJjZS4nKSlcbiAgfVxuICB2YXIgY2FsbGJhY2tOYW1lID0gY29uZmlnLmpzb25wQ2FsbGJhY2sgfHwgJ3dlZXhKc29ucENhbGxiYWNrJ1xuICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgaWYgKGNvZGUpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGNvZGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignbG9hZCBieSBqc29ucCBlcnJvcicpKVxuICAgIH1cbiAgfVxuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgc2NyaXB0LnNyYyA9IGRlY29kZVVSSUNvbXBvbmVudChjb25maWcuc291cmNlKVxuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KVxufVxuXG5mdW5jdGlvbiBsb2FkQnlTb3VyY2VDb2RlKGNvbmZpZywgY2FsbGJhY2spIHtcbiAgLy8gc3JjIGlzIHRoZSBqc2J1bmRsZS5cbiAgLy8gbm8gbmVlZCB0byBmZXRjaCBmcm9tIGFueXdoZXJlLlxuICBpZiAoY29uZmlnLnNvdXJjZSkge1xuICAgIGNhbGxiYWNrKG51bGwsIGNvbmZpZy5zb3VyY2UpXG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKCdzb3VyY2UgY29kZSBsYW9kZXI6IG1pc3NpbmcgY29uZmlnLnNvdXJjZS4nKSlcbiAgfVxufVxuXG52YXIgY2FsbGJhY2tNYXAgPSB7XG4gIHhocjogbG9hZEJ5WEhSLFxuICBqc29ucDogbG9hZEJ5SnNvbnAsXG4gIHNvdXJjZTogbG9hZEJ5U291cmNlQ29kZVxufVxuXG5mdW5jdGlvbiBsb2FkKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBsb2FkRm4gPSBjYWxsYmFja01hcFtvcHRpb25zLmxvYWRlcl1cbiAgbG9hZEZuKG9wdGlvbnMsIGNhbGxiYWNrKVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckxvYWRlcihuYW1lLCBsb2FkZXJGdW5jKSB7XG4gIGlmICh0eXBlb2YgbG9hZGVyRnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrTWFwW25hbWVdID0gbG9hZGVyRnVuY1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb2FkOiBsb2FkLFxuICByZWdpc3RlckxvYWRlcjogcmVnaXN0ZXJMb2FkZXJcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2xvYWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDE4XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi91dGlscycpLmV4dGVuZFxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL3V0aWxzJykuaXNBcnJheVxudmFyIENvbXBvbmVudE1hbmFnZXIgPSByZXF1aXJlKCcuL2NvbXBvbmVudE1hbmFnZXInKVxuXG4vLyBmb3IganNmcmFtZXdvcmsgdG8gcmVnaXN0ZXIgbW9kdWxlcy5cbnZhciBfcmVnaXN0ZXJNb2R1bGVzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICBpZiAoaXNBcnJheShjb25maWcpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb25maWcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB3aW5kb3cucmVnaXN0ZXJNb2R1bGVzKGNvbmZpZ1tpXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LnJlZ2lzdGVyTW9kdWxlcyhjb25maWcpXG4gIH1cbn1cblxudmFyIHByb3RvY29sID0ge1xuXG4gIC8vIHdlZXggaW5zdGFuY2VzXG4gIF9pbnN0YW5jZXM6IHt9LFxuXG4gIC8vIGFwaSBtZXRhIGluZm9cbiAgX21ldGE6IHt9LFxuXG4gIC8vIFdlZXgucmVnaXN0ZXJBcGlNb2R1bGUgdXNlZCB0aGlzIHRvIHJlZ2lzdGVyIGFuZCBhY2Nlc3MgYXBpTW9kdWxlcy5cbiAgYXBpTW9kdWxlOiB7fSxcblxuICBpbmplY3RXZWV4SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHRoaXMuX2luc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlXG4gIH0sXG5cbiAgZ2V0V2VleEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2VJZCkge1xuICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZXNbaW5zdGFuY2VJZF1cbiAgfSxcblxuICAvLyBnZXQgdGhlIGFwaSBtZXRob2QgbWV0YSBpbmZvIGFycmF5IGZvciB0aGUgbW9kdWxlLlxuICBnZXRBcGlNb2R1bGVNZXRhOiBmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xuICAgIHZhciBtZXRhT2JqID0ge31cbiAgICBtZXRhT2JqW21vZHVsZU5hbWVdID0gdGhpcy5fbWV0YVttb2R1bGVOYW1lXVxuICAgIHJldHVybiBtZXRhT2JqXG4gIH0sXG5cbiAgLy8gU2V0IG1ldGEgaW5mbyBmb3IgYSBhcGkgbW9kdWxlLlxuICAvLyBJZiB0aGVyZSBpcyBhIHNhbWUgbmFtZWQgYXBpLCBqdXN0IHJlcGxhY2UgaXQuXG4gIC8vIG9wdHM6XG4gIC8vIC0gbWV0YU9iajogbWV0YSBvYmplY3QgbGlrZVxuICAvLyB7XG4gIC8vICAgIGRvbTogW3tcbiAgLy8gICAgICBuYW1lOiAnYWRkRWxlbWVudCcsXG4gIC8vICAgICAgYXJnczogWydzdHJpbmcnLCAnb2JqZWN0J11cbiAgLy8gICAgfV1cbiAgLy8gfVxuICBzZXRBcGlNb2R1bGVNZXRhOiBmdW5jdGlvbiAobWV0YU9iaikge1xuICAgIHZhciBtb2R1bGVOYW1lXG4gICAgZm9yICh2YXIgayBpbiBtZXRhT2JqKSB7XG4gICAgICBpZiAobWV0YU9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICBtb2R1bGVOYW1lID0ga1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWV0YUFycmF5ID0gdGhpcy5fbWV0YVttb2R1bGVOYW1lXVxuICAgIGlmICghbWV0YUFycmF5KSB7XG4gICAgICB0aGlzLl9tZXRhW21vZHVsZU5hbWVdID0gbWV0YU9ialttb2R1bGVOYW1lXVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmFtZU9iaiA9IHt9XG4gICAgICBtZXRhT2JqW21vZHVsZU5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGFwaSkge1xuICAgICAgICBuYW1lT2JqW2FwaS5uYW1lXSA9IGFwaVxuICAgICAgfSlcbiAgICAgIG1ldGFBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChhcGksIGkpIHtcbiAgICAgICAgaWYgKG5hbWVPYmpbYXBpLm5hbWVdKSB7XG4gICAgICAgICAgbWV0YUFycmF5W2ldID0gbmFtZU9ialthcGkubmFtZV1cbiAgICAgICAgICBkZWxldGUgbmFtZU9ialthcGkubmFtZV1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGZvciAodmFyIGsgaW4gbWV0YU9iaikge1xuICAgICAgICBpZiAobWV0YU9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgIG1ldGFBcnJheS5wdXNoKG1ldGFPYmpba10pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbWV0YVttb2R1bGVOYW1lXSA9IG1ldGFPYmpbbW9kdWxlTmFtZV1cbiAgfSxcblxuICAvLyBTZXQgbWV0YSBpbmZvIGZvciBhIHNpbmdsZSBhcGkuXG4gIC8vIG9wdHM6XG4gIC8vICAtIG1vZHVsZU5hbWU6IGFwaSBtb2R1bGUgbmFtZS5cbiAgLy8gIC0gbWV0YTogYSBtZXRhIG9iamVjdCBsaWtlOlxuICAvLyAge1xuICAvLyAgICBuYW1lOiAnYWRkRWxlbWVudCcsXG4gIC8vICAgIGFyZ3M6IFsnc3RyaW5nJywgJ29iamVjdCddXG4gIC8vICB9XG4gIHNldEFwaU1ldGE6IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBtZXRhKSB7XG4gICAgdmFyIG1ldGFBcnJheSA9IHRoaXMuX21ldGFbbW9kdWxlTmFtZV1cbiAgICBpZiAoIW1ldGFBcnJheSkge1xuICAgICAgdGhpcy5fbWV0YVttb2R1bGVOYW1lXSA9IFttZXRhXVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWV0YUlkeCA9IC0xXG4gICAgICBtZXRhQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoYXBpLCBpKSB7XG4gICAgICAgIGlmIChtZXRhLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBtZXRhSWR4ID0gaVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYgKG1ldGFJZHggIT09IC0xKSB7XG4gICAgICAgIG1ldGFBcnJheVttZXRhSWR4XSA9IG1ldGFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFBcnJheS5wdXNoKG1ldGEpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbl9yZWdpc3Rlck1vZHVsZXMoW3tcbiAgbW9kYWw6IFt7XG4gICAgbmFtZTogJ3RvYXN0JyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAnYWxlcnQnLFxuICAgIGFyZ3M6IFsnb2JqZWN0JywgJ2Z1bmN0aW9uJ11cbiAgfSwge1xuICAgIG5hbWU6ICdjb25maXJtJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAncHJvbXB0JyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH1dXG59LCB7XG4gIGFuaW1hdGlvbjogW3tcbiAgICBuYW1lOiAndHJhbnNpdGlvbicsXG4gICAgYXJnczogWydzdHJpbmcnLCAnb2JqZWN0JywgJ2Z1bmN0aW9uJ11cbiAgfV1cbn1dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3RvY29sXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9wcm90b2NvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKVxudmFyIEZyYW1lVXBkYXRlciA9IHJlcXVpcmUoJy4vZnJhbWVVcGRhdGVyJylcbnZhciBBcHBlYXJXYXRjaGVyID0gcmVxdWlyZSgnLi9hcHBlYXJXYXRjaGVyJylcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxudmFyIExhenlMb2FkID0gcmVxdWlyZSgnLi9sYXp5TG9hZCcpXG52YXIgYW5pbWF0aW9uID0gcmVxdWlyZSgnLi9hbmltYXRpb24nKVxuXG52YXIgUkVOREVSSU5HX0lOREVOVCA9IDgwMFxuXG52YXIgX2luc3RhbmNlTWFwID0ge31cbnZhciB0eXBlTWFwID0ge31cbnZhciBzY3JvbGxhYmxlVHlwZXMgPSBbXG4gICdzY3JvbGxlcicsXG4gICdoc2Nyb2xsZXInLFxuICAndnNjcm9sbGVyJyxcbiAgJ2xpc3QnLFxuICAnaGxpc3QnLFxuICAndmxpc3QnXG5dXG5cbmZ1bmN0aW9uIENvbXBvbmVudE1hbmFnZXIoaW5zdGFuY2UpIHtcbiAgdGhpcy5pbnN0YW5jZUlkID0gaW5zdGFuY2UuaW5zdGFuY2VJZFxuICB0aGlzLndlZXhJbnN0YW5jZSA9IGluc3RhbmNlXG4gIHRoaXMuY29tcG9uZW50TWFwID0ge31cbiAgX2luc3RhbmNlTWFwW3RoaXMuaW5zdGFuY2VJZF0gPSB0aGlzXG59XG5cbkNvbXBvbmVudE1hbmFnZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoaW5zdGFuY2VJZCkge1xuICByZXR1cm4gX2luc3RhbmNlTWFwW2luc3RhbmNlSWRdXG59XG5cbkNvbXBvbmVudE1hbmFnZXIuZ2V0V2VleEluc3RhbmNlID0gZnVuY3Rpb24gKGluc3RhbmNlSWQpIHtcbiAgcmV0dXJuIF9pbnN0YW5jZU1hcFtpbnN0YW5jZUlkXS53ZWV4SW5zdGFuY2Vcbn1cblxuQ29tcG9uZW50TWFuYWdlci5yZWdpc3RlckNvbXBvbmVudCA9IGZ1bmN0aW9uICh0eXBlLCBkZWZpbml0aW9uKSB7XG4gIHR5cGVNYXBbdHlwZV0gPSBkZWZpbml0aW9uXG59XG5cbkNvbXBvbmVudE1hbmFnZXIuZ2V0U2Nyb2xsYWJsZVR5cGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc2Nyb2xsYWJsZVR5cGVzXG59XG5cbkNvbXBvbmVudE1hbmFnZXIucHJvdG90eXBlID0ge1xuXG4gIC8vIEZpcmUgYSBldmVudCAncmVuZGVyYmVnaW4nLydyZW5kZXJlbmQnIG9uIGJvZHkgZWxlbWVudC5cbiAgcmVuZGVyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX3JlbmRlcmluZ0VuZCgpIHtcbiAgICAgIC8vIGdldCB3ZWV4IGluc3RhbmNlIHJvb3RcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgncmVuZGVyZW5kJykpXG4gICAgICB0aGlzLl9yZW5kZXJpbmdUaW1lciA9IG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlbmRlcmluZ1RpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVuZGVyaW5nVGltZXIpXG4gICAgICB0aGlzLl9yZW5kZXJpbmdUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgIF9yZW5kZXJpbmdFbmQuYmluZCh0aGlzKSxcbiAgICAgICAgUkVOREVSSU5HX0lOREVOVFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3JlbmRlcmJlZ2luJykpXG4gICAgICB0aGlzLl9yZW5kZXJpbmdUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgIF9yZW5kZXJpbmdFbmQuYmluZCh0aGlzKSxcbiAgICAgICAgUkVOREVSSU5HX0lOREVOVFxuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICBnZXRFbGVtZW50QnlSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICB9LFxuXG4gIHJlbW92ZUVsZW1lbnRCeVJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBjbXBcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICBpZiAoIXJlZiB8fCAhKGNtcCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVtb3ZlIGZyb20gdGhpcy5jb21wb25lbnRNYXAgY3Vyc2l2ZWx5XG4gICAgKGZ1bmN0aW9uIF9yZW1vdmVDdXJzaXZlbHkoX3JlZikge1xuICAgICAgdmFyIGNoaWxkID0gc2VsZi5jb21wb25lbnRNYXBbX3JlZl1cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjaGlsZC5fbGlzdGVuZXJzXG4gICAgICB2YXIgY2hpbGRyZW4gPSBjaGlsZC5kYXRhLmNoaWxkcmVuXG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgX3JlbW92ZUN1cnNpdmVseShjaGlsZHJlbltpXS5yZWYpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHJlbW92ZSBldmVudHMgZnJvbSBfcmVmIGNvbXBvbmVudFxuICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICBmb3IgKHZhciB0eXBlIGluIGxpc3RlbmVycykge1xuICAgICAgICAgIGNoaWxkLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbdHlwZV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBjaGlsZC5fbGlzdGVuZXJzXG4gICAgICBkZWxldGUgY2hpbGQubm9kZS5fbGlzdGVuZXJzXG4gICAgICAvLyByZW1vdmUgX3JlZiBjb21wb25lbnRcbiAgICAgIGRlbGV0ZSBzZWxmLmNvbXBvbmVudE1hcFtfcmVmXVxuICAgIH0pKHJlZilcblxuICB9LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uIChkYXRhLCBub2RlVHlwZSkge1xuICAgIHZhciBDb21wb25lbnRUeXBlID0gdHlwZU1hcFtkYXRhLnR5cGVdXG4gICAgaWYgKCFDb21wb25lbnRUeXBlKSB7XG4gICAgICBDb21wb25lbnRUeXBlID0gdHlwZU1hcFsnY29udGFpbmVyJ11cbiAgICB9XG5cbiAgICB2YXIgcmVmID0gZGF0YS5yZWZcbiAgICB2YXIgY29tcG9uZW50ID0gbmV3IENvbXBvbmVudFR5cGUoZGF0YSwgbm9kZVR5cGUpXG5cbiAgICB0aGlzLmNvbXBvbmVudE1hcFtyZWZdID0gY29tcG9uZW50XG4gICAgY29tcG9uZW50Lm5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXJlZicsIHJlZilcblxuICAgIHJldHVybiBjb21wb25lbnRcbiAgfSxcblxuICAvKipcbiAgICogY3JlYXRlQm9keTogZ2VuZXJhdGUgcm9vdCBjb21wb25lbnRcbiAgICogQHBhcmFtICB7b2JqZWN0fSBlbGVtZW50XG4gICAqL1xuICBjcmVhdGVCb2R5OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXG4gICAgLy8gVE9ETzogY3JlYXRib2R5IG9uIGRvY3VtZW50LmJvZHlcbiAgICAvLyBubyBuZWVkIHRvIGNyZWF0ZSBhIGV4dHJhIGRpdlxuICAgIHZhciByb290LCBib2R5LCBub2RlVHlwZVxuICAgIGlmICh0aGlzLmNvbXBvbmVudE1hcFsnX3Jvb3QnXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbm9kZVR5cGUgPSBlbGVtZW50LnR5cGVcbiAgICBlbGVtZW50LnR5cGUgPSAncm9vdCdcbiAgICBlbGVtZW50LnJvb3RJZCA9IHRoaXMud2VleEluc3RhbmNlLnJvb3RJZFxuICAgIGVsZW1lbnQucmVmID0gJ19yb290J1xuXG4gICAgdmFyIHJvb3QgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoZWxlbWVudCwgbm9kZVR5cGUpXG4gICAgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy53ZWV4SW5zdGFuY2Uucm9vdElkKVxuICAgICAgICAgIHx8IGRvY3VtZW50LmJvZHlcbiAgICBib2R5LmFwcGVuZENoaWxkKHJvb3Qubm9kZSlcbiAgICByb290Ll9hcHBlbmRlZCA9IHRydWVcbiAgfSxcblxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24gKHBhcmVudFJlZiwgZGF0YSkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtwYXJlbnRSZWZdXG5cbiAgICBpZiAodGhpcy5jb21wb25lbnRNYXBbZGF0YS5yZWZdIHx8ICFwYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChwYXJlbnRSZWYgPT09ICdfcm9vdCcgJiYgIXBhcmVudCkge1xuICAgICAgcGFyZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KHtcbiAgICAgICAgdHlwZTogJ3Jvb3QnLFxuICAgICAgICByb290SWQ6IHRoaXMud2VleEluc3RhbmNlLnJvb3RJZCxcbiAgICAgICAgcmVmOiAnX3Jvb3QnXG4gICAgICB9KVxuICAgICAgcGFyZW50Ll9hcHBlbmRlZCA9IHRydWVcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBwYXJlbnQuYXBwZW5kQ2hpbGQoZGF0YSlcblxuICAgIC8vIEluIHNvbWUgcGFyZW50IGNvbXBvbmVudCB0aGUgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kXG4gICAgLy8gYXBwZW5kQ2hpbGQgZGlkbid0IHJldHVybiB0aGUgY29tcG9uZW50IGF0IGFsbCwgdGhlcmVmb3JcbiAgICAvLyBjaGlsZCBtYXliZSBhIHVuZGVmaW5lZCBvYmplY3QuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBjaGlsZC5wYXJlbnRSZWYgPSBwYXJlbnRSZWZcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgJiYgcGFyZW50Ll9hcHBlbmRlZCkge1xuICAgICAgdGhpcy5oYW5kbGVBcHBlbmQoY2hpbGQpXG4gICAgfVxuICB9LFxuXG4gIGFwcGVuZENoaWxkcmVuOiBmdW5jdGlvbiAocmVmLCBlbGVtZW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQocmVmLCBlbGVtZW50c1tpXSlcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtyZWZdXG5cbiAgICAvLyBmaXJlIGV2ZW50IGZvciByZW5kZXJpbmcgZG9tIG9uIGJvZHkgZWxtZW50LlxuICAgIHRoaXMucmVuZGVyaW5nKClcblxuICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnBhcmVudFJlZikge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuY29tcG9uZW50TWFwW2NvbXBvbmVudC5wYXJlbnRSZWZdXG4gICAgICBjb21wb25lbnQub25SZW1vdmUgJiYgY29tcG9uZW50Lm9uUmVtb3ZlKClcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjb21wb25lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybigncmVmOiAnLCByZWYpXG4gICAgfVxuICB9LFxuXG4gIG1vdmVFbGVtZW50OiBmdW5jdGlvbiAocmVmLCBwYXJlbnRSZWYsIGluZGV4KSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICB2YXIgbmV3UGFyZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcGFyZW50UmVmXVxuICAgIHZhciBvbGRQYXJlbnRSZWYgPSBjb21wb25lbnQucGFyZW50UmVmXG4gICAgdmFyIGNoaWxkcmVuLCBiZWZvcmUsIGksIGxcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhbmV3UGFyZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ3JlZjogJywgcmVmKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlyZSBldmVudCBmb3IgcmVuZGVyaW5nLlxuICAgIHRoaXMucmVuZGVyaW5nKClcblxuICAgIGlmIChpbmRleCA8IC0xKSB7XG4gICAgICBpbmRleCA9IC0xXG4gICAgICBjb25zb2xlLndhcm4oJ2luZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gLTEuJylcbiAgICB9XG5cbiAgICBjaGlsZHJlbiA9IG5ld1BhcmVudC5kYXRhLmNoaWxkcmVuXG4gICAgaWYgKGNoaWxkcmVuXG4gICAgICAgICYmIGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAmJiBpbmRleCAhPT0gLTFcbiAgICAgICAgJiYgaW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGJlZm9yZSA9IHRoaXMuY29tcG9uZW50TWFwW25ld1BhcmVudC5kYXRhLmNoaWxkcmVuW2luZGV4XS5yZWZdXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGZyb20gb2xkUGFyZW50LmRhdGEuY2hpbGRyZW5cbiAgICBpZiAob2xkUGFyZW50UmVmICYmIHRoaXMuY29tcG9uZW50TWFwW29sZFBhcmVudFJlZl0pIHtcbiAgICAgIGNoaWxkcmVuID0gdGhpcy5jb21wb25lbnRNYXBbb2xkUGFyZW50UmVmXS5kYXRhLmNoaWxkcmVuXG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5baV0ucmVmID09PSByZWYpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsID4gaSkge1xuICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAxKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV3UGFyZW50Lmluc2VydEJlZm9yZShjb21wb25lbnQsIGJlZm9yZSlcblxuICAgIGNvbXBvbmVudC5vbk1vdmUgJiYgY29tcG9uZW50Lm9uTW92ZShwYXJlbnRSZWYsIGluZGV4KVxuXG4gIH0sXG5cbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAocmVmLCBkYXRhKSB7XG4gICAgdmFyIGNoaWxkLCBiZWZvcmUsIHBhcmVudFxuICAgIGJlZm9yZSA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICBjaGlsZCA9IHRoaXMuY29tcG9uZW50TWFwW2RhdGEucmVmXVxuICAgIGJlZm9yZSAmJiAocGFyZW50ID0gdGhpcy5jb21wb25lbnRNYXBbYmVmb3JlLnBhcmVudFJlZl0pXG4gICAgaWYgKGNoaWxkIHx8ICFwYXJlbnQgfHwgIWJlZm9yZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2hpbGQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoZGF0YSlcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLnBhcmVudFJlZiA9IGJlZm9yZS5wYXJlbnRSZWZcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29tcG9uZW50TWFwW2JlZm9yZS5wYXJlbnRSZWZdLl9hcHBlbmRlZCkge1xuICAgICAgdGhpcy5oYW5kbGVBcHBlbmQoY2hpbGQpXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBhZGRFbGVtZW50XG4gICAqIElmIGluZGV4IGlzIGxhcmdldCB0aGFuIGFueSBjaGlsZCdzIGluZGV4LCB0aGVcbiAgICogZWxlbWVudCB3aWxsIGJlIGFwcGVuZGVkIGJlaGluZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFJlZlxuICAgKiBAcGFyYW0ge29ian0gZWxlbWVudCAoZGF0YSBvZiB0aGUgY29tcG9uZW50KVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIGFkZEVsZW1lbnQ6IGZ1bmN0aW9uIChwYXJlbnRSZWYsIGVsZW1lbnQsIGluZGV4KSB7XG4gICAgdmFyIHBhcmVudCwgY2hpbGRyZW4sIGJlZm9yZVxuXG4gICAgLy8gZmlyZSBldmVudCBmb3IgcmVuZGVyaW5nIGRvbSBvbiBib2R5IGVsbWVudC5cbiAgICB0aGlzLnJlbmRlcmluZygpXG5cbiAgICBwYXJlbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtwYXJlbnRSZWZdXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjaGlsZHJlbiA9IHBhcmVudC5kYXRhLmNoaWxkcmVuXG4gICAgLy8gLTEgbWVhbnMgYXBwZW5kIGFzIHRoZSBsYXN0LlxuICAgIGlmIChpbmRleCA8IC0xKSB7XG4gICAgICBpbmRleCA9IC0xXG4gICAgICBjb25zb2xlLndhcm4oJ2luZGV4IGNhbm5vdCBiZSBsZXNzIHRoYW4gLTEuJylcbiAgICB9XG4gICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAmJiBjaGlsZHJlbi5sZW5ndGggPiBpbmRleFxuICAgICAgICAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGNoaWxkcmVuW2luZGV4XS5yZWYsIGVsZW1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQocGFyZW50UmVmLCBlbGVtZW50KVxuICAgIH1cbiAgfSxcblxuICBjbGVhckNoaWxkcmVuOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICBjb21wb25lbnQubm9kZS5pbm5lckhUTUwgPSAnJ1xuICAgICAgaWYgKGNvbXBvbmVudC5kYXRhKSB7XG4gICAgICAgIGNvbXBvbmVudC5kYXRhLmNoaWxkcmVuID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBhZGRFdmVudDogZnVuY3Rpb24gKHJlZiwgdHlwZSkge1xuICAgIHZhciBjb21wb25lbnRcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHJlZiA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50TWFwW3JlZl1cbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZWYpLnNsaWNlKDgsIC0xKSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIGNvbXBvbmVudCA9IHJlZlxuICAgICAgcmVmID0gY29tcG9uZW50LmRhdGEucmVmXG4gICAgfVxuICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50Lm5vZGUpIHtcbiAgICAgIHZhciBzZW5kZXIgPSB0aGlzLndlZXhJbnN0YW5jZS5zZW5kZXJcbiAgICAgIHZhciBsaXN0ZW5lciA9IHNlbmRlci5maXJlRXZlbnQuYmluZChzZW5kZXIsIHJlZiwgdHlwZSlcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjb21wb25lbnQuX2xpc3RlbmVyc1xuICAgICAgY29tcG9uZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZmFsc2UsIGZhbHNlKVxuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXJzID0gY29tcG9uZW50Ll9saXN0ZW5lcnMgPSB7fVxuICAgICAgICBjb21wb25lbnQubm9kZS5fbGlzdGVuZXJzID0ge31cbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyXG4gICAgICBjb21wb25lbnQubm9kZS5fbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXJcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnQ6IGZ1bmN0aW9uIChyZWYsIHR5cGUpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICAgIHZhciBsaXN0ZW5lciA9IGNvbXBvbmVudC5fbGlzdGVuZXJzW3R5cGVdXG4gICAgaWYgKGNvbXBvbmVudCAmJiBsaXN0ZW5lcikge1xuICAgICAgY29tcG9uZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcilcbiAgICAgIGNvbXBvbmVudC5fbGlzdGVuZXJzW3R5cGVdID0gbnVsbFxuICAgICAgY29tcG9uZW50Lm5vZGUuX2xpc3RlbmVyc1t0eXBlXSA9IG51bGxcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlQXR0cnM6IGZ1bmN0aW9uIChyZWYsIGF0dHIpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIGNvbXBvbmVudC51cGRhdGVBdHRycyhhdHRyKVxuICAgICAgaWYgKGNvbXBvbmVudC5kYXRhLnR5cGUgPT09ICdpbWFnZScgJiYgYXR0ci5zcmMpIHtcbiAgICAgICAgTGF6eUxvYWQuc3RhcnRJZk5lZWRlZChjb21wb25lbnQpXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiAocmVmLCBzdHlsZSkge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtyZWZdXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgY29tcG9uZW50LnVwZGF0ZVN0eWxlKHN0eWxlKVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGVGdWxsQXR0cnM6IGZ1bmN0aW9uIChyZWYsIGF0dHIpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnRNYXBbcmVmXVxuICAgIGlmIChjb21wb25lbnQpIHtcbiAgICAgIGNvbXBvbmVudC5jbGVhckF0dHIoKVxuICAgICAgY29tcG9uZW50LnVwZGF0ZUF0dHJzKGF0dHIpXG4gICAgICBpZiAoY29tcG9uZW50LmRhdGEudHlwZSA9PT0gJ2ltYWdlJyAmJiBhdHRyLnNyYykge1xuICAgICAgICBMYXp5TG9hZC5zdGFydElmTmVlZGVkKGNvbXBvbmVudClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlRnVsbFN0eWxlOiBmdW5jdGlvbiAocmVmLCBzdHlsZSkge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtyZWZdXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgY29tcG9uZW50LmNsZWFyU3R5bGUoKVxuICAgICAgY29tcG9uZW50LnVwZGF0ZVN0eWxlKHN0eWxlKVxuICAgIH1cbiAgfSxcblxuICBoYW5kbGVBcHBlbmQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBjb21wb25lbnQuX2FwcGVuZGVkID0gdHJ1ZVxuICAgIGNvbXBvbmVudC5vbkFwcGVuZCAmJiBjb21wb25lbnQub25BcHBlbmQoKVxuXG4gICAgLy8gaW52b2tlIG9uQXBwZW5kIG9uIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5XG4gICAgdmFyIGNoaWxkcmVuID0gY29tcG9uZW50LmRhdGEuY2hpbGRyZW5cbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jb21wb25lbnRNYXBbY2hpbGRyZW5baV0ucmVmXVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZUFwcGVuZChjaGlsZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdhdGNoIGFwcGVhci9kaXNhcHBlYXIgb2YgdGhlIGNvbXBvbmVudCBpZiBuZWVkZWRcbiAgICBBcHBlYXJXYXRjaGVyLndhdGNoSWZOZWVkZWQoY29tcG9uZW50KVxuXG4gICAgLy8gZG8gbGF6eWxvYWQgaWYgbmVlZGVkXG4gICAgTGF6eUxvYWQuc3RhcnRJZk5lZWRlZChjb21wb25lbnQpXG4gIH0sXG5cbiAgdHJhbnNpdGlvbjogZnVuY3Rpb24gKHJlZiwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudE1hcFtyZWZdXG4gICAgYW5pbWF0aW9uLnRyYW5zaXRpb25PbmNlKGNvbXBvbmVudCwgY29uZmlnLCBjYWxsYmFjaylcbiAgfSxcblxuICByZW5kZXJGaW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICBGcmFtZVVwZGF0ZXIucGF1c2UoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50TWFuYWdlclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50TWFuYWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIwXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICBmdW5jdGlvbiAoY2FsbGxiYWNrKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNhbGxsYmFjaywgMTYpXG4gICAgICAgICAgfVxuXG52YXIgcmFmSWRcbnZhciBvYnNlcnZlcnMgPSBbXVxudmFyIHBhdXNlZCA9IGZhbHNlXG5cbnZhciBGcmFtZVVwZGF0ZXIgPSB7XG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJhZklkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICByYWZJZCA9IHJhZihmdW5jdGlvbiBydW5Mb29wKCkge1xuICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYnNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBvYnNlcnZlcnNbaV0oKVxuICAgICAgICB9XG4gICAgICAgIHJhZihydW5Mb29wKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG5cbiAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXBhdXNlZFxuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkID0gdHJ1ZVxuICAgIHJhZklkID0gdW5kZWZpbmVkXG4gIH0sXG5cbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgcGF1c2VkID0gZmFsc2VcbiAgICB0aGlzLnN0YXJ0KClcbiAgfSxcblxuICBhZGRVcGRhdGVPYnNlcnZlcjogZnVuY3Rpb24gKG9ic2VydmVNZXRob2QpIHtcbiAgICBvYnNlcnZlcnMucHVzaChvYnNlcnZlTWV0aG9kKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRnJhbWVVcGRhdGVyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9mcmFtZVVwZGF0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5cbnZhciBjb21wb25lbnRzSW5TY3JvbGxlciA9IFtdXG52YXIgY29tcG9uZW50c091dE9mU2Nyb2xsZXIgPSBbXVxudmFyIGxpc3RlbmVkID0gZmFsc2VcbnZhciBkaXJlY3Rpb24gPSAndXAnXG52YXIgc2Nyb2xsWSA9IDBcblxudmFyIEFwcGVhcldhdGNoZXIgPSB7XG4gIHdhdGNoSWZOZWVkZWQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBpZiAobmVlZFdhdGNoKGNvbXBvbmVudCkpIHtcbiAgICAgIGlmIChjb21wb25lbnQuaXNJblNjcm9sbGFibGUoKSkge1xuICAgICAgICBjb21wb25lbnRzSW5TY3JvbGxlci5wdXNoKGNvbXBvbmVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBvbmVudHNPdXRPZlNjcm9sbGVyLnB1c2goY29tcG9uZW50KVxuICAgICAgfVxuICAgICAgaWYgKCFsaXN0ZW5lZCkge1xuICAgICAgICBsaXN0ZW5lZCA9IHRydWVcbiAgICAgICAgLy8gdmFyIGhhbmRsZXIgPSB0aHJvdHRsZShvblNjcm9sbCwgMjUpXG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhyb3R0bGUob25TY3JvbGwsIDEwMClcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIsIGZhbHNlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBuZWVkV2F0Y2goY29tcG9uZW50KSB7XG4gIHZhciBldmVudHMgPSBjb21wb25lbnQuZGF0YS5ldmVudFxuICBpZiAoZXZlbnRzXG4gICAgICAmJiAoZXZlbnRzLmluZGV4T2YoJ2FwcGVhcicpICE9IC0xXG4gICAgICAgIHx8IGV2ZW50cy5pbmRleE9mKCdkaXNhcHBlYXInKSAhPSAtMSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBvblNjcm9sbChlKSB7XG4gIC8vIElmIHRoZSBzY3JvbGwgZXZlbnQgaXMgZGlzcGF0Y2hlZCBmcm9tIGEgc2Nyb2xsYWJsZSBjb21wb25lbnRcbiAgLy8gaW1wbGVtZW50ZWQgdGhyb3VnaCBzY3JvbGxlcmpzLCB0aGVuIHRoZSBhcHBlYXIvZGlzYXBwZWFyIGV2ZW50c1xuICAvLyBzaG91bGQgYmUgdHJlYXRlZCBzcGVjaWFsbHkgYnkgaGFuZGxlU2Nyb2xsZXJTY3JvbGwuXG4gIGlmIChlLm9yaWdpbmFsVHlwZSA9PT0gJ3Njcm9sbGluZycpIHtcbiAgICBoYW5kbGVTY3JvbGxlclNjcm9sbChlKVxuICB9IGVsc2Uge1xuICAgIGhhbmRsZVdpbmRvd1Njcm9sbCgpXG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsZXJTY3JvbGwoZSkge1xuICB2YXIgY21wcyA9IGNvbXBvbmVudHNJblNjcm9sbGVyXG4gIHZhciBsZW4gPSBjbXBzLmxlbmd0aFxuICBkaXJlY3Rpb24gPSBlLmRpcmVjdGlvblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNtcHNbaV1cbiAgICB2YXIgYXBwZWFyID0gaXNDb21wb25lbnRJblNjcm9sbGVyQXBwZWFyKGNvbXBvbmVudClcbiAgICBpZiAoYXBwZWFyICYmICFjb21wb25lbnQuX2FwcGVhcikge1xuICAgICAgY29tcG9uZW50Ll9hcHBlYXIgPSB0cnVlXG4gICAgICBmaXJlRXZlbnQoY29tcG9uZW50LCAnYXBwZWFyJylcbiAgICB9IGVsc2UgaWYgKCFhcHBlYXIgJiYgY29tcG9uZW50Ll9hcHBlYXIpIHtcbiAgICAgIGNvbXBvbmVudC5fYXBwZWFyID0gZmFsc2VcbiAgICAgIGZpcmVFdmVudChjb21wb25lbnQsICdkaXNhcHBlYXInKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVXaW5kb3dTY3JvbGwoKSB7XG4gIHZhciB5ID0gd2luZG93LnNjcm9sbFlcbiAgZGlyZWN0aW9uID0geSA+PSBzY3JvbGxZID8gJ3VwJyA6ICdkb3duJ1xuICBzY3JvbGxZID0geVxuXG4gIHZhciBsZW4gPSBjb21wb25lbnRzT3V0T2ZTY3JvbGxlci5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c091dE9mU2Nyb2xsZXJbaV1cbiAgICB2YXIgYXBwZWFyID0gaXNDb21wb25lbnRJbldpbmRvdyhjb21wb25lbnQpXG4gICAgaWYgKGFwcGVhciAmJiAhY29tcG9uZW50Ll9hcHBlYXIpIHtcbiAgICAgIGNvbXBvbmVudC5fYXBwZWFyID0gdHJ1ZVxuICAgICAgZmlyZUV2ZW50KGNvbXBvbmVudCwgJ2FwcGVhcicpXG4gICAgfSBlbHNlIGlmICghYXBwZWFyICYmIGNvbXBvbmVudC5fYXBwZWFyKSB7XG4gICAgICBjb21wb25lbnQuX2FwcGVhciA9IGZhbHNlXG4gICAgICBmaXJlRXZlbnQoY29tcG9uZW50LCAnZGlzYXBwZWFyJylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb21wb25lbnRJblNjcm9sbGVyQXBwZWFyKGNvbXBvbmVudCkge1xuICB2YXIgcGFyZW50U2Nyb2xsZXIgPSBjb21wb25lbnQuX3BhcmVudFNjcm9sbGVyXG4gIHZhciBjbXBSZWN0ID0gY29tcG9uZW50Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgaWYgKCFpc0NvbXBvbmVudEluV2luZG93KGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB3aGlsZSAocGFyZW50U2Nyb2xsZXIpIHtcbiAgICB2YXIgcGFyZW50UmVjdCA9IHBhcmVudFNjcm9sbGVyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBpZiAoIShjbXBSZWN0LnJpZ2h0ID4gcGFyZW50UmVjdC5sZWZ0XG4gICAgICAgICYmIGNtcFJlY3QubGVmdCA8IHBhcmVudFJlY3QucmlnaHRcbiAgICAgICAgJiYgY21wUmVjdC5ib3R0b20gPiBwYXJlbnRSZWN0LnRvcFxuICAgICAgICAmJiBjbXBSZWN0LnRvcCA8IHBhcmVudFJlY3QuYm90dG9tKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHBhcmVudFNjcm9sbGVyID0gcGFyZW50U2Nyb2xsZXIuX3BhcmVudFNjcm9sbGVyXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaXNDb21wb25lbnRJbldpbmRvdyhjb21wb25lbnQpIHtcbiAgdmFyIHJlY3QgPSBjb21wb25lbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gcmVjdC5yaWdodCA+IDAgJiYgcmVjdC5sZWZ0IDwgd2luZG93LmlubmVyV2lkdGggJiZcbiAgICAgICAgIHJlY3QuYm90dG9tID4gMCAmJiByZWN0LnRvcCA8IHdpbmRvdy5pbm5lckhlaWdodFxufVxuXG5mdW5jdGlvbiBmaXJlRXZlbnQoY29tcG9uZW50LCB0eXBlKSB7XG4gIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpXG4gIHZhciBkYXRhID0geyBkaXJlY3Rpb246IGRpcmVjdGlvbiB9XG4gIGV2dC5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKVxuICBldnQuZGF0YSA9IGRhdGFcbiAgdXRpbHMuZXh0ZW5kKGV2dCwgZGF0YSlcbiAgY29tcG9uZW50Lm5vZGUuZGlzcGF0Y2hFdmVudChldnQpXG59XG5cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQpIHtcbiAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdFxuICB2YXIgdGltZW91dCA9IG51bGxcbiAgdmFyIHByZXZpb3VzID0gMFxuICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJldmlvdXMgPSBEYXRlLm5vdygpXG4gICAgdGltZW91dCA9IG51bGxcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKVxuICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKVxuICAgIGNvbnRleHQgPSB0aGlzXG4gICAgYXJncyA9IGFyZ3VtZW50c1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICB0aW1lb3V0ID0gbnVsbFxuICAgICAgcHJldmlvdXMgPSBub3dcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncylcbiAgICB9IGVsc2UgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBcHBlYXJXYXRjaGVyXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvYXBwZWFyV2F0Y2hlci5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCdsYXp5aW1nJylcblxudmFyIGxhenlsb2FkVGltZXJcblxudmFyIExhenlMb2FkID0ge1xuICBtYWtlSW1hZ2VMYXp5OiBmdW5jdGlvbiAoaW1hZ2UsIHNyYykge1xuICAgIGltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnaW1nLXNyYycpXG4gICAgaW1hZ2UucmVtb3ZlQXR0cmlidXRlKCdpLWxhenktc3JjJylcbiAgICBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpXG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdpbWctc3JjJywgc3JjKVxuICAgIC8vIHNob3VsZCByZXBsYWNlICdzcmMnIHdpdGggJ2ltZy1zcmMnLiBidXQgZm9yIG5vdyBsaWIuaW1nLmZpcmUgaXNcbiAgICAvLyBub3Qgd29ya2luZyBmb3IgdGhlIHNpdHVhdGlvbiB0aGF0IHRoZSBhcHBlYXIgZXZlbnQgaGFzIGJlZW5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZC5cbiAgICAvLyBpbWFnZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYylcbiAgICAvLyBpbWFnZS5zZXRBdHRyaWJ1dGUoJ2ltZy1zcmMnLCBzcmMpXG4gICAgdGhpcy5maXJlKClcbiAgfSxcblxuICAvLyB3ZSBkb24ndCBrbm93IHdoZW4gYWxsIGltYWdlIGFyZSBhcHBlbmRlZFxuICAvLyBqdXN0IHVzZSBzZXRUaW1lb3V0IHRvIGRvIGRlbGF5IGxhenlsb2FkXG4gIC8vXG4gIC8vIC0tIGFjdHVhbGx5IGV2ZXJ5dGltZSB3ZSBhZGQgYSBlbGVtZW50IG9yIHVwZGF0ZSBzdHlsZXMsXG4gIC8vIHRoZSBjb21wb25lbnQgbWFuYWdlciB3aWxsIGNhbGwgc3RhcnRJZk5lZWQgdG8gZmlyZVxuICAvLyBsYXp5bG9hZCBvbmNlIGFnYWluIGluIHRoZSBoYW5kbGVBcHBlbmQgZnVuY3Rpb24uIHNvIHRoZXJlXG4gIC8vIGlzIG5vIHdheSB0aGF0IGFueSBpbWFnZSBlbGVtZW50IGNhbiBtaXNzIGl0LiBTZWUgc291cmNlXG4gIC8vIGNvZGUgaW4gY29tcG9uZW50TWFuZ2FnZXIuanMuXG4gIHN0YXJ0SWZOZWVkZWQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBpZiAoY29tcG9uZW50LmRhdGEudHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgaWYgKCFsYXp5bG9hZFRpbWVyKSB7XG4gICAgICAgIGxhenlsb2FkVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LmZpcmUoKVxuICAgICAgICAgIGNsZWFyVGltZW91dChsYXp5bG9hZFRpbWVyKVxuICAgICAgICAgIGxhenlsb2FkVGltZXIgPSBudWxsXG4gICAgICAgIH0sIDE2KVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBsb2FkSWZOZWVkZWQ6IGZ1bmN0aW9uIChlbGVtZW50U2NvcGUpIHtcbiAgICB2YXIgbm90UHJlUHJvY2Vzc2VkID0gZWxlbWVudFNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbWctc3JjXScpXG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLy8gaW1hZ2UgZWxlbWVudHMgd2hpY2ggaGF2ZSBhdHRyaWJ1dGUgJ2ktbGF6eS1zcmMnIHdlcmUgZWxlbWVudHNcbiAgICAvLyB0aGF0IGhhZCBiZWVuIHByZXByb2Nlc3NlZCBieSBsaWItaW1nLWNvcmUsIGJ1dCBub3QgbG9hZGVkIHlldCwgYW5kXG4gICAgLy8gbXVzdCBiZSBsb2FkZWQgd2hlbiAnYXBwZWFyJyBldmVudHMgd2VyZSBmaXJlZC4gSXQgdHVybnMgb3V0IHRoZVxuICAgIC8vICdhcHBlYXInIGV2ZW50IHdhcyBub3QgZmlyZWQgY29ycmVjdGx5IGluIHRoZSBjc3MtdHJhbnNsYXRlLXRyYW5zaXRpb25cbiAgICAvLyBzaXR1YXRpb24sIHNvICdpLWxhenktc3JjJyBtdXN0IGJlIGNoZWNrZWQgYW5kIGxhenlsb2FkIG11c3QgYmVcbiAgICAvLyBmaXJlZCBtYW51YWxseS5cbiAgICB2YXIgcHJlUHJvY2Vzc2VkID0gZWxlbWVudFNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpLWxhenktc3JjXScpXG4gICAgaWYgKG5vdFByZVByb2Nlc3NlZC5sZW5ndGggPiAwIHx8IHByZVByb2Nlc3NlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGF0LmZpcmUoKVxuICAgIH1cbiAgfSxcblxuICAvLyBmaXJlIGxhenlsb2FkLlxuICBmaXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgbGliLmltZy5maXJlKClcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGF6eUxvYWRcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2xhenlMb2FkLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyYmKHdpbmRvdz17Y3RybDp7fSxsaWI6e319KSwhd2luZG93LmN0cmwmJih3aW5kb3cuY3RybD17fSksIXdpbmRvdy5saWImJih3aW5kb3cubGliPXt9KSxmdW5jdGlvbih0LGkpe2Z1bmN0aW9uIGUodCxpKXtpJiYoXCJJTUdcIj09dC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpP3Quc2V0QXR0cmlidXRlKFwic3JjXCIsaSk6dC5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9J3VybChcIicraSsnXCIpJyl9ZnVuY3Rpb24gYSgpe3I9aS5hcHBlYXIuaW5pdCh7Y2xzOlwiaW1ndG1wXCIsb25jZTohMCx4Om8ubGF6eVdpZHRoLHk6by5sYXp5SGVpZ2h0LG9uQXBwZWFyOmZ1bmN0aW9uKHQpe3ZhciBpPXRoaXM7ZShpLGkuZ2V0QXR0cmlidXRlKFwiaS1sYXp5LXNyY1wiKSksaS5yZW1vdmVBdHRyaWJ1dGUoXCJpLWxhenktc3JjXCIpfX0pfXJlcXVpcmUoXCJhcHBlYXJqc1wiKTt2YXIgcixBPXt9LG89e2RhdGFTcmM6XCJpbWctc3JjXCIsbGF6eUhlaWdodDowLGxhenlXaWR0aDowfTtBLmxvZ0NvbmZpZz1mdW5jdGlvbigpe2NvbnNvbGUubG9nKFwibGliLWltZyBDb25maWdcXG5cIixvKX0sQS5maXJlPWZ1bmN0aW9uKCl7cnx8YSgpO3ZhciB0PVwiaV9cIitEYXRlLm5vdygpJTFlNSxpPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIrby5kYXRhU3JjK1wiXVwiKTtbXS5mb3JFYWNoLmNhbGwoaSxmdW5jdGlvbihpKXtcImZhbHNlXCI9PWkuZGF0YXNldC5sYXp5JiZcInRydWVcIiE9aS5kYXRhc2V0Lmxhenk/ZShpLHByb2Nlc3NTcmMoaSxpLmdldEF0dHJpYnV0ZShvLmRhdGFTcmMpKSk6KGkuY2xhc3NMaXN0LmFkZCh0KSxpLnNldEF0dHJpYnV0ZShcImktbGF6eS1zcmNcIixpLmdldEF0dHJpYnV0ZShvLmRhdGFTcmMpKSksaS5yZW1vdmVBdHRyaWJ1dGUoby5kYXRhU3JjKX0pLHIuYmluZChcIi5cIit0KSxyLmZpcmUoKX0sQS5kZWZhdWx0U3JjPVwiZGF0YTppbWFnZS9naWY7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FZQUFBQWZGY1NKQUFBQURVbEVRVlFJbVdOZ1lHQmdBQUFBQlFBQmg2Rk8xQUFBQUFCSlJVNUVya0pnZ2c9PVwiLGkuaW1nPUEsbW9kdWxlLmV4cG9ydHM9QX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9+L2xhenlpbWcvYnVpbGQvaW1nLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI0XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIlwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3cmJih3aW5kb3c9e2N0cmw6e30sbGliOnt9fSksIXdpbmRvdy5jdHJsJiYod2luZG93LmN0cmw9e30pLCF3aW5kb3cubGliJiYod2luZG93LmxpYj17fSksZnVuY3Rpb24obixlKXtmdW5jdGlvbiBpKCl7ZD13LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKSx2PXcuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpLGQuaW5pdEV2ZW50KFwiX2FwcGVhclwiLCExLCEwKSx2LmluaXRFdmVudChcIl9kaXNhcHBlYXJcIiwhMSwhMCl9ZnVuY3Rpb24gYSh0LG4pe3ZhciBlLGksYSxzPShEYXRlLm5vdygpLDApLG89bnVsbCxyPWZ1bmN0aW9uKCl7cz1EYXRlLm5vdygpLG89bnVsbCx0LmFwcGx5KGUsaSl9O3JldHVybiBmdW5jdGlvbigpe3ZhciBsPURhdGUubm93KCk7ZT10aGlzLGk9YXJndW1lbnRzO3ZhciBjPW4tKGwtcyk7cmV0dXJuIDA+PWN8fGM+PW4/KGNsZWFyVGltZW91dChvKSxvPW51bGwsYT10LmFwcGx5KGUsaSkpOm51bGw9PW8mJihvPXNldFRpbWVvdXQocixjKSksYX19ZnVuY3Rpb24gcyhuLGUpe3ZhciBuLGksYSxzO2lmKG4pcmV0dXJuIGV8fChlPXt4OjAseTowfSksbiE9d2luZG93PyhuPW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksaT1uLmxlZnQsdD1uLnRvcCxhPW4ucmlnaHQscz1uLmJvdHRvbSk6KGk9MCx0PTAsYT1pK24uaW5uZXJXaWR0aCxzPXQrbi5pbm5lckhlaWdodCkse2xlZnQ6aSx0b3A6dCxyaWdodDphK2UueCxib3R0b206cytlLnl9fWZ1bmN0aW9uIG8odCxuKXt2YXIgZT1uLnJpZ2h0PnQubGVmdCYmbi5sZWZ0PHQucmlnaHQsaT1uLmJvdHRvbT50LnRvcCYmbi50b3A8dC5ib3R0b207cmV0dXJuIGUmJml9ZnVuY3Rpb24gcih0LG4pe3ZhciBlPVwibm9uZVwiLGk9dC5sZWZ0LW4ubGVmdCxhPXQudG9wLW4udG9wO3JldHVybiAwPT1hJiYoZT0wIT1pP2k+MD9cImxlZnRcIjpcInJpZ2h0XCI6XCJub25lXCIpLDA9PWkmJihlPTAhPWE/YT4wP1widXBcIjpcImRvd25cIjpcIm5vbmVcIiksZX1mdW5jdGlvbiBsKHQsbil7Zm9yKHZhciBlIGluIG4pbi5oYXNPd25Qcm9wZXJ0eShlKSYmKHRbZV09bltlXSk7cmV0dXJuIHR9ZnVuY3Rpb24gYygpe3ZhciB0PXRoaXMsbj1hKGZ1bmN0aW9uKCl7Zi5hcHBseSh0LGFyZ3VtZW50cyl9LHRoaXMub3B0aW9ucy53YWl0KTt0aGlzLl9faGFuZGxlJiYodGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLHRoaXMuX19oYW5kbGUpLHRoaXMuX19oYW5kbGU9bnVsbCksdGhpcy5fX2hhbmRsZT1uLHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixuLCExKSx0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsZnVuY3Rpb24obil7Zi5hcHBseSh0LGFyZ3VtZW50cyl9LCExKSx0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uRW5kXCIsZnVuY3Rpb24oKXtmLmFwcGx5KHQsYXJndW1lbnRzKX0sITEpLHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ3ZWJraXRBbmltYXRpb25FbmRcIixmdW5jdGlvbigpe2YuYXBwbHkodCxhcmd1bWVudHMpfSwhMSksdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIixmdW5jdGlvbigpe2YuYXBwbHkodCxhcmd1bWVudHMpfSwhMSl9ZnVuY3Rpb24gcCh0KXt2YXIgbj10aGlzLGU9dGhpcy5vcHRpb25zLmNvbnRhaW5lcjtpZihcInN0cmluZ1wiPT10eXBlb2YgZT90aGlzLmNvbnRhaW5lcj13LnF1ZXJ5U2VsZWN0b3IoZSk6dGhpcy5jb250YWluZXI9ZSx0aGlzLmNvbnRhaW5lcj09d2luZG93KXZhciBpPXcucXVlcnlTZWxlY3RvckFsbCh0KTtlbHNlIHZhciBpPXRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwodCk7dmFyIGk9W10uc2xpY2UuY2FsbChpLG51bGwpO3JldHVybiBpPWkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVyblwiMVwiPT10LmRhdGFzZXQuYmluZD8oZGVsZXRlIHQuX2hhc0FwcGVhcixkZWxldGUgdC5faGFzRGlzQXBwZWFyLGRlbGV0ZSB0Ll9hcHBlYXIsdC5jbGFzc0xpc3QucmVtb3ZlKG4ub3B0aW9ucy5jbHMpLCExKTohMH0pfWZ1bmN0aW9uIGgodCl7dmFyIG49dGhpczt0JiZ0Lmxlbmd0aD4wJiZbXS5mb3JFYWNoLmNhbGwodCxmdW5jdGlvbih0KXt0Ll9lbGVPZmZzZXQ9cyh0KSx0LmNsYXNzTGlzdC5yZW1vdmUobi5vcHRpb25zLmNscyksdC5kYXRhc2V0LmJpbmQ9MX0pfWZ1bmN0aW9uIGYoKXt2YXIgdD10aGlzLmNvbnRhaW5lcixuPXRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cyxlPXRoaXMub3B0aW9ucy5vbkFwcGVhcixpPXRoaXMub3B0aW9ucy5vbkRpc2FwcGVhcixhPXModCx7eDp0aGlzLm9wdGlvbnMueCx5OnRoaXMub3B0aW9ucy55fSksbD10aGlzLm9wdGlvbnMub25jZSxjPWFyZ3VtZW50c1swXXx8e307biYmbi5sZW5ndGg+MCYmW10uZm9yRWFjaC5jYWxsKG4sZnVuY3Rpb24odCxuKXt2YXIgcD1zKHQpLGg9cih0Ll9lbGVPZmZzZXQscCk7dC5fZWxlT2Zmc2V0PXA7dmFyIGY9byhhLHApLHU9dC5fYXBwZWFyLHc9dC5faGFzQXBwZWFyLEU9dC5faGFzRGlzQXBwZWFyO2QuZGF0YT17ZGlyZWN0aW9uOmh9LHYuZGF0YT17ZGlyZWN0aW9uOmh9LGYmJiF1PyhsJiYhd3x8IWwpJiYoZSYmZS5jYWxsKHQsYyksdC5kaXNwYXRjaEV2ZW50KGQpLHQuX2hhc0FwcGVhcj0hMCx0Ll9hcHBlYXI9ITApOiFmJiZ1JiYobCYmIUV8fCFsKSYmKGkmJmkuY2FsbCh0LGMpLHQuZGlzcGF0Y2hFdmVudCh2KSx0Ll9oYXNEaXNBcHBlYXI9ITAsdC5fYXBwZWFyPSExKX0pfWZ1bmN0aW9uIHUodCl7bCh0aGlzLm9wdGlvbnMsdHx8KHQ9e30pKSx0aGlzLmFwcGVhcldhdGNoRWxlbWVudHM9dGhpcy5hcHBlYXJXYXRjaEVsZW1lbnRzfHxwLmNhbGwodGhpcyxcIi5cIit0aGlzLm9wdGlvbnMuY2xzKSxoLmNhbGwodGhpcyx0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMpLGMuY2FsbCh0aGlzKX12YXIgZCx2LHc9ZG9jdW1lbnQsRT1mdW5jdGlvbigpe3UuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxfPXtpbnN0YW5jZXM6W10saW5pdDpmdW5jdGlvbih0KXt2YXIgbj17b3B0aW9uczp7Y29udGFpbmVyOndpbmRvdyx3YWl0OjEwMCx4OjAseTowLGNsczpcImxpYi1hcHBlYXJcIixvbmNlOiExLG9uUmVzZXQ6ZnVuY3Rpb24oKXt9LG9uQXBwZWFyOmZ1bmN0aW9uKCl7fSxvbkRpc2FwcGVhcjpmdW5jdGlvbigpe319LGNvbnRhaW5lcjpudWxsLGFwcGVhcldhdGNoRWxlbWVudHM6bnVsbCxiaW5kOmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMub3B0aW9ucy5jbHM7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe3ZhciBlPXAuY2FsbCh0aGlzLHQpO1tdLmZvckVhY2guY2FsbChlLGZ1bmN0aW9uKHQsZSl7dC5jbGFzc0xpc3QuY29udGFpbnMobil8fHQuY2xhc3NMaXN0LmFkZChuKX0pfWVsc2V7aWYoMSE9dC5ub2RlVHlwZXx8IXRoaXMuY29udGFpbmVyLmNvbnRhaW5zKHQpKXJldHVybiB0aGlzO3QuY2xhc3NMaXN0LmNvbnRhaW5zKG4pfHx0LmNsYXNzTGlzdC5hZGQobil9dmFyIGk9cC5jYWxsKHRoaXMsXCIuXCIrdGhpcy5vcHRpb25zLmNscyk7cmV0dXJuIHRoaXMuYXBwZWFyV2F0Y2hFbGVtZW50cz10aGlzLmFwcGVhcldhdGNoRWxlbWVudHMuY29uY2F0KGkpLGguY2FsbCh0aGlzLGkpLHRoaXN9LHJlc2V0OmZ1bmN0aW9uKHQpe3JldHVybiB1LmNhbGwodGhpcyx0KSx0aGlzLmFwcGVhcldhdGNoRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbih0KXtkZWxldGUgdC5faGFzQXBwZWFyLGRlbGV0ZSB0Ll9oYXNEaXNBcHBlYXIsZGVsZXRlIHQuX2FwcGVhcn0pLHRoaXN9LGZpcmU6ZnVuY3Rpb24oKXt0aGlzLmFwcGVhcldhdGNoRWxlbWVudHN8fCh0aGlzLmFwcGVhcldhdGNoRWxlbWVudHM9W10pO3ZhciB0PXAuY2FsbCh0aGlzLFwiLlwiK3RoaXMub3B0aW9ucy5jbHMpO3JldHVybiB0aGlzLmFwcGVhcldhdGNoRWxlbWVudHM9dGhpcy5hcHBlYXJXYXRjaEVsZW1lbnRzLmNvbmNhdCh0KSxoLmNhbGwodGhpcyx0KSxmLmNhbGwodGhpcyksdGhpc319O0UucHJvdG90eXBlPW47dmFyIGU9bmV3IEUodCk7cmV0dXJuIHRoaXMuaW5zdGFuY2VzLnB1c2goZSksZX0sZmlyZUFsbDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuaW5zdGFuY2VzO3QuZm9yRWFjaChmdW5jdGlvbih0KXt0LmZpcmUoKX0pfX07aSgpLGUuYXBwZWFyPV99KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2FwcGVhcmpzL2J1aWxkL2FwcGVhci5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyoqXG4gICAqIGNvbmZpZzpcbiAgICogICAtIHN0eWxlc1xuICAgKiAgIC0gZHVyYXRpb24gW051bWJlcl0gbWlsbGlzZWNvbmRzKG1zKVxuICAgKiAgIC0gdGltaW5nRnVuY3Rpb24gW3N0cmluZ11cbiAgICogICAtIGRlYWx5IFtOdW1iZXJdIG1pbGxpc2Vjb25kcyhtcylcbiAgICovXG4gIHRyYW5zaXRpb25PbmNlOiBmdW5jdGlvbiAoY29tcCwgY29uZmlnLCBjYWxsYmFjaykge1xuICAgIHZhciBzdHlsZXMgPSBjb25maWcuc3R5bGVzIHx8IHt9XG4gICAgdmFyIGR1cmF0aW9uID0gY29uZmlnLmR1cmF0aW9uIHx8IDEwMDAgLy8gbXNcbiAgICB2YXIgdGltaW5nRnVuY3Rpb24gPSBjb25maWcudGltaW5nRnVuY3Rpb24gfHwgJ2Vhc2UnXG4gICAgdmFyIGRlbGF5ID0gY29uZmlnLmRlbGF5IHx8IDAgIC8vIG1zXG4gICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9ICdhbGwgJyArIGR1cmF0aW9uICsgJ21zICdcbiAgICAgICAgKyB0aW1pbmdGdW5jdGlvbiArICcgJyArIGRlbGF5ICsgJ21zJ1xuICAgIHZhciBkb20gPSBjb21wLm5vZGVcbiAgICB2YXIgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0cmFuc2l0aW9uRW5kSGFuZGxlcilcbiAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdHJhbnNpdGlvbkVuZEhhbmRsZXIpXG4gICAgICBkb20uc3R5bGUudHJhbnNpdGlvbiA9ICcnXG4gICAgICBkb20uc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICAgIGRvbS5zdHlsZS50cmFuc2l0aW9uID0gdHJhbnNpdGlvblZhbHVlXG4gICAgZG9tLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uVmFsdWVcbiAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0VHJhbnNpdGlvbkVuZCcsIHRyYW5zaXRpb25FbmRIYW5kbGVyKVxuICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdHJhbnNpdGlvbkVuZEhhbmRsZXIpXG4gICAgY29tcC51cGRhdGVTdHlsZShzdHlsZXMpXG4gIH1cblxufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2FuaW1hdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDI2XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJylcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJylcbnZhciBDb21wb25lbnRNYW5hZ2VyID0gcmVxdWlyZSgnLi4vY29tcG9uZW50TWFuYWdlcicpXG52YXIgZmxleGJveCA9IHJlcXVpcmUoJy4uL2ZsZXhib3gnKVxudmFyIHZhbHVlRmlsdGVyID0gcmVxdWlyZSgnLi4vdmFsdWVGaWx0ZXInKVxucmVxdWlyZSgnZml4ZWRzdGlja3knKVxuXG5mdW5jdGlvbiBDb21wb25lbnQoZGF0YSwgbm9kZVR5cGUpIHtcbiAgdGhpcy5kYXRhID0gZGF0YVxuICB0aGlzLm5vZGUgPSB0aGlzLmNyZWF0ZShub2RlVHlwZSlcblxuICB0aGlzLmNyZWF0ZUNoaWxkcmVuKClcbiAgdGhpcy51cGRhdGVBdHRycyh0aGlzLmRhdGEuYXR0cilcbiAgLy8gaXNzdWU6IHdoZW4gYWRkIGVsZW1lbnQgdG8gYSBsaXN0IGluIGxpZmV0aW1lIGhvb2sgJ3JlYWR5JywgdGhlXG4gIC8vIHN0eWxlcyBpcyBzZXQgdG8gdGhlIGNsYXNzU3R5bGUsIG5vdCBzdHlsZS4gVGhpcyBpcyBhIGlzc3VlXG4gIC8vIHRoYXQganNmcmFtZXdvcmsgc2hvdWxkIGRvIHNvbWV0aGluZyBhYm91dC5cbiAgdmFyIGNsYXNzU3R5bGUgPSB0aGlzLmRhdGEuY2xhc3NTdHlsZVxuICBjbGFzc1N0eWxlICYmIHRoaXMudXBkYXRlU3R5bGUodGhpcy5kYXRhLmNsYXNzU3R5bGUpXG4gIHRoaXMudXBkYXRlU3R5bGUodGhpcy5kYXRhLnN0eWxlKVxuICB0aGlzLmJpbmRFdmVudHModGhpcy5kYXRhLmV2ZW50KVxufVxuXG5Db21wb25lbnQucHJvdG90eXBlID0ge1xuXG4gIGNyZWF0ZTogZnVuY3Rpb24gKG5vZGVUeXBlKSB7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVUeXBlIHx8ICdkaXYnKVxuICAgIHJldHVybiBub2RlXG4gIH0sXG5cbiAgZ2V0Q29tcG9uZW50TWFuYWdlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBDb21wb25lbnRNYW5hZ2VyLmdldEluc3RhbmNlKHRoaXMuZGF0YS5pbnN0YW5jZUlkKVxuICB9LFxuXG4gIGdldFBhcmVudDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5jb21wb25lbnRNYXBbdGhpcy5wYXJlbnRSZWZdXG4gIH0sXG5cbiAgZ2V0UGFyZW50U2Nyb2xsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0luU2Nyb2xsYWJsZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50U2Nyb2xsZXJcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfSxcblxuICBnZXRSb290U2Nyb2xsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0luU2Nyb2xsYWJsZSgpKSB7XG4gICAgICB2YXIgc2Nyb2xsZXIgPSB0aGlzLl9wYXJlbnRTY3JvbGxlclxuICAgICAgdmFyIHBhcmVudCA9IHNjcm9sbGVyLl9wYXJlbnRTY3JvbGxlclxuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBzY3JvbGxlciA9IHBhcmVudFxuICAgICAgICBwYXJlbnQgPSBzY3JvbGxlci5fcGFyZW50U2Nyb2xsZXJcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY3JvbGxlclxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9LFxuXG4gIGdldFJvb3RDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpLndlZXhJbnN0YW5jZS5nZXRSb290KClcbiAgICAgIHx8IGRvY3VtZW50LmJvZHlcbiAgICByZXR1cm4gcm9vdFxuICB9LFxuXG4gIGlzU2Nyb2xsYWJsZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ID0gdGhpcy5kYXRhLnR5cGVcbiAgICByZXR1cm4gQ29tcG9uZW50TWFuYWdlci5nZXRTY3JvbGxhYmxlVHlwZXMoKS5pbmRleE9mKHQpICE9PSAtMVxuICB9LFxuXG4gIGlzSW5TY3JvbGxhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9pc0luU2Nyb2xsYWJsZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNJblNjcm9sbGFibGVcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcbiAgICBpZiAocGFyZW50XG4gICAgICAgICYmICh0eXBlb2YgcGFyZW50Ll9pc0luU2Nyb2xsYWJsZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAmJiAhcGFyZW50LmlzU2Nyb2xsYWJsZSgpKSB7XG4gICAgICBpZiAocGFyZW50LmRhdGEucmVmID09PSAnX3Jvb3QnKSB7XG4gICAgICAgIHRoaXMuX2lzSW5TY3JvbGxhYmxlID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB0aGlzLl9pc0luU2Nyb2xsYWJsZSA9IHBhcmVudC5pc0luU2Nyb2xsYWJsZSgpXG4gICAgICB0aGlzLl9wYXJlbnRTY3JvbGxlciA9IHBhcmVudC5fcGFyZW50U2Nyb2xsZXJcbiAgICAgIHJldHVybiB0aGlzLl9pc0luU2Nyb2xsYWJsZVxuICAgIH1cbiAgICBpZiAocGFyZW50ICYmIHR5cGVvZiBwYXJlbnQuX2lzSW5TY3JvbGxhYmxlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuX2lzSW5TY3JvbGxhYmxlID0gcGFyZW50Ll9pc0luU2Nyb2xsYWJsZVxuICAgICAgdGhpcy5fcGFyZW50U2Nyb2xsZXIgPSBwYXJlbnQuX3BhcmVudFNjcm9sbGVyXG4gICAgICByZXR1cm4gdGhpcy5faXNJblNjcm9sbGFibGVcbiAgICB9XG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuaXNTY3JvbGxhYmxlKCkpIHtcbiAgICAgIHRoaXMuX2lzSW5TY3JvbGxhYmxlID0gdHJ1ZVxuICAgICAgdGhpcy5fcGFyZW50U2Nyb2xsZXIgPSBwYXJlbnRcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IoJ2lzSW5TY3JvbGxhYmxlIC0gcGFyZW50IG5vdCBleGlzdC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgdmFyIHBhcmVudFJlZiA9IHRoaXMuZGF0YS5yZWZcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgICB2YXIgaXNGbGV4ID0gZmFsc2VcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGRyZW5baV0uaW5zdGFuY2VJZCA9IHRoaXMuZGF0YS5pbnN0YW5jZUlkXG4gICAgICAgIGNoaWxkcmVuW2ldLnNjYWxlID0gdGhpcy5kYXRhLnNjYWxlXG4gICAgICAgIHZhciBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChjaGlsZHJlbltpXSlcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcbiAgICAgICAgY2hpbGQucGFyZW50UmVmID0gcGFyZW50UmVmXG4gICAgICAgIGlmICghaXNGbGV4XG4gICAgICAgICAgICAmJiBjaGlsZC5kYXRhLnN0eWxlXG4gICAgICAgICAgICAmJiBjaGlsZC5kYXRhLnN0eWxlLmhhc093blByb3BlcnR5KCdmbGV4JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICBpc0ZsZXggPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChmcmFnbWVudClcbiAgICB9XG4gIH0sXG5cbiAgLy8gQHRvZG86IGNoYW5nZWQgcGFyYW0gZGF0YSB0byBjaGlsZFxuICBhcHBlbmRDaGlsZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gICAgdmFyIGNoaWxkID0gY29tcG9uZW50TWFuYWdlci5jcmVhdGVFbGVtZW50KGRhdGEpXG4gICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG4gICAgLy8gdXBkYXRlIHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRhLmNoaWxkcmVuID0gW2RhdGFdXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goZGF0YSlcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRcbiAgfSxcblxuICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChjaGlsZCwgYmVmb3JlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgdmFyIGkgPSAwXG4gICAgdmFyIGxcbiAgICB2YXIgaXNBcHBlbmQgPSBmYWxzZVxuXG4gICAgLy8gdXBkYXRlIHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCAhYmVmb3JlKSB7XG4gICAgICBpc0FwcGVuZCA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS5yZWYgPT09IGJlZm9yZS5kYXRhLnJlZikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBsKSB7XG4gICAgICAgIGlzQXBwZW5kID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0FwcGVuZCkge1xuICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkLmRhdGEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChiZWZvcmUuZml4ZWRQbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLm5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLm5vZGUsIGJlZm9yZS5maXhlZFBsYWNlaG9sZGVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShjaGlsZC5ub2RlLCBiZWZvcmUubm9kZSlcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAwLCBjaGlsZC5kYXRhKVxuICAgIH1cblxuICB9LFxuXG4gIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICAvLyByZW1vdmUgZnJvbSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgICB2YXIgaSA9IDBcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoY2hpbGRyZW5baV0ucmVmID09PSBjaGlsZC5kYXRhLnJlZikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpIDwgbCkge1xuICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVtb3ZlIGZyb20gY29tcG9uZW50TWFwIHJlY3Vyc2l2ZWx5XG4gICAgY29tcG9uZW50TWFuYWdlci5yZW1vdmVFbGVtZW50QnlSZWYoY2hpbGQuZGF0YS5yZWYpXG4gICAgaWYgKGNoaWxkLmZpeGVkUGxhY2Vob2xkZXIpIHtcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZChjaGlsZC5maXhlZFBsYWNlaG9sZGVyKVxuICAgIH1cbiAgICBjaGlsZC5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQubm9kZSlcbiAgfSxcblxuICB1cGRhdGVBdHRyczogZnVuY3Rpb24gKGF0dHJzKSB7XG4gICAgLy8gTm90Ze+8mmF0dHIgbXVzdCBiZSBpbmplY3RlZCBpbnRvIHRoZSBkb20gZWxlbWVudCBiZWNhdXNlXG4gICAgLy8gaXQgd2lsbCBiZSBhY2Nlc3NlZCBmcm9tIHRoZSBvdXRzaWRlIGRldmVsb3BlciBieSBldmVudC50YXJnZXQuYXR0ci5cbiAgICBpZiAoIXRoaXMubm9kZS5hdHRyKSB7XG4gICAgICB0aGlzLm5vZGUuYXR0ciA9IHt9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cnNba2V5XVxuICAgICAgdmFyIGF0dHJTZXR0ZXIgPSB0aGlzLmF0dHJba2V5XVxuICAgICAgaWYgKHR5cGVvZiBhdHRyU2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGF0dHJTZXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHRoaXMubm9kZVtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlLmF0dHJba2V5XSA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiAoc3R5bGUpIHtcblxuICAgIGZvciAodmFyIGtleSBpbiBzdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVba2V5XVxuICAgICAgdmFyIHN0eWxlU2V0dGVyID0gdGhpcy5zdHlsZVtrZXldXG4gICAgICBpZiAodHlwZW9mIHN0eWxlU2V0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0eWxlU2V0dGVyLmNhbGwodGhpcywgdmFsdWUpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICB2YXIgcGFyc2VyID0gdmFsdWVGaWx0ZXIuZ2V0RmlsdGVycyhrZXksXG4gICAgICAgICAgeyBzY2FsZTogdGhpcy5kYXRhLnNjYWxlIH0pW3R5cGVvZiB2YWx1ZV1cbiAgICAgIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKVxuICAgICAgfVxuICAgICAgdGhpcy5ub2RlLnN0eWxlW2tleV0gPSB2YWx1ZVxuICAgIH1cbiAgfSxcblxuICBiaW5kRXZlbnRzOiBmdW5jdGlvbiAoZXZ0cykge1xuICAgIHZhciBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgICBpZiAoZXZ0c1xuICAgICAgICAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXZ0cykuc2xpY2UoOCwgLTEpID09PSAnQXJyYXknXG4gICAgICApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29tcG9uZW50TWFuYWdlci5hZGRFdmVudCh0aGlzLCBldnRzW2ldKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBkaXNwYXRjaCBhIHNwZWNpZmllZCBldmVudCBvbiB0aGlzLm5vZGVcbiAgLy8gIC0gdHlwZTogZXZlbnQgdHlwZVxuICAvLyAgLSBkYXRhOiBldmVudCBkYXRhXG4gIC8vICAtIGNvbmZpZzogZXZlbnQgY29uZmlnIG9iamVjdFxuICAvLyAgICAgLSBidWJibGVzXG4gIC8vICAgICAtIGNhbmNlbGFibGVcbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHR5cGUsIGRhdGEsIGNvbmZpZykge1xuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJylcbiAgICBjb25maWcgPSBjb25maWcgfHwge31cbiAgICBldmVudC5pbml0RXZlbnQodHlwZSwgY29uZmlnLmJ1YmJsZXMgfHwgZmFsc2UsIGNvbmZpZy5jYW5jZWxhYmxlIHx8IGZhbHNlKVxuICAgICFkYXRhICYmIChkYXRhID0ge30pXG4gICAgZXZlbnQuZGF0YSA9IHV0aWxzLmV4dGVuZCh7fSwgZGF0YSlcbiAgICB1dGlscy5leHRlbmQoZXZlbnQsIGRhdGEpXG4gICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH0sXG5cbiAgdXBkYXRlUmVjdXJzaXZlQXR0cjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLnVwZGF0ZUF0dHJzKGRhdGEuYXR0cilcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuZ2V0RWxlbWVudEJ5UmVmKGNoaWxkcmVuW2ldLnJlZilcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgY2hpbGQudXBkYXRlUmVjdXJzaXZlQXR0cihkYXRhLmNoaWxkcmVuW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZVJlY3Vyc2l2ZVN0eWxlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMudXBkYXRlU3R5bGUoZGF0YS5zdHlsZSlcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuZ2V0RWxlbWVudEJ5UmVmKGNoaWxkcmVuW2ldLnJlZilcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgY2hpbGQudXBkYXRlUmVjdXJzaXZlU3R5bGUoZGF0YS5jaGlsZHJlbltpXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGVSZWN1cnNpdmVBbGw6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdGhpcy51cGRhdGVBdHRycyhkYXRhLmF0dHIpXG4gICAgdGhpcy51cGRhdGVTdHlsZShkYXRhLnN0eWxlKVxuICAgIHZhciBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcblxuICAgIC8vIHZhciBvbGRSZWYgPSB0aGlzLmRhdGEucmVmXG4gICAgLy8gaWYgKGNvbXBvbmVudE1hcFtvbGRSZWZdKSB7XG4gICAgLy8gICBkZWxldGUgY29tcG9uZW50TWFwW29sZFJlZl1cbiAgICAvLyB9XG4gICAgLy8gdGhpcy5kYXRhLnJlZiA9IGRhdGEucmVmXG4gICAgLy8gY29tcG9uZW50TWFwW2RhdGEucmVmXSA9IHRoaXNcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjb21wb25lbnRNYW5hZ2VyLmdldEVsZW1lbnRCeVJlZihjaGlsZHJlbltpXS5yZWYpXG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgIGNoaWxkLnVwZGF0ZVJlY3Vyc2l2ZUFsbChkYXRhLmNoaWxkcmVuW2ldKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGF0dHI6IHt9LCAvLyBhdHRyIHNldHRlcnNcblxuICBzdHlsZTogT2JqZWN0LmNyZWF0ZShmbGV4Ym94KSwgLy8gc3R5bGUgc2V0dGVyc1xuXG4gIGNsZWFyQXR0cjogZnVuY3Rpb24gKCkge1xuICB9LFxuXG4gIGNsZWFyU3R5bGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm5vZGUuY3NzVGV4dCA9ICcnXG4gIH1cbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zdHlsZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gIC8vIEZvciB0aGUgZWxlbWVudHMgd2hvIGFyZSBmaXhlZCBlbGVtZW50cyBiZWZvcmUsIG5vd1xuICAvLyBhcmUgbm90IGZpeGVkOiB0aGUgZml4ZWRQbGFjZWhvbGRlciBoYXMgdG8gYmUgcmVwbGFjZWRcbiAgLy8gYnkgdGhpcyBlbGVtZW50LlxuICAvLyBUaGlzIGlzIGEgcGVhY2Ugb2YgaGFja2luZyB0byBmaXggdGhlIHByb2JsZW0gYWJvdXRcbiAgLy8gbWl4aW5nIGZpeGVkIGFuZCB0cmFuc2Zvcm0uIFNlZSAnaHR0cDovL3N0YWNrb3ZlcmZsb1xuICAvLyB3LmNvbS9xdWVzdGlvbnMvMTUxOTQzMTMvd2Via2l0LWNzcy10cmFuc2Zvcm0zZC1wb3NpXG4gIC8vIHRpb24tZml4ZWQtaXNzdWUnIGZvciBtb3JlIGluZm8uXG4gIGlmICh2YWx1ZSAhPT0gJ2ZpeGVkJykge1xuICAgIGlmICh0aGlzLmZpeGVkUGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmZpeGVkUGxhY2Vob2xkZXIucGFyZW50Tm9kZVxuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLm5vZGUsIHRoaXMuZml4ZWRQbGFjZWhvbGRlcilcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmZpeGVkUGxhY2Vob2xkZXIpXG4gICAgICB0aGlzLmZpeGVkUGxhY2Vob2xkZXIgPSBudWxsXG4gICAgfVxuICB9IGVsc2UgeyAvLyB2YWx1ZSA9PT0gJ2ZpeGVkJ1xuICAgIC8vIEZvciB0aGUgZWxlbWVudHMgd2hvIGFyZSBmaXhlZDogdGhpcyBmaXhlZFBsYWNlaG9sZGVyXG4gICAgLy8gc2hvdWQgYmUgaW5zZXJ0ZWQsIGFuZCB0aGUgZml4ZWQgZWxlbWVudCBpdHNlbGYgc2hvdWxkXG4gICAgLy8gYmUgcGxhY2VkIG91dCBpbiByb290IGNvbnRhaW5lci5cbiAgICB0aGlzLm5vZGUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgdmFyIHBhcmVudCA9IHRoaXMubm9kZS5wYXJlbnROb2RlXG4gICAgdmFyIHJlcGxhY2VXaXRoRml4ZWRQbGFjZWhvbGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZml4ZWRQbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICB0aGlzLmZpeGVkUGxhY2Vob2xkZXIuY2xhc3NMaXN0LmFkZCgnd2VleC1maXhlZC1wbGFjZWhvbGRlcicpXG4gICAgICB0aGlzLmZpeGVkUGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgdGhpcy5maXhlZFBsYWNlaG9sZGVyLnN0eWxlLndpZHRoID0gJzBweCdcbiAgICAgIHRoaXMuZml4ZWRQbGFjZWhvbGRlci5zdHlsZS5oZWlnaHQgPSAnMHB4J1xuICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLmZpeGVkUGxhY2Vob2xkZXIsIHRoaXMubm9kZSlcbiAgICAgIHRoaXMuZ2V0Um9vdENvbnRhaW5lcigpLmFwcGVuZENoaWxkKHRoaXMubm9kZSlcbiAgICB9LmJpbmQodGhpcylcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgaWYgKHRoaXMub25BcHBlbmQpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMub25BcHBlbmQuYmluZCh0aGlzKVxuICAgICAgfVxuICAgICAgdGhpcy5vbkFwcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5ub2RlLnBhcmVudE5vZGVcbiAgICAgICAgcmVwbGFjZVdpdGhGaXhlZFBsYWNlaG9sZGVyKClcbiAgICAgICAgcHJlICYmIHByZSgpXG4gICAgICB9LmJpbmQodGhpcylcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZVdpdGhGaXhlZFBsYWNlaG9sZGVyKClcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAodmFsdWUgPT09ICdzdGlja3knKSB7XG4gICAgdGhpcy5ub2RlLnN0eWxlLnpJbmRleCA9IDEwMFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5zdGlja3kgPSBuZXcgbGliLnN0aWNreSh0aGlzLm5vZGUsIHtcbiAgICAgICAgdG9wOiAwXG4gICAgICB9KVxuICAgIH0uYmluZCh0aGlzKSwgMClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGUuc3R5bGUucG9zaXRpb24gPSB2YWx1ZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50XG5cblxuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2NvbXBvbmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDI3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG4vLyBGbGV4Ym94IHBvbHlmaWxsXG52YXIgZmxleGJveFNldHRlcnMgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgQk9YX0FMSUdOID0ge1xuICAgIHN0cmV0Y2g6ICdzdHJldGNoJyxcbiAgICAnZmxleC1zdGFydCc6ICdzdGFydCcsXG4gICAgJ2ZsZXgtZW5kJzogJ2VuZCcsXG4gICAgY2VudGVyOiAnY2VudGVyJ1xuICB9XG4gIHZhciBCT1hfT1JJRU5UID0ge1xuICAgIHJvdzogJ2hvcml6b250YWwnLFxuICAgIGNvbHVtbjogJ3ZlcnRpY2FsJ1xuICB9XG4gIHZhciBCT1hfUEFDSyA9IHtcbiAgICAnZmxleC1zdGFydCc6ICdzdGFydCcsXG4gICAgJ2ZsZXgtZW5kJzogJ2VuZCcsXG4gICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAnc3BhY2UtYmV0d2Vlbic6ICdqdXN0aWZ5JyxcbiAgICAnc3BhY2UtYXJvdW5kJzogJ2p1c3RpZnknIC8vIEp1c3Qgc2FtZSBhcyBgc3BhY2UtYmV0d2VlbmBcbiAgfVxuICByZXR1cm4ge1xuICAgIGZsZXg6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEJveEZsZXggPSB2YWx1ZVxuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEZsZXggPSB2YWx1ZVxuICAgICAgdGhpcy5ub2RlLnN0eWxlLmZsZXggPSB2YWx1ZVxuICAgIH0sXG4gICAgYWxpZ25JdGVtczogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0Qm94QWxpZ24gPSBCT1hfQUxJR05bdmFsdWVdXG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0QWxpZ25JdGVtcyA9IHZhbHVlXG4gICAgICB0aGlzLm5vZGUuc3R5bGUuYWxpZ25JdGVtcyA9IHZhbHVlXG4gICAgfSxcbiAgICBhbGlnblNlbGY6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEFsaWduU2VsZiA9IHZhbHVlXG4gICAgICB0aGlzLm5vZGUuc3R5bGUuYWxpZ25TZWxmID0gdmFsdWVcbiAgICB9LFxuICAgIGZsZXhEaXJlY3Rpb246IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEJveE9yaWVudCA9IEJPWF9PUklFTlRbdmFsdWVdXG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0RmxleERpcmVjdGlvbiA9IHZhbHVlXG4gICAgICB0aGlzLm5vZGUuc3R5bGUuZmxleERpcmVjdGlvbiA9IHZhbHVlXG4gICAgfSxcbiAgICBqdXN0aWZ5Q29udGVudDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2Via2l0Qm94UGFjayA9IEJPWF9QQUNLW3ZhbHVlXVxuICAgICAgdGhpcy5ub2RlLnN0eWxlLndlYmtpdEp1c3RpZnlDb250ZW50ID0gdmFsdWVcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IHZhbHVlXG4gICAgfVxuICB9XG59KSgpXG5cbm1vZHVsZS5leHBvcnRzID0gZmxleGJveFNldHRlcnNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2ZsZXhib3guanNcbiAqKiBtb2R1bGUgaWQgPSAyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIE5PVF9QWF9OVU1CRVJfUFJPUEVSVElFUyA9IFsnZmxleCcsICdvcGFjaXR5JywgJ3pJbmRleCcsICdmb250V2VpZ2h0J11cblxudmFyIHZhbHVlRmlsdGVyID0ge1xuXG4gIGZpbHRlclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcywgY29uZmlnKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVzW2tleV1cbiAgICAgIHZhciBwYXJzZXIgPSB0aGlzLmdldEZpbHRlcnMoa2V5LCBjb25maWcpW3R5cGVvZiB2YWx1ZV1cbiAgICAgIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0eWxlc1trZXldID0gcGFyc2VyKHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXRGaWx0ZXJzOiBmdW5jdGlvbiAoa2V5LCBjb25maWcpIHtcblxuICAgIGlmIChOT1RfUFhfTlVNQkVSX1BST1BFUlRJRVMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbCAqIGNvbmZpZy5zY2FsZSArICdweCdcbiAgICAgIH0sXG4gICAgICBzdHJpbmc6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgLy8gc3RyaW5nIG9mIGEgcHVyZSBudW1iZXIgb3IgYSBudW1iZXIgc3VmZml4ZWQgd2l0aCBhICdweCcgdW5pdFxuICAgICAgICBpZiAodmFsLm1hdGNoKC9eXFwtP1xcZCpcXC4/XFxkKyg/OnB4KT8kLykpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWwpICogY29uZmlnLnNjYWxlICsgJ3B4J1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkubWF0Y2goL3RyYW5zZm9ybS8pICYmIHZhbC5tYXRjaCgvdHJhbnNsYXRlLykpIHtcbiAgICAgICAgICByZXR1cm4gdmFsLnJlcGxhY2UoL1xcZCpcXC4/XFxkK3B4L2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHBhcnNlRmxvYXQobWF0Y2gpICogY29uZmlnLnNjYWxlKSArICdweCdcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZUZpbHRlclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvdmFsdWVGaWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpICYmICh3aW5kb3cgPSB7Y3RybDoge30sIGxpYjoge319KTshd2luZG93LmN0cmwgJiYgKHdpbmRvdy5jdHJsID0ge30pOyF3aW5kb3cubGliICYmICh3aW5kb3cubGliID0ge30pOyFmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtyZXR1cm4gbnVsbCE9YSYmXCJvYmplY3RcIj09dHlwZW9mIGEmJk9iamVjdC5nZXRQcm90b3R5cGVPZihhKT09T2JqZWN0LnByb3RvdHlwZX1mdW5jdGlvbiBlKGEsYil7dmFyIGMsZCxlLGY9bnVsbCxnPTAsaD1mdW5jdGlvbigpe2c9RGF0ZS5ub3coKSxmPW51bGwsZT1hLmFwcGx5KGMsZCl9O3JldHVybiBmdW5jdGlvbigpe3ZhciBpPURhdGUubm93KCksaj1iLShpLWcpO3JldHVybiBjPXRoaXMsZD1hcmd1bWVudHMsMD49aj8oY2xlYXJUaW1lb3V0KGYpLGY9bnVsbCxnPWksZT1hLmFwcGx5KGMsZCkpOmZ8fChmPXNldFRpbWVvdXQoaCxqKSksZX19ZnVuY3Rpb24gZihhKXt2YXIgYj1cIlwiO3JldHVybiBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKGZ1bmN0aW9uKGMpe2IrPWMrXCI6XCIrYVtjXStcIjtcIn0pLGJ9ZnVuY3Rpb24gZyhhLGMpeyFjJiZkKGEpJiYoYz1hLGE9Yy5lbGVtZW50KSxjPWN8fHt9LGEubm9kZVR5cGUhPWIuRUxFTUVOVF9OT0RFJiZcInN0cmluZ1wiPT10eXBlb2YgYSYmKGE9Yi5xdWVyeVNlbGVjdG9yKGEpKTt2YXIgZT10aGlzO2UuZWxlbWVudD1hLGUudG9wPWMudG9wfHwwLGUud2l0aGluUGFyZW50PXZvaWQgMD09Yy53aXRoaW5QYXJlbnQ/ITE6Yy53aXRoaW5QYXJlbnQsZS5pbml0KCl9dmFyIGg9YS5wYXJzZUludCxpPW5hdmlnYXRvci51c2VyQWdlbnQsaj0hIWkubWF0Y2goL0ZpcmVmb3gvaSksaz0hIWkubWF0Y2goL0lFTW9iaWxlL2kpLGw9aj9cIi1tb3otXCI6az9cIi1tcy1cIjpcIi13ZWJraXQtXCIsbT1qP1wiTW96XCI6az9cIm1zXCI6XCJ3ZWJraXRcIixuPWZ1bmN0aW9uKCl7dmFyIGE9Yi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGM9YS5zdHlsZTtyZXR1cm4gYy5jc3NUZXh0PVwicG9zaXRpb246XCIrbCtcInN0aWNreTtwb3NpdGlvbjpzdGlja3k7XCIsLTEhPWMucG9zaXRpb24uaW5kZXhPZihcInN0aWNreVwiKX0oKTtnLnByb3RvdHlwZT17Y29uc3RydWN0b3I6Zyxpbml0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuZWxlbWVudCxjPWIuc3R5bGU7Y1ttK1wiVHJhbnNmb3JtXCJdPVwidHJhbnNsYXRlWigwKVwiLGMudHJhbnNmb3JtPVwidHJhbnNsYXRlWigwKVwiLGEuX29yaWdpbkNzc1RleHQ9Yy5jc3NUZXh0LG4/KGMucG9zaXRpb249bCtcInN0aWNreVwiLGMucG9zaXRpb249XCJzdGlja3lcIixjLnRvcD1hLnRvcCtcInB4XCIpOihhLl9zaW11bGF0ZVN0aWNreSgpLGEuX2JpbmRSZXNpemUoKSl9LF9iaW5kUmVzaXplOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcyxjPS9hbmRyb2lkL2dpLnRlc3QobmF2aWdhdG9yLmFwcFZlcnNpb24pLGQ9Yi5fcmVzaXplRXZlbnQ9XCJvbm9yaWVudGF0aW9uY2hhbmdlXCJpbiBhP1wib3JpZW50YXRpb25jaGFuZ2VcIjpcInJlc2l6ZVwiLGU9Yi5fcmVzaXplSGFuZGxlcj1mdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtiLnJlZnJlc2goKX0sYz8yMDA6MCl9O2EuYWRkRXZlbnRMaXN0ZW5lcihkLGUsITEpfSxyZWZyZXNoOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcztufHwoYS5fZGV0YWNoKCksYS5fc2ltdWxhdGVTdGlja3koKSl9LF9hZGRQbGFjZWhvbGRlcjpmdW5jdGlvbihhKXt2YXIgYyxkPXRoaXMsZT1kLmVsZW1lbnQsZz1hLnBvc2l0aW9uO2lmKC0xIT1bXCJzdGF0aWNcIixcInJlbGF0aXZlXCJdLmluZGV4T2YoZykpe2M9ZC5fcGxhY2Vob2xkZXJFbGVtZW50PWIuY3JlYXRlRWxlbWVudChcImRpdlwiKTt2YXIgaT1oKGEud2lkdGgpK2goYS5tYXJnaW5MZWZ0KStoKGEubWFyZ2luUmlnaHQpLGo9aChhLmhlaWdodCk7XCJib3JkZXItYm94XCIhPWEuYm94U2l6aW5nJiYoaSs9aChhLmJvcmRlckxlZnRXaWR0aCkraChhLmJvcmRlclJpZ2h0V2lkdGgpK2goYS5wYWRkaW5nTGVmdCkraChhLnBhZGRpbmdSaWdodCksais9aChhLmJvcmRlclRvcFdpZHRoKStoKGEuYm9yZGVyQm90dG9tV2lkdGgpK2goYS5wYWRkaW5nVG9wKStoKGEucGFkZGluZ0JvdHRvbSkpLGMuc3R5bGUuY3NzVGV4dD1mKHtkaXNwbGF5Olwibm9uZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIix3aWR0aDppK1wicHhcIixoZWlnaHQ6aitcInB4XCIsbWFyZ2luOjAsXCJtYXJnaW4tdG9wXCI6YS5tYXJnaW5Ub3AsXCJtYXJnaW4tYm90dG9tXCI6YS5tYXJnaW5Cb3R0b20sYm9yZGVyOjAscGFkZGluZzowLFwiZmxvYXRcIjphW1wiZmxvYXRcIl18fGEuY3NzRmxvYXR9KSxlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGMsZSl9cmV0dXJuIGN9LF9zaW11bGF0ZVN0aWNreTpmdW5jdGlvbigpe3ZhciBjPXRoaXMsZD1jLmVsZW1lbnQsZz1jLnRvcCxpPWQuc3R5bGUsaj1kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGs9Z2V0Q29tcHV0ZWRTdHlsZShkLFwiXCIpLGw9ZC5wYXJlbnROb2RlLG09Z2V0Q29tcHV0ZWRTdHlsZShsLFwiXCIpLG49Yy5fYWRkUGxhY2Vob2xkZXIoayksbz1jLndpdGhpblBhcmVudCxwPWMuX29yaWdpbkNzc1RleHQscT1qLnRvcC1nK2EucGFnZVlPZmZzZXQscj1sLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbS1oKG0ucGFkZGluZ0JvdHRvbSktaChtLmJvcmRlckJvdHRvbVdpZHRoKS1oKGsubWFyZ2luQm90dG9tKS1qLmhlaWdodC1nK2EucGFnZVlPZmZzZXQscz1wK2Yoe3Bvc2l0aW9uOlwiZml4ZWRcIix0b3A6ZytcInB4XCIsd2lkdGg6ay53aWR0aCxcIm1hcmdpbi10b3BcIjowfSksdD1wK2Yoe3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6citcInB4XCIsd2lkdGg6ay53aWR0aH0pLHU9MSx2PWMuX3Njcm9sbEhhbmRsZXI9ZShmdW5jdGlvbigpe3ZhciBiPWEucGFnZVlPZmZzZXQ7cT5iPzEhPXUmJihpLmNzc1RleHQ9cCxuJiYobi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiKSx1PTEpOiFvJiZiPj1xfHxvJiZiPj1xJiZyPmI/MiE9dSYmKGkuY3NzVGV4dD1zLG4mJjMhPXUmJihuLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiKSx1PTIpOm8mJjMhPXUmJihpLmNzc1RleHQ9dCxuJiYyIT11JiYobi5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIiksdT0zKX0sMTAwKTtpZihhLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIix2LCExKSxhLnBhZ2VZT2Zmc2V0Pj1xKXt2YXIgdz1iLmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKTt3LmluaXRFdmVudChcInNjcm9sbFwiLCEwLCEwKSxhLmRpc3BhdGNoRXZlbnQodyl9fSxfZGV0YWNoOmZ1bmN0aW9uKCl7dmFyIGI9dGhpcyxjPWIuZWxlbWVudDtpZihjLnN0eWxlLmNzc1RleHQ9Yi5fb3JpZ2luQ3NzVGV4dCwhbil7dmFyIGQ9Yi5fcGxhY2Vob2xkZXJFbGVtZW50O2QmJmMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkKSxhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIixiLl9zY3JvbGxIYW5kbGVyLCExKX19LGRlc3Ryb3k6ZnVuY3Rpb24oKXt2YXIgYj10aGlzO2IuX2RldGFjaCgpO3ZhciBjPWIuZWxlbWVudC5zdHlsZTtjLnJlbW92ZVByb3BlcnR5KGwrXCJ0cmFuc2Zvcm1cIiksYy5yZW1vdmVQcm9wZXJ0eShcInRyYW5zZm9ybVwiKSxufHxhLnJlbW92ZUV2ZW50TGlzdGVuZXIoYi5fcmVzaXplRXZlbnQsYi5fcmVzaXplSGFuZGxlciwhMSl9fSxjLnN0aWNreT1nfSh3aW5kb3csZG9jdW1lbnQsd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKTs7bW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cubGliWydzdGlja3knXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L34vZml4ZWRzdGlja3kvYnVpbGQvc3RpY2t5LmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDMwXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG5cbnZhciBfc2VuZGVyTWFwID0ge31cblxuZnVuY3Rpb24gU2VuZGVyKGluc3RhbmNlKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBTZW5kZXIoaW5zdGFuY2UpXG4gIH1cbiAgdGhpcy5pbnN0YW5jZUlkID0gaW5zdGFuY2UuaW5zdGFuY2VJZFxuICB0aGlzLndlZXhJbnN0YW5jZSA9IGluc3RhbmNlXG4gIF9zZW5kZXJNYXBbdGhpcy5pbnN0YW5jZUlkXSA9IHRoaXNcbn1cblxuZnVuY3Rpb24gX3NlbmQoaW5zdGFuY2VJZCwgbXNnKSB7XG4gIGNhbGxKUyhpbnN0YW5jZUlkLCBbbXNnXSlcbn1cblxuU2VuZGVyLmdldFNlbmRlciA9IGZ1bmN0aW9uIChpbnN0YW5jZUlkKSB7XG4gIHJldHVybiBfc2VuZGVyTWFwW2luc3RhbmNlSWRdXG59XG5cblNlbmRlci5wcm90b3R5cGUgPSB7XG5cbiAgLy8gcGVyZm9ybSBhIGNhbGxiYWNrIHRvIGpzZnJhbWV3b3JrLlxuICBwZXJmb3JtQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFja0lkLCBkYXRhLCBrZWVwQWxpdmUpIHtcbiAgICB2YXIgYXJncyA9IFtjYWxsYmFja0lkXVxuICAgIGRhdGEgJiYgYXJncy5wdXNoKGRhdGEpXG4gICAga2VlcEFsaXZlICYmIGFyZ3MucHVzaChrZWVwQWxpdmUpXG4gICAgX3NlbmQodGhpcy5pbnN0YW5jZUlkLCB7XG4gICAgICBtZXRob2Q6ICdjYWxsYmFjaycsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSlcbiAgfSxcblxuICBmaXJlRXZlbnQ6IGZ1bmN0aW9uIChyZWYsIHR5cGUsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50Ll9hbHJlYWR5RmlyZWQpIHtcbiAgICAgIC8vIHN0b3AgYnViYmxpbmcgdXAgaW4gdmlydHVhbCBkb20gdHJlZS5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBkbyBub3QgcHJldmVudCBkZWZhdWx0LCBvdGhlcndpc2UgdGhlIHRvdWNoc3RhcnRcbiAgICAvLyBldmVudCB3aWxsIG5vIGxvbmdlciB0cmlnZ2VyIGEgY2xpY2sgZXZlbnRcbiAgICBldmVudC5fYWxyZWFkeUZpcmVkID0gdHJ1ZVxuICAgIHZhciBldnQgPSB1dGlscy5leHRlbmQoe30sIGV2ZW50KVxuICAgIC8vIFRoZSBldmVudC50YXJnZXQgbXVzdCBiZSB0aGUgc3RhbmRhcmQgZXZlbnQncyBjdXJyZW50VGFyZ2V0LlxuICAgIGV2dC50YXJnZXQgPSBldnQuY3VycmVudFRhcmdldFxuICAgIGV2dC52YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgIGV2dC50aW1lc3RhbXAgPSBEYXRlLm5vdygpXG4gICAgX3NlbmQodGhpcy5pbnN0YW5jZUlkLCB7XG4gICAgICBtZXRob2Q6ICdmaXJlRXZlbnQnLFxuICAgICAgYXJnczogW3JlZiwgdHlwZSwgZXZ0XVxuICAgIH0pXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2JyaWRnZS9zZW5kZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpXG52YXIgcHJvdG9jb2wgPSByZXF1aXJlKCcuLi9wcm90b2NvbCcpXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG52YXIgRnJhbWVVcGRhdGVyID0gcmVxdWlyZSgnLi4vZnJhbWVVcGRhdGVyJylcbnZhciBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpXG5cbnZhciBjYWxsUXVldWUgPSBbXVxuLy8gTmVlZCBhIHRhc2sgY291bnRlcj9cbi8vIFdoZW4gRnJhbWVVcGRhdGVyIGlzIG5vdCBhY3RpdmF0ZWQsIHRhc2tzIHdpbGwgbm90IGJlIHB1c2hcbi8vIGludG8gY2FsbFF1ZXVlIGFuZCB0aGVyZSB3aWxsIGJlIG5vIHRyYWNlIGZvciBzaXR1YXRpb24gb2Zcbi8vIGV4ZWN1dGlvbiBvZiB0YXNrcy5cblxuLy8gZ2l2ZSAxMG1zIGZvciBjYWxsIGhhbmRsaW5nLCBhbmQgcmVzdCA2bXMgZm9yIG90aGVyc1xudmFyIE1BWF9USU1FX0ZPUl9FQUNIX0ZSQU1FID0gMTBcblxuLy8gY2FsbE5hdGl2ZToganNGcmFtZXdvcmsgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIHRvIHRhbGsgdG9cbi8vIHRoaXMgcmVuZGVyZXIuXG4vLyBwYXJhbXM6XG4vLyAgLSBpbnN0YW5jZUlkOiBzdHJpbmcuXG4vLyAgLSB0YXNrczogYXJyYXkgb2Ygb2JqZWN0LlxuLy8gIC0gY2FsbGJhY2tJZDogbnVtYmVyLlxuZnVuY3Rpb24gY2FsbE5hdGl2ZShpbnN0YW5jZUlkLCB0YXNrcywgY2FsbGJhY2tJZCkge1xuICB2YXIgY2FsbHMgPSBbXVxuICBpZiAodHlwZW9mIHRhc2tzID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBjYWxscyA9IEpTT04ucGFyc2UodGFza3MpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignaW52YWxpZCB0YXNrczonLCB0YXNrcylcbiAgICB9XG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhc2tzKS5zbGljZSg4LCAtMSkgPT09ICdBcnJheScpIHtcbiAgICBjYWxscyA9IHRhc2tzXG4gIH1cbiAgdmFyIGxlbiA9IGNhbGxzLmxlbmd0aFxuICBjYWxsc1tsZW4gLSAxXS5jYWxsYmFja0lkID0gKCFjYWxsYmFja0lkICYmIGNhbGxiYWNrSWQgIT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNhbGxiYWNrSWRcbiAgLy8gVG8gc29sdmUgdGhlIHByb2JsZW0gb2YgY2FsbGFwcCwgdGhlIHR3by13YXkgdGltZSBsb29wIHJ1bGUgbXVzdFxuICAvLyBiZSByZXBsYWNlZCBieSBjYWxsaW5nIGRpcmVjdGx5IGV4Y2VwdCB0aGUgc2l0dWF0aW9uIG9mIHBhZ2UgbG9hZGluZy5cbiAgLy8gMjAxNS0xMS0wM1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKEZyYW1lVXBkYXRlci5pc0FjdGl2ZSgpKSB7XG4gICAgICBjYWxsUXVldWUucHVzaCh7XG4gICAgICAgIGluc3RhbmNlSWQ6IGluc3RhbmNlSWQsXG4gICAgICAgIGNhbGw6IGNhbGxzW2ldXG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHByb2Nlc3NDYWxsKGluc3RhbmNlSWQsIGNhbGxzW2ldKVxuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDYWxsUXVldWUoKSB7XG4gIHZhciBsZW4gPSBjYWxsUXVldWUubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpXG4gIHZhciBlbGFwc2VkID0gMFxuXG4gIHdoaWxlICgtLWxlbiA+PSAwICYmIGVsYXBzZWQgPCBNQVhfVElNRV9GT1JfRUFDSF9GUkFNRSkge1xuICAgIHZhciBjYWxsT2JqID0gY2FsbFF1ZXVlLnNoaWZ0KClcbiAgICBwcm9jZXNzQ2FsbChjYWxsT2JqLmluc3RhbmNlSWQsIGNhbGxPYmouY2FsbClcbiAgICBlbGFwc2VkID0gRGF0ZS5ub3coKSAtIHN0YXJ0XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NhbGwoaW5zdGFuY2VJZCwgY2FsbCkge1xuICB2YXIgbW9kdWxlTmFtZSA9IGNhbGwubW9kdWxlXG4gIHZhciBtZXRob2ROYW1lID0gY2FsbC5tZXRob2RcbiAgdmFyIG1vZHVsZSwgbWV0aG9kXG4gIHZhciBhcmdzID0gY2FsbC5hcmdzIHx8IGNhbGwuYXJndW1lbnRzIHx8IFtdXG5cbiAgaWYgKCEobW9kdWxlID0gcHJvdG9jb2wuYXBpTW9kdWxlW21vZHVsZU5hbWVdKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICghKG1ldGhvZCA9IG1vZHVsZVttZXRob2ROYW1lXSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIG1ldGhvZC5hcHBseShwcm90b2NvbC5nZXRXZWV4SW5zdGFuY2UoaW5zdGFuY2VJZCksIGFyZ3MpXG5cbiAgdmFyIGNhbGxiYWNrSWQgPSBjYWxsLmNhbGxiYWNrSWRcbiAgaWYgKChjYWxsYmFja0lkXG4gICAgfHwgY2FsbGJhY2tJZCA9PT0gMFxuICAgIHx8IGNhbGxiYWNrSWQgPT09ICcwJylcbiAgICAmJiBjYWxsYmFja0lkICE9PSAnLTEnXG4gICAgJiYgY2FsbGJhY2tJZCAhPT0gLTEpIHtcbiAgICBwZXJmb3JtTmV4dFRpY2soaW5zdGFuY2VJZCwgY2FsbGJhY2tJZClcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtTmV4dFRpY2soaW5zdGFuY2VJZCwgY2FsbGJhY2tJZCkge1xuICBTZW5kZXIuZ2V0U2VuZGVyKGluc3RhbmNlSWQpLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkKVxufVxuXG5mdW5jdGlvbiBuYXRpdmVMb2coKSB7XG4gIGlmIChjb25maWcuZGVidWcpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdLm1hdGNoKC9ecGVyZi8pKSB7XG4gICAgICBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnNvbGUuZGVidWcuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4cG9ydHNCcmlkZ2VNZXRob2RzVG9HbG9iYWwoKSB7XG4gIGdsb2JhbC5jYWxsTmF0aXZlID0gY2FsbE5hdGl2ZVxuICBnbG9iYWwubmF0aXZlTG9nID0gbmF0aXZlTG9nXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHByb2Nlc3MgY2FsbFF1ZXVlIGV2ZXJ5IDE2IG1pbGxpc2Vjb25kcy5cbiAgICBGcmFtZVVwZGF0ZXIuYWRkVXBkYXRlT2JzZXJ2ZXIocHJvY2Vzc0NhbGxRdWV1ZSlcbiAgICBGcmFtZVVwZGF0ZXIuc3RhcnQoKVxuXG4gICAgLy8gZXhwb3J0cyBtZXRob2RzIHRvIGdsb2JhbCh3aW5kb3cpLlxuICAgIGV4cG9ydHNCcmlkZ2VNZXRob2RzVG9HbG9iYWwoKVxuICB9XG5cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2JyaWRnZS9yZWNlaXZlci5qc1xuICoqIG1vZHVsZSBpZCA9IDMyXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsInZhciBSb290Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9yb290JylcbnZhciBDb250YWluZXIgPSByZXF1aXJlKCcuL2NvbnRhaW5lcicpXG52YXIgSW1hZ2UgPSByZXF1aXJlKCcuL2ltYWdlJylcbnZhciBUZXh0ID0gcmVxdWlyZSgnLi90ZXh0JylcbnZhciBWbGlzdCA9IHJlcXVpcmUoJy4vdmxpc3QnKVxudmFyIEhsaXN0ID0gcmVxdWlyZSgnLi9obGlzdCcpXG52YXIgQ291bnRkb3duID0gcmVxdWlyZSgnLi9jb3VudGRvd24nKVxudmFyIE1hcnF1ZWUgPSByZXF1aXJlKCcuL21hcnF1ZWUnKVxudmFyIFNsaWRlciA9IHJlcXVpcmUoJy4vc2xpZGVyJylcbnZhciBJbmRpY2F0b3IgPSByZXF1aXJlKCcuL2luZGljYXRvcicpXG52YXIgVGFiaGVhZGVyID0gcmVxdWlyZSgnLi90YWJoZWFkZXInKVxudmFyIFNjcm9sbGVyID0gcmVxdWlyZSgnLi9zY3JvbGxlcicpXG52YXIgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0JylcbnZhciBTZWxlY3QgPSByZXF1aXJlKCcuL3NlbGVjdCcpXG52YXIgRGF0ZXBpY2tlciA9IHJlcXVpcmUoJy4vZGF0ZXBpY2tlcicpXG52YXIgVGltZXBpY2tlciA9IHJlcXVpcmUoJy4vdGltZXBpY2tlcicpXG52YXIgVmlkZW8gPSByZXF1aXJlKCcuL3ZpZGVvJylcbnZhciBTd2l0Y2ggPSByZXF1aXJlKCcuL3N3aXRjaCcpXG52YXIgQSA9IHJlcXVpcmUoJy4vYScpXG52YXIgRW1iZWQgPSByZXF1aXJlKCcuL2VtYmVkJylcbnZhciBSZWZyZXNoID0gcmVxdWlyZSgnLi9yZWZyZXNoJylcbnZhciBMb2FkaW5nID0gcmVxdWlyZSgnLi9sb2FkaW5nJylcbnZhciBTcGlubmVyID0gcmVxdWlyZSgnLi9zcGlubmVyJylcbnZhciBXZWIgPSByZXF1aXJlKCcuL3dlYicpXG5cbnZhciBjb21wb25lbnRzID0ge1xuICBpbml0OiBmdW5jdGlvbiAoV2VleCkge1xuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3Jvb3QnLCBSb290Q29tcG9uZW50KVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2NvbnRhaW5lcicsIENvbnRhaW5lcilcbiAgICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdkaXYnLCBDb250YWluZXIpXG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnaW1hZ2UnLCBJbWFnZSlcbiAgICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCd0ZXh0JywgVGV4dClcbiAgICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdsaXN0JywgVmxpc3QpXG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgndmxpc3QnLCBWbGlzdClcbiAgICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdobGlzdCcsIEhsaXN0KVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2NvdW50ZG93bicsIENvdW50ZG93bilcbiAgICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdtYXJxdWVlJywgTWFycXVlZSlcbiAgICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdzbGlkZXInLCBTbGlkZXIpXG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnaW5kaWNhdG9yJywgSW5kaWNhdG9yKVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3RhYmhlYWRlcicsIFRhYmhlYWRlcilcbiAgICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdzY3JvbGxlcicsIFNjcm9sbGVyKVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2lucHV0JywgSW5wdXQpXG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnc2VsZWN0JywgU2VsZWN0KVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2RhdGVwaWNrZXInLCBEYXRlcGlja2VyKVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3RpbWVwaWNrZXInLCBUaW1lcGlja2VyKVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3ZpZGVvJywgVmlkZW8pXG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnc3dpdGNoJywgU3dpdGNoKVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2EnLCBBKVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ2VtYmVkJywgRW1iZWQpXG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgncmVmcmVzaCcsIFJlZnJlc2gpXG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnbG9hZGluZycsIExvYWRpbmcpXG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnc3Bpbm5lcicsIFNwaW5uZXIpXG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnbG9hZGluZy1pbmRpY2F0b3InLCBTcGlubmVyKVxuICAgIFdlZXgucmVnaXN0ZXJDb21wb25lbnQoJ3dlYicsIFdlYilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBvbmVudHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIENvbXBvbmVudE1hbmFnZXIgPSByZXF1aXJlKCcuLi9jb21wb25lbnRNYW5hZ2VyJylcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudCcpXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJylcblxudmFyIHJvb3RDYW5kaWRhdGVzID0gWydkaXYnLCAnbGlzdCcsICd2bGlzdCcsICdzY3JvbGxlciddXG5cbmZ1bmN0aW9uIFJvb3RDb21wb25lbnQoZGF0YSwgbm9kZVR5cGUpIHtcbiAgdmFyIGlkID0gZGF0YS5yb290SWQgKyAnLXJvb3QnXG4gIHZhciBjb21wb25lbnRNYW5hZ2VyID0gQ29tcG9uZW50TWFuYWdlci5nZXRJbnN0YW5jZShkYXRhLmluc3RhbmNlSWQpXG5cbiAgLy8gSWYgbm9kZVR5cGUgaXMgaW4gdGhlIGRvd25ncmFkZXMgbWFwLCBqdXN0IGlnbm9yZSBpdCBhbmRcbiAgLy8gcmVwbGFjZSBpdCB3aXRoIGEgZGl2IGNvbXBvbmVudC5cbiAgdmFyIGRvd25ncmFkZXMgPSBjb21wb25lbnRNYW5hZ2VyLndlZXhJbnN0YW5jZS5kb3duZ3JhZGVzXG4gIHRoaXMuZGF0YSA9IGRhdGFcblxuICAvLyBJbiBzb21lIHNpdHVhdGlvbiB0aGUgcm9vdCBjb21wb25lbnQgc2hvdWxkIGJlIGltcGxlbWVudGVkIGFzXG4gIC8vIGl0cyBvd24gdHlwZSwgb3RoZXJ3aXNlIGl0IGhhcyB0byBiZSBhIGRpdiBjb21wb25lbnQgYXMgYSByb290LlxuICBpZiAoIW5vZGVUeXBlKSB7XG4gICAgbm9kZVR5cGUgPSAnZGl2J1xuICB9IGVsc2UgaWYgKHJvb3RDYW5kaWRhdGVzLmluZGV4T2Yobm9kZVR5cGUpID09PSAtMSkge1xuICAgIGxvZ2dlci53YXJuKCd0aGUgcm9vdCBjb21wb25lbnQgdHlwZSBcXCcnICsgbm9kZVR5cGUgKyAnXFwnIGlzIG5vdCBvbmUgb2YgJ1xuICAgICAgKyAndGhlIHR5cGVzIGluIFsnICsgcm9vdENhbmRpZGF0ZXMgKyAnXSBsaXN0LiBJdCBpcyBhdXRvIGRvd25ncmFkZWQgJ1xuICAgICAgKyAndG8gXFwnZGl2XFwnLicpXG4gICAgbm9kZVR5cGUgPSAnZGl2J1xuICB9IGVsc2UgaWYgKGRvd25ncmFkZXNbbm9kZVR5cGVdKSB7XG4gICAgbG9nZ2VyLndhcm4oJ1RoYW5rcyB0byB0aGUgZG93bmdyYWRlIGZsYWdzIGZvciBbJ1xuICAgICAgKyBPYmplY3Qua2V5cyhkb3duZ3JhZGVzKVxuICAgICAgKyAnXSwgdGhlIHJvb3QgY29tcG9uZW50IHR5cGUgXFwnJyArIG5vZGVUeXBlXG4gICAgICArICdcXCcgaXMgYXV0byBkb3duZ3JhZGVkIHRvIFxcJ2RpdlxcJy4nKVxuICAgIG5vZGVUeXBlID0gJ2RpdidcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgcm9vdCBjb21wb25lbnQgaXMgbm90IGEgZW1iZWQgZWxlbWVudCBpbiBhIHdlYnBhZ2UsIHRoZW5cbiAgICAvLyB0aGUgaHRtbCBhbmQgYm9keSBoZWlnaHQgc2hvdWxkIGJlIGZpeGVkIHRvIHRoZSBtYXggaGVpZ2h0XG4gICAgLy8gb2Ygdmlld3BvcnQuXG4gICAgaWYgKCFjb21wb25lbnRNYW5hZ2VyLndlZXhJbnN0YW5jZS5lbWJlZCkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbmRlcmVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXRlY3RSb290SGVpZ2h0KClcbiAgICAgIH0uYmluZCh0aGlzKSlcbiAgICB9XG4gICAgaWYgKG5vZGVUeXBlICE9PSAnZGl2Jykge1xuICAgICAgbG9nZ2VyLndhcm4oJ3RoZSByb290IGNvbXBvbmVudCB0eXBlIFxcJycgKyBub2RlVHlwZSArICdcXCcgbWF5IGhhdmUgJ1xuICAgICAgICArICdzb21lIHBlcmZvcm1hbmNlIGlzc3VlIG9uIHNvbWUgb2YgdGhlIGFuZHJvaWQgZGV2aWNlcyB3aGVuIHRoZXJlICdcbiAgICAgICAgKyAnaXMgYSBodWdlIGFtb3VudCBvZiBkb20gZWxlbWVudHMuIFRyeSB0byBhZGQgZG93bmdyYWRlICdcbiAgICAgICAgKyAnZmxhZ3MgYnkgYWRkaW5nIHBhcmFtIFxcJ2Rvd25ncmFkZV8nICsgbm9kZVR5cGUgKyAnPXRydWVcXCcgaW4gdGhlICdcbiAgICAgICAgKyAndXJsIG9yIHNldHRpbmcgZG93bmdyYWRlIGNvbmZpZyB0byBhIGFycmF5IGNvbnRhaW5zIFxcJycgKyBub2RlVHlwZVxuICAgICAgICArICdcXCcgaW4gdGhlIFxcJ3dlZXguaW5pdFxcJyBmdW5jdGlvbi4gVGhpcyB3aWxsIGRvd25ncmFkZSB0aGUgcm9vdCBcXCcnXG4gICAgICAgICsgbm9kZVR5cGUgKyAnXFwnIHRvIGEgXFwnZGl2XFwnLCBhbmQgbWF5IGVsZXZhdGUgdGhlIGxldmVsIG9mICdcbiAgICAgICAgKyAncGVyZm9ybWFuY2UsIGFsdGhvdWdoIGl0IGhhcyBzb21lIG90aGVyIGlzc3Vlcy4nKVxuICAgIH1cbiAgICAhdGhpcy5kYXRhLnN0eWxlLmhlaWdodCAmJiAodGhpcy5kYXRhLnN0eWxlLmhlaWdodCA9ICcxMDAlJylcbiAgfVxuXG4gIGRhdGEudHlwZSA9IG5vZGVUeXBlXG4gIHZhciBjbXAgPSBjb21wb25lbnRNYW5hZ2VyLmNyZWF0ZUVsZW1lbnQoZGF0YSlcbiAgY21wLm5vZGUuaWQgPSBpZFxuICByZXR1cm4gY21wXG59XG5cblJvb3RDb21wb25lbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuXG5Sb290Q29tcG9uZW50LnByb3RvdHlwZS5kZXRlY3RSb290SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcm9vdFF1ZXJ5ID0gJyMnICsgdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKCkud2VleEluc3RhbmNlLnJvb3RJZFxuICB2YXIgcm9vdENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdFF1ZXJ5KSB8fCBkb2N1bWVudC5ib2R5XG4gIHZhciBoZWlnaHQgPSByb290Q29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICBpZiAoaGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgbG9nZ2VyLndhcm4oW1xuICAgICAgJ2ZvciBzY3JvbGxhYmxlIHJvb3QgbGlrZSBcXCdsaXN0XFwnIGFuZCBcXCdzY3JvbGxlclxcJywgdGhlIGhlaWdodCBvZiAnLFxuICAgICAgJ3RoZSByb290IGNvbnRhaW5lciBtdXN0IGJlIGEgdXNlci1zcGVjaWZpZWQgdmFsdWUuIE90aGVyd2lzZSAnLFxuICAgICAgJ3RoZSBzY3JvbGxhYmxlIGVsZW1lbnQgbWF5IG5vdCBiZSBhYmxlIHRvIHdvcmsgY29ycmVjdGx5LiAnLFxuICAgICAgJ0N1cnJlbnQgaGVpZ2h0IG9mIHRoZSByb290IGVsZW1lbnQgXFwnJyArIHJvb3RRdWVyeSArICdcXCcgaXMgJyxcbiAgICAgIGhlaWdodCArICdweCwgYW5kIG1vc3RseSBpdHMgaGVpZ2h0IHNob3VsZCBiZSBsZXNzIHRoYW4gdGhlICcsXG4gICAgICAndmlld3BvcnRcXCdzIGhlaWdodCAnICsgd2luZG93LmlubmVySGVpZ2h0ICsgJ3B4LiBQbGVhc2UgJyxcbiAgICAgICdtYWtlIHN1cmUgdGhlIGhlaWdodCBpcyBjb3JyZWN0LidcbiAgICAgIF0uam9pbignJykpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSb290Q29tcG9uZW50XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3Jvb3QuanNcbiAqKiBtb2R1bGUgaWQgPSAzNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxucmVxdWlyZSgnLi4vc3R5bGVzL2NvbnRhaW5lci5jc3MnKVxuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnQnKVxuXG5mdW5jdGlvbiBDb250YWluZXIgKGRhdGEsIG5vZGVUeXBlKSB7XG4gIENvbXBvbmVudC5jYWxsKHRoaXMsIGRhdGEsIG5vZGVUeXBlKVxuICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInKVxufVxuXG5Db250YWluZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhaW5lclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9jb250YWluZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY29udGFpbmVyLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY29udGFpbmVyLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY29udGFpbmVyLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2NvbnRhaW5lci5jc3NcbiAqKiBtb2R1bGUgaWQgPSAzNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlZXgtY29udGFpbmVyIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJvcmRlcjogMCBzb2xpZCBibGFjaztcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbi53ZWV4LWVsZW1lbnQge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2NvbnRhaW5lci5jc3NcbiAqKiBtb2R1bGUgaWQgPSAzN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIEF0b21pYyA9IHJlcXVpcmUoJy4vYXRvbWljJylcbnZhciBMYXp5TG9hZCA9IHJlcXVpcmUoJy4uL2xhenlMb2FkJylcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKVxuXG5yZXF1aXJlKCcuLi9zdHlsZXMvaW1hZ2UuY3NzJylcblxudmFyIERFRkFVTFRfU0laRSA9IDIwMFxudmFyIFJFU0laRV9NT0RFUyA9IFsnc3RyZXRjaCcsICdjb3ZlcicsICdjb250YWluJ11cbnZhciBERUZBVUxUX1JFU0laRV9NT0RFID0gJ3N0cmV0Y2gnXG5cbi8qKlxuICogcmVzaXplOiAnY292ZXInIHwgJ2NvbnRhaW4nIHwgJ3N0cmV0Y2gnLCBkZWZhdWx0IGlzICdzdHJldGNoJ1xuICogc3JjOiB1cmxcbiAqL1xuXG5mdW5jdGlvbiBJbWFnZSAoZGF0YSkge1xuICB0aGlzLnJlc2l6ZSA9IERFRkFVTFRfUkVTSVpFX01PREVcbiAgQXRvbWljLmNhbGwodGhpcywgZGF0YSlcbn1cblxuSW1hZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlKVxuXG5JbWFnZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1pbWcnKVxuICByZXR1cm4gbm9kZVxufVxuXG5JbWFnZS5wcm90b3R5cGUuYXR0ciA9IHtcbiAgc3JjOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKCF0aGlzLnNyYykge1xuICAgICAgdGhpcy5zcmMgPSBsaWIuaW1nLmRlZmF1bHRTcmNcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKCcgKyB0aGlzLnNyYyArICcpJ1xuICAgIH1cbiAgICBMYXp5TG9hZC5tYWtlSW1hZ2VMYXp5KHRoaXMubm9kZSwgdmFsKVxuICB9LFxuXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmIChSRVNJWkVfTU9ERVMuaW5kZXhPZih2YWwpID09PSAtMSkge1xuICAgICAgdmFsID0gJ3N0cmV0Y2gnXG4gICAgfVxuICAgIHRoaXMubm9kZS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IHZhbCA9PT0gJ3N0cmV0Y2gnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcxMDAlIDEwMCUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbFxuICB9XG59XG5cbkltYWdlLnByb3RvdHlwZS5zdHlsZSA9IHV0aWxzLmV4dGVuZChPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUuc3R5bGUpLCB7XG4gIHdpZHRoOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpICogdGhpcy5kYXRhLnNjYWxlXG4gICAgaWYgKHZhbCA8IDAgfHwgdmFsICE9PSB2YWwpIHtcbiAgICAgIHZhbCA9IERFRkFVTFRfU0laRVxuICAgIH1cbiAgICB0aGlzLm5vZGUuc3R5bGUud2lkdGggPSB2YWwgKyAncHgnXG4gIH0sXG5cbiAgaGVpZ2h0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpICogdGhpcy5kYXRhLnNjYWxlXG4gICAgaWYgKHZhbCA8IDAgfHwgdmFsICE9PSB2YWwpIHtcbiAgICAgIHZhbCA9IERFRkFVTFRfU0laRVxuICAgIH1cbiAgICB0aGlzLm5vZGUuc3R5bGUuaGVpZ2h0ID0gdmFsICsgJ3B4J1xuICB9XG59KVxuXG5JbWFnZS5wcm90b3R5cGUuY2xlYXJBdHRyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNyYyA9ICcnXG4gIHRoaXMubm9kZS5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAnJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2ltYWdlLmpzXG4gKiogbW9kdWxlIGlkID0gMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudCcpXG5cbi8vIENvbXBvbmVudCB3aGljaCBjYW4gaGF2ZSBubyBzdWJjb21wb25lbnRzLlxuLy8gVGhpcyBjb21wb25lbnQgc2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHksIHNpbmNlXG4vLyBpdCBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIGFzIGEgYmFzZSBjbGFzcyB0byBleHRlbmQgZnJvbS5cbmZ1bmN0aW9uIEF0b21pYyAoZGF0YSkge1xuICBDb21wb25lbnQuY2FsbCh0aGlzLCBkYXRhKVxufVxuXG5BdG9taWMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuXG5BdG9taWMucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gZG8gbm90aGluZ1xuICByZXR1cm5cbn1cblxuQXRvbWljLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiAoY2hpbGQsIGJlZm9yZSkge1xuICAvLyBkbyBub3RoaW5nXG4gIHJldHVyblxufVxuXG5BdG9taWMucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gIC8vIGRvIG5vdGhpbmdcbiAgcmV0dXJuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXRvbWljXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2F0b21pYy5qc1xuICoqIG1vZHVsZSBpZCA9IDM5XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbWFnZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2ltYWdlLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW1hZ2UuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvaW1hZ2UuY3NzXG4gKiogbW9kdWxlIGlkID0gNDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi53ZWV4LWltZyB7XFxuXFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXNpemU6IDEwMCUgMTAwJTtcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IDUwJTtcXG4gIGJvcmRlcjogMCBzb2xpZCBibGFjaztcXG59XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2ltYWdlLmNzc1xuICoqIG1vZHVsZSBpZCA9IDQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQXRvbWljID0gcmVxdWlyZSgnLi9jb21wb25lbnQnKVxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKVxuXG52YXIgREVGQVVMVF9GT05UX1NJWkUgPSAzMlxudmFyIERFRkFVTFRfVEVYVF9PVkVSRkxPVyA9ICdlbGxpcHNpcydcblxuLy8gYXR0clxuLy8gIC0gdmFsdWU6IHRleHQgY29udGVudC5cbi8vICAtIGxpbmVzOiBtYXhpbXVtIGxpbmVzIG9mIHRoZSB0ZXh0LlxuZnVuY3Rpb24gVGV4dCAoZGF0YSkge1xuICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxufVxuXG5UZXh0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcblxuVGV4dC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInKVxuICBub2RlLnN0eWxlLmZvbnRTaXplID0gREVGQVVMVF9GT05UX1NJWkUgKiB0aGlzLmRhdGEuc2NhbGUgKyAncHgnXG4gIHRoaXMudGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgLy8gR2l2ZSB0aGUgZGV2ZWxvcGVycyB0aGUgYWJpbGl0eSB0byBjb250cm9sIHNwYWNlXG4gIC8vIGFuZCBsaW5lLWJyZWFrZXJzLlxuICB0aGlzLnRleHROb2RlLnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnXG4gIHRoaXMudGV4dE5vZGUuc3R5bGUuZGlzcGxheSA9ICctd2Via2l0LWJveCdcbiAgdGhpcy50ZXh0Tm9kZS5zdHlsZS53ZWJraXRCb3hPcmllbnQgPSAndmVydGljYWwnXG4gIHRoaXMuc3R5bGUubGluZXMuY2FsbCh0aGlzLCB0aGlzLmRhdGEuc3R5bGUubGluZXMpXG4gIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy50ZXh0Tm9kZSlcbiAgcmV0dXJuIG5vZGVcbn1cblxuVGV4dC5wcm90b3R5cGUuYXR0ciA9IHtcbiAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBzcGFuID0gdGhpcy5ub2RlLmZpcnN0Q2hpbGRcbiAgICBzcGFuLmlubmVySFRNTCA9ICcnXG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc3Bhbi50ZXh0Q29udGVudCA9IHZhbHVlXG4gICAgLyoqXG4gICAgICogRGV2ZWxvcGVycyBhcmUgc3VwcG9zZWQgdG8gaGF2ZSB0aGUgYWJpbGl0eSB0byBicmVhayB0ZXh0XG4gICAgICogbGluZXMgbWFudWFsbHkuIFVzaW5nIGBgJm5ic3A7YGAgdG8gcmVwbGFjZSB0ZXh0IHNwYWNlIGlzXG4gICAgICogbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYGAtd2Via2l0LWxpbmUtY2xhbXBgYC4gVGhlcmVmb3JcbiAgICAgKiB3ZSB1c2UgYGB3aGl0ZS1zcGFjZTogbm8td3JhcGBgIGluc3RlYWQgKGluc3RlYWQgb2YgdGhlXG4gICAgICogY29kZSBiZWxsb3cpLlxuXG4gICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgICAgICB0ZXh0LnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHIpXG4gICAgICAgICAgdmFyIHNwYWNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpXG4gICAgICAgICAgc3BhY2UuaW5uZXJIVE1MID0gJyZuYnNwOydcbiAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKHNwYWNlKVxuICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQodGV4dE5vZGUpXG4gICAgICAgIH0pXG4gICAgICAgIGZyYWcucmVtb3ZlQ2hpbGQoZnJhZy5maXJzdENoaWxkKVxuICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpXG4gICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZnJhZylcbiAgICAgIH0pXG4gICAgICBzcGFuLnJlbW92ZUNoaWxkKHNwYW4uZmlyc3RDaGlsZClcbiAgICAgKi9cbiAgfVxufVxuXG5UZXh0LnByb3RvdHlwZS5jbGVhckF0dHIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubm9kZS5maXJzdENoaWxkLnRleHRDb250ZW50ID0gJydcbn1cblxuVGV4dC5wcm90b3R5cGUuc3R5bGUgPSB1dGlscy5leHRlbmQoT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlLnN0eWxlKSwge1xuXG4gIGxpbmVzOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VJbnQodmFsKVxuICAgIGlmICh2YWwgIT09IHZhbCkgeyAvLyBOYU5cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAodmFsIDw9IDApIHtcbiAgICAgIHRoaXMudGV4dE5vZGUuc3R5bGUudGV4dE92ZXJmbG93ID0gJydcbiAgICAgIHRoaXMudGV4dE5vZGUuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSdcbiAgICAgIHRoaXMudGV4dE5vZGUuc3R5bGUud2Via2l0TGluZUNsYW1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5kYXRhID8gdGhpcy5kYXRhLnN0eWxlIDogbnVsbFxuICAgICAgdGhpcy50ZXh0Tm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gICAgICB0aGlzLnRleHROb2RlLnN0eWxlLnRleHRPdmVyZmxvdyA9IHN0eWxlXG4gICAgICAgID8gc3R5bGUudGV4dE92ZXJmbG93XG4gICAgICAgIDogREVGQVVMVF9URVhUX09WRVJGTE9XXG4gICAgICB0aGlzLnRleHROb2RlLnN0eWxlLndlYmtpdExpbmVDbGFtcCA9IHZhbFxuICAgIH1cbiAgfSxcblxuICB0ZXh0T3ZlcmZsb3c6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnRleHROb2RlLnN0eWxlLnRleHRPdmVyZmxvdyA9IHZhbFxuICB9XG5cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gVGV4dFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy90ZXh0LmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwidmFyIExpc3QgPSByZXF1aXJlKCcuL2xpc3QnKVxuXG5mdW5jdGlvbiBWbGlzdChkYXRhLCBub2RlVHlwZSkge1xuICBkYXRhLmF0dHIuZGlyZWN0aW9uID0gJ3YnXG4gIExpc3QuY2FsbCh0aGlzLCBkYXRhLCBub2RlVHlwZSlcbn1cblxuVmxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMaXN0LnByb3RvdHlwZSlcblxubW9kdWxlLmV4cG9ydHMgPSBWbGlzdFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvdmxpc3QuanNcbiAqKiBtb2R1bGUgaWQgPSA0M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxucmVxdWlyZSgnLi4vc3R5bGVzL2xpc3QuY3NzJylcbnJlcXVpcmUoJy4uL3Njcm9sbCcpXG5cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudCcpXG52YXIgTGF6eUxvYWQgPSByZXF1aXJlKCcuLi9sYXp5TG9hZCcpXG5cbnZhciBERUZBVUxUX0xPQURfTU9SRV9PRkZTRVQgPSA1MDBcblxudmFyIGRpcmVjdGlvbk1hcCA9IHtcbiAgaDogWydyb3cnLCAnaG9yaXpvbnRhbCcsICdoJywgJ3gnXSxcbiAgdjogWydjb2x1bW4nLCAndmVydGljYWwnLCAndicsICd5J11cbn1cblxuLy8gZGlyZWN0aW9uOiAndicgb3IgJ2gnLCBkZWZhdWx0IGlzICd2J1xuZnVuY3Rpb24gTGlzdChkYXRhLCBub2RlVHlwZSkge1xuICAvLyB0aGlzLmxvYWRtb3JlT2Zmc2V0ID0gTnVtYmVyKGRhdGEuYXR0ci5sb2FkbW9yZW9mZnNldClcbiAgLy8gdGhpcy5pc0F2YWlsYWJsZVRvRmlyZWxvYWRtb3JlID0gdHJ1ZVxuICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbk1hcC5oLmluZGV4T2YoZGF0YS5hdHRyLmRpcmVjdGlvbikgPT09IC0xXG4gICAgPyAndidcbiAgICA6ICdoJ1xuICBDb21wb25lbnQuY2FsbCh0aGlzLCBkYXRhLCBub2RlVHlwZSlcbn1cblxuTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG5cbkxpc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChub2RlVHlwZSkge1xuICB2YXIgU2Nyb2xsID0gbGliLnNjcm9sbFxuICB2YXIgbm9kZSA9IENvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlLmNhbGwodGhpcywgbm9kZVR5cGUpXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInLCAnbGlzdC13cmFwJylcbiAgdGhpcy5saXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHRoaXMubGlzdEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcbiAgICAnd2VleC1jb250YWluZXInXG4gICAgLCAnbGlzdC1lbGVtZW50J1xuICAgICwgdGhpcy5kaXJlY3Rpb24gKyAnLWxpc3QnXG4gIClcblxuICAvLyBGbGV4IHdpbGwgY2F1c2UgYSBidWcgdG8gcmVzY2FsZSBjaGlsZHJlbidzIHNpemUgaWYgdGhlaXIgdG90YWxcbiAgLy8gc2l6ZSBleGNlZWQgdGhlIGxpbWl0IG9mIHRoZWlyIHBhcmVudC4gU28gdG8gdXNlIGJveCBpbnN0ZWFkLlxuICB0aGlzLmxpc3RFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnLXdlYmtpdC1ib3gnXG4gIHRoaXMubGlzdEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdib3gnXG4gIHRoaXMubGlzdEVsZW1lbnQuc3R5bGUud2Via2l0Qm94T3JpZW50ID0gdGhpcy5kaXJlY3Rpb24gPT09ICdoJ1xuICAgID8gJ2hvcml6b250YWwnXG4gICAgOiAndmVydGljYWwnXG4gIHRoaXMubGlzdEVsZW1lbnQuc3R5bGUuYm94T3JpZW50ID0gdGhpcy5saXN0RWxlbWVudC5zdHlsZS53ZWJraXRCb3hPcmllbnRcblxuICBub2RlLmFwcGVuZENoaWxkKHRoaXMubGlzdEVsZW1lbnQpXG4gIHRoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsKHtcbiAgICBzY3JvbGxFbGVtZW50OiB0aGlzLmxpc3RFbGVtZW50XG4gICAgLCBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uID09PSAnaCcgPyAneCcgOiAneSdcbiAgfSlcbiAgdGhpcy5zY3JvbGxlci5pbml0KClcbiAgdGhpcy5vZmZzZXQgPSAwXG4gIHJldHVybiBub2RlXG59XG5cbkxpc3QucHJvdG90eXBlLmJpbmRFdmVudHMgPSBmdW5jdGlvbiAoZXZ0cykge1xuICBDb21wb25lbnQucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbCh0aGlzLCBldnRzKVxuICAvLyB0byBlbmFibGUgbGF6eWxvYWQgZm9yIEltYWdlcy5cbiAgdGhpcy5zY3JvbGxlci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGxpbmcnLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBzbyA9IGUuc2Nyb2xsT2JqXG4gICAgdmFyIHNjcm9sbFRvcCA9IHNvLmdldFNjcm9sbFRvcCgpXG4gICAgdmFyIHNjcm9sbExlZnQgPSBzby5nZXRTY3JvbGxMZWZ0KClcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2JyA/IHNjcm9sbFRvcCA6IHNjcm9sbExlZnRcbiAgICB2YXIgZGlmZiA9IG9mZnNldCAtIHRoaXMub2Zmc2V0XG4gICAgdmFyIGRpclxuICAgIGlmIChkaWZmID49IDApIHtcbiAgICAgIGRpciA9IHRoaXMuZGlyZWN0aW9uID09PSAndicgPyAndXAnIDogJ2xlZnQnXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpciA9IHRoaXMuZGlyZWN0aW9uID09PSAndicgPyAnZG93bicgOiAncmlnaHQnXG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnc2Nyb2xsJywge1xuICAgICAgb3JpZ2luYWxUeXBlOiAnc2Nyb2xsaW5nJyxcbiAgICAgIHNjcm9sbFRvcDogc28uZ2V0U2Nyb2xsVG9wKCksXG4gICAgICBzY3JvbGxMZWZ0OiBzby5nZXRTY3JvbGxMZWZ0KCksXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIGRpcmVjdGlvbjogZGlyXG4gICAgfSwge1xuICAgICAgYnViYmxlczogdHJ1ZVxuICAgIH0pXG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXRcbiAgfS5iaW5kKHRoaXMpKVxuXG4gIHZhciBwdWxsZW5kRXZlbnQgPSAncHVsbCcgKyAoeyB2OiAndXAnLCBoOiAnbGVmdCcgfSlbdGhpcy5kaXJlY3Rpb25dICsgJ2VuZCdcbiAgdGhpcy5zY3JvbGxlci5hZGRFdmVudExpc3RlbmVyKHB1bGxlbmRFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2xvYWRtb3JlJylcbiAgfS5iaW5kKHRoaXMpKVxufVxuXG5MaXN0LnByb3RvdHlwZS5jcmVhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gIHZhciBwYXJlbnRSZWYgPSB0aGlzLmRhdGEucmVmXG4gIHZhciBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgIHZhciBpc0ZsZXggPSBmYWxzZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkcmVuW2ldLmluc3RhbmNlSWQgPSB0aGlzLmRhdGEuaW5zdGFuY2VJZFxuICAgICAgY2hpbGRyZW5baV0uc2NhbGUgPSB0aGlzLmRhdGEuc2NhbGVcbiAgICAgIHZhciBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChjaGlsZHJlbltpXSlcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG4gICAgICBjaGlsZC5wYXJlbnRSZWYgPSBwYXJlbnRSZWZcbiAgICAgIGlmICghaXNGbGV4XG4gICAgICAgICAgJiYgY2hpbGQuZGF0YS5zdHlsZVxuICAgICAgICAgICYmIGNoaWxkLmRhdGEuc3R5bGUuaGFzT3duUHJvcGVydHkoJ2ZsZXgnKVxuICAgICAgICApIHtcbiAgICAgICAgaXNGbGV4ID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxpc3RFbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KVxuICB9XG4gIC8vIHdhaXQgZm9yIGZyYWdtZW50IHRvIGFwcGVuZGVkIG9uIGxpc3RFbGVtZW50IG9uIFVJIHRocmVhZC5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zY3JvbGxlci5yZWZyZXNoKClcbiAgfS5iaW5kKHRoaXMpLCAwKVxufVxuXG5MaXN0LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gIHZhciBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChkYXRhKVxuICB0aGlzLmxpc3RFbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG5cbiAgLy8gd2FpdCBmb3IgVUkgdGhyZWFkIHRvIHVwZGF0ZS5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zY3JvbGxlci5yZWZyZXNoKClcbiAgfS5iaW5kKHRoaXMpLCAwKVxuXG4gIC8vIHVwZGF0ZSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdGhpcy5kYXRhLmNoaWxkcmVuID0gW2RhdGFdXG4gIH0gZWxzZSB7XG4gICAgY2hpbGRyZW4ucHVzaChkYXRhKVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkXG59XG5cbkxpc3QucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChjaGlsZCwgYmVmb3JlKSB7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICB2YXIgaSA9IDBcbiAgdmFyIGlzQXBwZW5kID0gZmFsc2VcblxuICAvLyB1cGRhdGUgdGhpcy5kYXRhLmNoaWxkcmVuXG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCAhYmVmb3JlKSB7XG4gICAgaXNBcHBlbmQgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnJlZiA9PT0gYmVmb3JlLmRhdGEucmVmKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBsKSB7XG4gICAgICBpc0FwcGVuZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBpZiAoaXNBcHBlbmQpIHtcbiAgICB0aGlzLmxpc3RFbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG4gICAgY2hpbGRyZW4ucHVzaChjaGlsZC5kYXRhKVxuICB9IGVsc2Uge1xuICAgIGlmIChiZWZvcmUuZml4ZWRQbGFjZWhvbGRlcikge1xuICAgICAgdGhpcy5saXN0RWxlbWVudC5pbnNlcnRCZWZvcmUoY2hpbGQubm9kZSwgYmVmb3JlLmZpeGVkUGxhY2Vob2xkZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLm5vZGUsIGJlZm9yZS5ub2RlKVxuICAgIH1cbiAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMCwgY2hpbGQuZGF0YSlcbiAgfVxuXG4gIC8vIHdhaXQgZm9yIFVJIHRocmVhZCB0byB1cGRhdGUuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2Nyb2xsZXIucmVmcmVzaCgpXG4gIH0uYmluZCh0aGlzKSwgMClcbn1cblxuTGlzdC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gIC8vIHJlbW92ZSBmcm9tIHRoaXMuZGF0YS5jaGlsZHJlblxuICB2YXIgaSA9IDBcbiAgdmFyIGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnJlZiA9PT0gY2hpbGQuZGF0YS5yZWYpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPCBsKSB7XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMSlcbiAgICB9XG4gIH1cbiAgLy8gcmVtb3ZlIGZyb20gY29tcG9uZW50TWFwIHJlY3Vyc2l2ZWx5XG4gIGNvbXBvbmVudE1hbmFnZXIucmVtb3ZlRWxlbWVudEJ5UmVmKGNoaWxkLmRhdGEucmVmKVxuICBpZiAoY2hpbGQuZml4ZWRQbGFjZWhvbGRlcikge1xuICAgIHRoaXMubGlzdEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGQuZml4ZWRQbGFjZWhvbGRlcilcbiAgfVxuICBjaGlsZC5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQubm9kZSlcblxuICAvLyB3YWl0IGZvciBVSSB0aHJlYWQgdG8gdXBkYXRlLlxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjcm9sbGVyLnJlZnJlc2goKVxuICB9LmJpbmQodGhpcyksIDApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9saXN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2xpc3QuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9saXN0LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbGlzdC5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9saXN0LmNzc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubGlzdC13cmFwIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLmxpc3QtZWxlbWVudCB7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2xpc3QuY3NzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwicmVxdWlyZSgnLi9tb3Rpb24nKVxuXG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKVxuXG52YXIgZG9jID0gd2luZG93LmRvY3VtZW50XG52YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxudmFyIHNjcm9sbE9ianMgPSB7fVxudmFyIHBsdWdpbnMgPSB7fVxudmFyIGRwciA9IHdpbmRvdy5kcHJcbiAgfHwgKCEhd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQaG9uZXxpUGFkfGlQb2QvKVxuICAgID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIC8gd2luZG93LnNjcmVlbi5hdmFpbFdpZHRoXG4gICAgOiAxKVxudmFyIGluZXJ0aWFDb2VmZmljaWVudCA9IHtcbiAgbm9ybWFsOiBbMiAqIGRwciwgMC4wMDE1ICogZHByXSxcbiAgc2xvdzogWzEuNSAqIGRwciwgMC4wMDMgKiBkcHJdLFxuICB2ZXJ5c2xvdzogWzEuNSAqIGRwciwgMC4wMDUgKiBkcHJdXG59XG52YXIgdGltZUZ1bmN0aW9uID0ge1xuICBlYXNlOiBbLjI1LC4xLC4yNSwxXSxcbiAgbGluZXI6IFswLDAsMSwxXSxcbiAgJ2Vhc2UtaW4nOiBbLjQyLDAsMSwxXSxcbiAgJ2Vhc2Utb3V0JzogWzAsMCwuNTgsMV0sXG4gICdlYXNlLWluLW91dCc6IFsuNDIsMCwuNTgsMV1cbn1cbnZhciBGaXJlZm94ID0gISF1YS5tYXRjaCgvRmlyZWZveC9pKVxudmFyIElFTW9iaWxlID0gISF1YS5tYXRjaCgvSUVNb2JpbGUvaSlcbnZhciBjc3NQcmVmaXggPSBGaXJlZm94ID8gJy1tb3otJyA6IElFTW9iaWxlID8gJy1tcy0nIDogJy13ZWJraXQtJ1xudmFyIHN0eWxlUHJlZml4ID0gRmlyZWZveCA/ICdNb3onIDogSUVNb2JpbGUgPyAnbXMnIDogJ3dlYmtpdCdcblxuZnVuY3Rpb24gZGVidWdMb2coKSB7XG4gIGlmIChsaWIuc2Nyb2xsLm91dHB1dERlYnVnTG9nKSB7XG4gICAgbG9nZ2VyLmxvZy5hcHBseShsb2dnZXIsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBpZiAoIXJlY3QpIHtcbiAgICByZWN0ID0ge31cbiAgICByZWN0LndpZHRoID0gZWwub2Zmc2V0V2lkdGhcbiAgICByZWN0LmhlaWdodCA9IGVsLm9mZnNldEhlaWdodFxuXG4gICAgcmVjdC5sZWZ0ID0gZWwub2Zmc2V0TGVmdFxuICAgIHJlY3QudG9wID0gZWwub2Zmc2V0VG9wXG4gICAgdmFyIHBhcmVudCA9IGVsLm9mZnNldFBhcmVudFxuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHJlY3QubGVmdCArPSBwYXJlbnQub2Zmc2V0TGVmdFxuICAgICAgcmVjdC50b3AgKz0gcGFyZW50Lm9mZnNldFRvcFxuICAgICAgcGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudFxuICAgIH1cblxuICAgIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyByZWN0LndpZHRoXG4gICAgcmVjdC5ib3R0b20gPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0XG4gIH1cbiAgcmV0dXJuIHJlY3Rcbn1cblxuZnVuY3Rpb24gZ2V0TWluU2Nyb2xsT2Zmc2V0KHNjcm9sbE9iaikge1xuICByZXR1cm4gMCAtIHNjcm9sbE9iai5vcHRpb25zW3Njcm9sbE9iai5heGlzICsgJ1BhZGRpbmdUb3AnXVxufVxuXG5mdW5jdGlvbiBnZXRNYXhTY3JvbGxPZmZzZXQoc2Nyb2xsT2JqKSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHNjcm9sbE9iai5lbGVtZW50KVxuICB2YXIgcFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc2Nyb2xsT2JqLnZpZXdwb3J0KVxuICB2YXIgbWluID0gZ2V0TWluU2Nyb2xsT2Zmc2V0KHNjcm9sbE9iailcbiAgaWYgKHNjcm9sbE9iai5heGlzID09PSAneScpIHtcbiAgICB2YXIgbWF4ID0gMCAtIHJlY3QuaGVpZ2h0ICsgcFJlY3QuaGVpZ2h0XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1heCA9IDAgLSByZWN0LndpZHRoICsgcFJlY3Qud2lkdGhcbiAgfVxuICByZXR1cm4gTWF0aC5taW4oXG4gICAgbWF4ICsgc2Nyb2xsT2JqLm9wdGlvbnNbc2Nyb2xsT2JqLmF4aXMgKyAnUGFkZGluZ0JvdHRvbSddLFxuICAgIG1pblxuICApXG59XG5cbmZ1bmN0aW9uIGdldEJvdW5kYXJ5T2Zmc2V0KHNjcm9sbE9iaiwgb2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPiBzY3JvbGxPYmoubWluU2Nyb2xsT2Zmc2V0KSB7XG4gICAgcmV0dXJuIG9mZnNldCAtIHNjcm9sbE9iai5taW5TY3JvbGxPZmZzZXRcbiAgfVxuICBpZiAob2Zmc2V0IDwgc2Nyb2xsT2JqLm1heFNjcm9sbE9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgLSBzY3JvbGxPYmoubWF4U2Nyb2xsT2Zmc2V0XG4gIH1cbn1cblxuZnVuY3Rpb24gdG91Y2hCb3VuZGFyeShzY3JvbGxPYmosIG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID4gc2Nyb2xsT2JqLm1pblNjcm9sbE9mZnNldCkge1xuICAgIG9mZnNldCA9IHNjcm9sbE9iai5taW5TY3JvbGxPZmZzZXRcbiAgfSBlbHNlIGlmIChvZmZzZXQgPCBzY3JvbGxPYmoubWF4U2Nyb2xsT2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gc2Nyb2xsT2JqLm1heFNjcm9sbE9mZnNldFxuICB9XG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gZmlyZUV2ZW50KHNjcm9sbE9iaiwgZXZlbnROYW1lLCBleHRyYSkge1xuICBkZWJ1Z0xvZyhzY3JvbGxPYmouZWxlbWVudC5zY3JvbGxJZCwgZXZlbnROYW1lLCBleHRyYSlcbiAgdmFyIGV2ZW50ID0gZG9jLmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJylcbiAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgZmFsc2UsIHRydWUpXG4gIGV2ZW50LnNjcm9sbE9iaiA9IHNjcm9sbE9ialxuICBpZiAoZXh0cmEpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0cmEpIHtcbiAgICAgIGV2ZW50W2tleV0gPSBleHRyYVtrZXldXG4gICAgfVxuICB9XG4gIHNjcm9sbE9iai5lbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIHNjcm9sbE9iai52aWV3cG9ydC5kaXNwYXRjaEV2ZW50KGV2ZW50KVxufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1PZmZzZXQoc2Nyb2xsT2JqKSB7XG4gIHZhciBvZmZzZXQgPSB7eDogMCwgeTogMH1cbiAgdmFyIHRyYW5zZm9ybSA9IGdldENvbXB1dGVkU3R5bGUoc2Nyb2xsT2JqLmVsZW1lbnQpXG4gICAgW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddXG4gIHZhciBtYXRjaGVkXG4gIHZhciByZWcxID0gbmV3IFJlZ0V4cCgnXm1hdHJpeDNkJ1xuICAgICsgJ1xcXFwoKD86Wy1cXFxcZC5dKyxcXFxccyopezEyfShbLVxcXFxkLl0rKSwnXG4gICAgKyAnXFxcXHMqKFstXFxcXGQuXSspKD86LFxcXFxzKlstXFxcXGQuXSspezJ9XFxcXCknKVxuICB2YXIgcmVnMiA9IG5ldyBSZWdFeHAoJ15tYXRyaXgnXG4gICAgKyAnXFxcXCgoPzpbLVxcXFxkLl0rLFxcXFxzKil7NH0oWy1cXFxcZC5dKyksXFxcXHMqKFstXFxcXGQuXSspXFxcXCkkJylcbiAgaWYgKHRyYW5zZm9ybSAhPT0gJ25vbmUnKSB7XG4gICAgaWYgKChtYXRjaGVkID0gdHJhbnNmb3JtLm1hdGNoKHJlZzEpIHx8XG4gICAgICAgIHRyYW5zZm9ybS5tYXRjaChyZWcyKSkpIHtcbiAgICAgIG9mZnNldC54ID0gcGFyc2VGbG9hdChtYXRjaGVkWzFdKSB8fCAwXG4gICAgICBvZmZzZXQueSA9IHBhcnNlRmxvYXQobWF0Y2hlZFsyXSkgfHwgMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRcbn1cblxudmFyIENTU01hdHJpeCA9IElFTW9iaWxlID8gJ01TQ1NTTWF0cml4JyA6ICdXZWJLaXRDU1NNYXRyaXgnXG52YXIgaGFzM2QgPSAhIUZpcmVmb3hcbiAgfHwgQ1NTTWF0cml4IGluIHdpbmRvd1xuICAmJiAnbTExJyBpbiBuZXcgd2luZG93W0NTU01hdHJpeF0oKVxuZnVuY3Rpb24gZ2V0VHJhbnNsYXRlKHgsIHkpIHtcbiAgeCA9IHBhcnNlRmxvYXQoeClcbiAgeSA9IHBhcnNlRmxvYXQoeSlcblxuICBpZiAoeCAhPSAwKSB7XG4gICAgeCArPSAncHgnXG4gIH1cblxuICBpZiAoeSAhPSAwKSB7XG4gICAgeSArPSAncHgnXG4gIH1cblxuICBpZiAoaGFzM2QpIHtcbiAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJywgJyArIHkgKyAnLCAwKSdcbiAgfVxuICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeCArICcsICcgKyB5ICsgJyknXG59XG5cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25TdHlsZShzY3JvbGxPYmosIGR1cmF0aW9uLCB0aW1pbmdGdW5jdGlvbikge1xuICBpZiAoZHVyYXRpb24gPT09ICcnICYmIHRpbWluZ0Z1bmN0aW9uID09PSAnJykge1xuICAgIHNjcm9sbE9iai5lbGVtZW50LnN0eWxlW3N0eWxlUHJlZml4ICsgJ1RyYW5zaXRpb24nXSA9ICcnXG4gIH0gZWxzZSB7XG4gICAgc2Nyb2xsT2JqLmVsZW1lbnQuc3R5bGVbc3R5bGVQcmVmaXggKyAnVHJhbnNpdGlvbiddXG4gICAgICA9IGNzc1ByZWZpeCArICd0cmFuc2Zvcm0gJyArIGR1cmF0aW9uICsgJyAnICsgdGltaW5nRnVuY3Rpb24gKyAnIDBzJ1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldFRyYW5zZm9ybVN0eWxlKHNjcm9sbE9iaiwgb2Zmc2V0KSB7XG4gIHZhciB4ID0gMFxuICB2YXIgeSA9IDBcbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgeCA9IG9mZnNldC54XG4gICAgeSA9IG9mZnNldC55XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNjcm9sbE9iai5heGlzID09PSAneScpIHtcbiAgICAgIHkgPSBvZmZzZXRcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IG9mZnNldFxuICAgIH1cbiAgfVxuICBzY3JvbGxPYmouZWxlbWVudC5zdHlsZVtzdHlsZVByZWZpeCArICdUcmFuc2Zvcm0nXSA9IGdldFRyYW5zbGF0ZSh4LCB5KVxufVxuXG52YXIgcGFubmluZyA9IGZhbHNlXG5kb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKGUpIHtcbiAgaWYgKHBhbm5pbmcpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufSwgZmFsc2UpXG5cbmZ1bmN0aW9uIFNjcm9sbChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIG9wdGlvbnMubm9Cb3VuY2UgPSAhIW9wdGlvbnMubm9Cb3VuY2VcbiAgb3B0aW9ucy5wYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nIHx8IHt9XG5cbiAgaWYgKG9wdGlvbnMuaXNQcmV2ZW50ID09IG51bGwpIHtcbiAgICBvcHRpb25zLmlzUHJldmVudCA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmlzUHJldmVudCA9ICEhb3B0aW9ucy5pc1ByZXZlbnRcbiAgfVxuXG4gIGlmIChvcHRpb25zLmlzRml4U2Nyb2xsZW5kQ2xpY2sgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMuaXNGaXhTY3JvbGxlbmRDbGljayA9IHRydWVcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zLmlzRml4U2Nyb2xsZW5kQ2xpY2sgPSAhIW9wdGlvbnMuaXNGaXhTY3JvbGxlbmRDbGlja1xuICB9XG5cbiAgaWYgKG9wdGlvbnMucGFkZGluZykge1xuICAgIG9wdGlvbnMueVBhZGRpbmdUb3AgPSAtb3B0aW9ucy5wYWRkaW5nLnRvcCB8fCAwXG4gICAgb3B0aW9ucy55UGFkZGluZ0JvdHRvbSA9IC1vcHRpb25zLnBhZGRpbmcuYm90dG9tIHx8IDBcbiAgICBvcHRpb25zLnhQYWRkaW5nVG9wID0gLW9wdGlvbnMucGFkZGluZy5sZWZ0IHx8IDBcbiAgICBvcHRpb25zLnhQYWRkaW5nQm90dG9tID0gLW9wdGlvbnMucGFkZGluZy5yaWdodCB8fCAwXG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucy55UGFkZGluZ1RvcCA9IDBcbiAgICBvcHRpb25zLnlQYWRkaW5nQm90dG9tID0gMFxuICAgIG9wdGlvbnMueFBhZGRpbmdUb3AgPSAwXG4gICAgb3B0aW9ucy54UGFkZGluZ0JvdHRvbSA9IDBcbiAgfVxuXG4gIG9wdGlvbnMuZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb24gfHwgJ3knXG4gIG9wdGlvbnMuaW5lcnRpYSA9IG9wdGlvbnMuaW5lcnRpYSB8fCAnbm9ybWFsJ1xuXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgdGhhdC5heGlzID0gb3B0aW9ucy5kaXJlY3Rpb25cbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudFxuICB0aGlzLnZpZXdwb3J0ID0gZWxlbWVudC5wYXJlbnROb2RlXG4gIHRoaXMucGx1Z2lucyA9IHt9XG5cbiAgdGhpcy5lbGVtZW50LnNjcm9sbElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2Nyb2xsT2Jqc1t0aGF0LmVsZW1lbnQuc2Nyb2xsSWQgKyAnJ10gPSB0aGF0XG4gIH0sIDEpXG5cbiAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIsIGZhbHNlKVxuICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyLCBmYWxzZSlcbiAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRvdWNoZW5kSGFuZGxlciwgZmFsc2UpXG4gIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigncGFuc3RhcnQnLCBwYW5zdGFydEhhbmRsZXIsIGZhbHNlKVxuICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhbm1vdmUnLCBwYW5IYW5kbGVyLCBmYWxzZSlcbiAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdwYW5lbmQnLCBwYW5lbmRIYW5kbGVyLCBmYWxzZSlcblxuICBpZiAob3B0aW9ucy5pc1ByZXZlbnQpIHtcbiAgICB0aGlzLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcGFubmluZyA9IHRydWVcbiAgICB9LCBmYWxzZSlcbiAgICB0aGF0LnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHBhbm5pbmcgPSBmYWxzZVxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgLy8gaWYgKG9wdGlvbnMuaXNQcmV2ZW50KSB7XG4gIC8vICAgdmFyIGQgPSB0aGlzLmF4aXMgPT09ICd5Jz8ndmVydGljYWwnOidob3Jpem9udGFsJ1xuICAvLyAgIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcihkICsgJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgLy8gICAgIHBhbm5pbmcgPSB0cnVlXG4gIC8vICAgfSwgZmFsc2UpXG4gIC8vICAgdGhhdC52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdwYW5lbmQnLCBmdW5jdGlvbiAoZSkge1xuICAvLyAgICAgcGFubmluZyA9IGZhbHNlXG4gIC8vICAgfSwgZmFsc2UpXG4gIC8vIH1cblxuICBpZiAob3B0aW9ucy5pc0ZpeFNjcm9sbGVuZENsaWNrKSB7XG4gICAgdmFyIHByZXZlbnRTY3JvbGxlbmRDbGlja1xuICAgIHZhciBmaXhTY3JvbGxlbmRDbGlja1RpbWVvdXRJZFxuXG4gICAgdGhpcy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGxpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBwcmV2ZW50U2Nyb2xsZW5kQ2xpY2sgPSB0cnVlXG4gICAgICBmaXhTY3JvbGxlbmRDbGlja1RpbWVvdXRJZCAmJiBjbGVhclRpbWVvdXQoZml4U2Nyb2xsZW5kQ2xpY2tUaW1lb3V0SWQpXG4gICAgICBmaXhTY3JvbGxlbmRDbGlja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbGVuZENsaWNrID0gZmFsc2VcbiAgICAgIH0sIDQwMClcbiAgICB9LCBmYWxzZSlcblxuICAgIGZ1bmN0aW9uIHByZXZlbnRTY3JvbGxlbmRDbGlja0hhbmRsZXIoZSkge1xuICAgICAgaWYgKHByZXZlbnRTY3JvbGxlbmRDbGljayB8fCBpc1Njcm9sbGluZykge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyZU5pY2VUYXBFdmVudEhhbmRsZXIoZSkge1xuICAgICAgaWYgKCFwcmV2ZW50U2Nyb2xsZW5kQ2xpY2sgJiYgIWlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBuaWNlVGFwRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpXG4gICAgICAgICAgbmljZVRhcEV2ZW50LmluaXRFdmVudCgnbmljZWNsaWNrJywgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KG5pY2VUYXBFdmVudClcbiAgICAgICAgfSwgMzAwKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBwcmV2ZW50U2Nyb2xsZW5kQ2xpY2tIYW5kbGVyKVxuICAgIHRoaXMudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgZmlyZU5pY2VUYXBFdmVudEhhbmRsZXIpXG4gIH1cblxuICBpZiAob3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgIHZhciBzY3JvbGxBbmltYXRpb25cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYW5pbWF0aW9uJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzY3JvbGxBbmltYXRpb25cbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHZhciB0cmFuc2l0aW9uRW5kSGFuZGxlclxuICAgIHZhciB0cmFuc2l0aW9uRW5kVGltZW91dElkID0gMFxuXG4gICAgZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkVuZEhhbmRsZXIoaCwgdCkge1xuICAgICAgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBudWxsXG4gICAgICBjbGVhclRpbWVvdXQodHJhbnNpdGlvbkVuZFRpbWVvdXRJZClcblxuICAgICAgdHJhbnNpdGlvbkVuZFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbkVuZEhhbmRsZXIpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IG51bGxcbiAgICAgICAgICBsaWIuYW5pbWF0aW9uLnJlcXVlc3RGcmFtZShoKVxuICAgICAgICB9XG4gICAgICB9LCAodCB8fCA0MDApKVxuXG4gICAgICB0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGhcbiAgICB9XG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIEZpcmVmb3hcbiAgICAgICAgICA/ICd0cmFuc2l0aW9uZW5kJ1xuICAgICAgICAgIDogKHN0eWxlUHJlZml4ICsgJ1RyYW5zaXRpb25FbmQnKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0cmFuc2l0aW9uRW5kSGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRyYW5zaXRpb25FbmRIYW5kbGVyXG5cbiAgICAgICAgdHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBudWxsXG4gICAgICAgIGNsZWFyVGltZW91dCh0cmFuc2l0aW9uRW5kVGltZW91dElkKVxuXG4gICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBoYW5kbGVyKGUpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSwgZmFsc2UpXG4gIH1cblxuICB2YXIgcGFuRml4UmF0aW9cbiAgdmFyIGlzU2Nyb2xsaW5nXG4gIHZhciBpc0ZsaWNrU2Nyb2xsaW5nXG4gIHZhciBjYW5jZWxTY3JvbGxFbmRcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2lzU2Nyb2xsaW5nJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICEhaXNTY3JvbGxpbmdcbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gaXNFbmFibGVkKGUpIHtcbiAgICBpZiAoIXRoYXQuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBlLmlzVmVydGljYWwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0aGF0LmF4aXMgPT09ICd5JyAmJiBlLmlzVmVydGljYWxcbiAgICAgICAgICB8fCB0aGF0LmF4aXMgPT09ICd4JyAmJiAhZS5pc1ZlcnRpY2FsKSB7XG4gICAgICAgIC8vIGdlc3R1cmUgaW4gc2FtZSBkaXJlY3Rpb24sIHN0b3AgYnViYmxpbmcgdXBcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2VzdHVyZSBpbiBkaWZmZXJlbnQgZGlyZWN0aW9uLCBidWJibGluZyB1cFxuICAgICAgICAvLyB0byB0aGUgdG9wLCB3aXRob3V0IGFueSBvdGhlciBwcm9jZXNzXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0SGFuZGxlcihlKSB7XG4gICAgaWYgKCFpc0VuYWJsZWQoZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc1Njcm9sbGluZykge1xuICAgICAgc2Nyb2xsRW5kKClcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgc2Nyb2xsQW5pbWF0aW9uICYmIHNjcm9sbEFuaW1hdGlvbi5zdG9wKClcbiAgICAgIHNjcm9sbEFuaW1hdGlvbiA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybU9mZnNldCh0aGF0KVxuICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgdHJhbnNmb3JtKVxuICAgICAgc2V0VHJhbnNpdGlvblN0eWxlKHRoYXQsICcnLCAnJylcbiAgICAgIHRyYW5zaXRpb25FbmRIYW5kbGVyID0gbnVsbFxuICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zaXRpb25FbmRUaW1lb3V0SWQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRIYW5kbGVyKGUpIHtcbiAgICBpZiAoIWlzRW5hYmxlZChlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHMwID0gZ2V0VHJhbnNmb3JtT2Zmc2V0KHRoYXQpW3RoYXQuYXhpc11cbiAgICB2YXIgYm91bmRhcnlPZmZzZXQgPSBnZXRCb3VuZGFyeU9mZnNldCh0aGF0LCBzMClcblxuICAgIGlmIChib3VuZGFyeU9mZnNldCkge1xuICAgICAgLy8gZHJhZ2dpbmcgb3V0IG9mIGJvdW5kcmF5LCBib3VuY2UgaXMgbmVlZGVkXG4gICAgICB2YXIgczEgPSB0b3VjaEJvdW5kYXJ5KHRoYXQsIHMwKVxuXG4gICAgICBpZiAob3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICAvLyBmcmFtZVxuICAgICAgICB2YXIgX3MgPSBzMSAtIHMwXG4gICAgICAgIHNjcm9sbEFuaW1hdGlvbiA9IG5ldyBsaWIuYW5pbWF0aW9uKFxuICAgICAgICAgICAgNDAwLFxuICAgICAgICAgICAgbGliLmN1YmljYmV6aWVyLmVhc2UsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAoczAgKyBfcyAqIGkyKS50b0ZpeGVkKDIpXG4gICAgICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgb2Zmc2V0KVxuICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJylcbiAgICAgICAgfSlcbiAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLm9uZW5kKHNjcm9sbEVuZClcbiAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLnBsYXkoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3NzXG4gICAgICAgIHZhciBvZmZzZXQgPSAgczEudG9GaXhlZCgwKVxuICAgICAgICBzZXRUcmFuc2l0aW9uU3R5bGUodGhhdCwgJzAuNHMnLCAnZWFzZScpXG4gICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgc2V0VHJhbnNpdGlvbkVuZEhhbmRsZXIoc2Nyb2xsRW5kLCA0MDApXG5cbiAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpc1Njcm9sbGluZyAmJiB0aGF0LmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJylcbiAgICAgICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKGFyZ3VtZW50cy5jYWxsZWUpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBpZiAoYm91bmRhcnlPZmZzZXQgPiAwKSB7XG4gICAgICAgIGZpcmVFdmVudCh0aGF0LCB0aGF0LmF4aXMgPT09ICd5JyA/ICdwdWxsZG93bmVuZCcgOiAncHVsbHJpZ2h0ZW5kJylcbiAgICAgIH0gZWxzZSBpZiAoYm91bmRhcnlPZmZzZXQgPCAwKSB7XG4gICAgICAgIGZpcmVFdmVudCh0aGF0LCB0aGF0LmF4aXMgPT09ICd5JyA/ICdwdWxsdXBlbmQnIDogJ3B1bGxsZWZ0ZW5kJylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2Nyb2xsaW5nKSB7XG4gICAgICAvLyB3aXRob3V0IGV4Y2VlZGluZyB0aGUgYm91bmRhcnksIGp1c3QgZW5kIGl0XG4gICAgICBzY3JvbGxFbmQoKVxuICAgIH1cbiAgfVxuXG4gIHZhciBsYXN0RGlzcGxhY2VtZW50XG4gIGZ1bmN0aW9uIHBhbnN0YXJ0SGFuZGxlcihlKSB7XG4gICAgaWYgKCFpc0VuYWJsZWQoZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoYXQudHJhbnNmb3JtT2Zmc2V0ID0gZ2V0VHJhbnNmb3JtT2Zmc2V0KHRoYXQpXG4gICAgdGhhdC5taW5TY3JvbGxPZmZzZXQgPSBnZXRNaW5TY3JvbGxPZmZzZXQodGhhdClcbiAgICB0aGF0Lm1heFNjcm9sbE9mZnNldCA9IGdldE1heFNjcm9sbE9mZnNldCh0aGF0KVxuICAgIHBhbkZpeFJhdGlvID0gMi41XG4gICAgY2FuY2VsU2Nyb2xsRW5kID0gdHJ1ZVxuICAgIGlzU2Nyb2xsaW5nID0gdHJ1ZVxuICAgIGlzRmxpY2tTY3JvbGxpbmcgPSBmYWxzZVxuICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsc3RhcnQnKVxuXG4gICAgbGFzdERpc3BsYWNlbWVudCA9IGVbJ2Rpc3BsYWNlbWVudCcgKyB0aGF0LmF4aXMudG9VcHBlckNhc2UoKV1cbiAgfVxuXG5cbiAgZnVuY3Rpb24gcGFuSGFuZGxlcihlKSB7XG4gICAgaWYgKCFpc0VuYWJsZWQoZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbmdlciBtb3ZlIGxlc3MgdGhhbiA1IHB4LiBqdXN0IGlnbm9yZSB0aGF0LlxuICAgIHZhciBkaXNwbGFjZW1lbnQgPSBlWydkaXNwbGFjZW1lbnQnICsgdGhhdC5heGlzLnRvVXBwZXJDYXNlKCldXG4gICAgaWYgKE1hdGguYWJzKGRpc3BsYWNlbWVudCAtIGxhc3REaXNwbGFjZW1lbnQpIDwgNSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxhc3REaXNwbGFjZW1lbnQgPSBkaXNwbGFjZW1lbnRcblxuICAgIHZhciBvZmZzZXQgPSB0aGF0LnRyYW5zZm9ybU9mZnNldFt0aGF0LmF4aXNdICsgZGlzcGxhY2VtZW50XG4gICAgaWYgKG9mZnNldCA+IHRoYXQubWluU2Nyb2xsT2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSB0aGF0Lm1pblNjcm9sbE9mZnNldFxuICAgICAgICArIChvZmZzZXQgLSB0aGF0Lm1pblNjcm9sbE9mZnNldCkgLyBwYW5GaXhSYXRpb1xuICAgICAgcGFuRml4UmF0aW8gKj0gMS4wMDNcbiAgICB9IGVsc2UgaWYgKG9mZnNldCA8IHRoYXQubWF4U2Nyb2xsT2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSB0aGF0Lm1heFNjcm9sbE9mZnNldFxuICAgICAgICAtICh0aGF0Lm1heFNjcm9sbE9mZnNldCAtIG9mZnNldCkgLyBwYW5GaXhSYXRpb1xuICAgICAgcGFuRml4UmF0aW8gKj0gMS4wMDNcbiAgICB9XG4gICAgaWYgKHBhbkZpeFJhdGlvID4gNCkge1xuICAgICAgcGFuRml4UmF0aW8gPSA0XG4gICAgfVxuXG4gICAgLy8gdGVsbCB3aGV0aGVyIG9yIG5vdCByZWFjaCB0aGUgZnJpbmdlXG4gICAgdmFyIGJvdW5kYXJ5T2Zmc2V0ID0gZ2V0Qm91bmRhcnlPZmZzZXQodGhhdCwgb2Zmc2V0KVxuICAgIGlmIChib3VuZGFyeU9mZnNldCkge1xuICAgICAgZmlyZUV2ZW50KFxuICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgYm91bmRhcnlPZmZzZXQgPiAwXG4gICAgICAgICAgPyAodGhhdC5heGlzID09PSAneScgPyAncHVsbGRvd24nIDogJ3B1bGxyaWdodCcpXG4gICAgICAgICAgOiAodGhhdC5heGlzID09PSAneScgPyAncHVsbHVwJyA6ICdwdWxsbGVmdCcpLCB7XG4gICAgICAgIGJvdW5kYXJ5T2Zmc2V0OiBNYXRoLmFicyhib3VuZGFyeU9mZnNldClcbiAgICAgIH0pXG4gICAgICBpZiAodGhhdC5vcHRpb25zLm5vQm91bmNlKSB7XG4gICAgICAgIG9mZnNldCA9IHRvdWNoQm91bmRhcnkodGhhdCwgb2Zmc2V0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldC50b0ZpeGVkKDIpKVxuICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhbmVuZEhhbmRsZXIoZSkge1xuICAgIGlmICghaXNFbmFibGVkKGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoZS5pc2ZsaWNrKSB7XG4gICAgICBmbGlja0hhbmRsZXIoZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbGlja0hhbmRsZXIoZSkge1xuICAgIGNhbmNlbFNjcm9sbEVuZCA9IHRydWVcblxuICAgIHZhciB2MCwgYTAsIHQwLCBzMCwgcywgbW90aW9uMFxuICAgIHZhciB2MSwgYTEsIHQxLCBzMSwgbW90aW9uMSxzaWduXG4gICAgdmFyIHYyLCBhMiwgdDIsIHMyLCBtb3Rpb24yLCBmdFxuXG4gICAgczAgPSBnZXRUcmFuc2Zvcm1PZmZzZXQodGhhdClbdGhhdC5heGlzXVxuICAgIHZhciBib3VuZGFyeU9mZnNldDAgPSBnZXRCb3VuZGFyeU9mZnNldCh0aGF0LCBzMClcbiAgICBpZiAoIWJvdW5kYXJ5T2Zmc2V0MCkge1xuICAgICAgLy8gd2hlbiBmaW5nZXJzIGxlZnQgdGhlIHJhbmdlIG9mIHNjcmVlbiwgbGV0IHRvdWNoIGVuZCBoYW5kbGVyXG4gICAgICAvLyB0byBkZWFsIHdpdGggaXQuXG4gICAgICAvLyB3aGVuIGZpbmdlcnMgbGVmdCB0aGUgc2NyZWVuLCBidXQgc3RpbGwgaW4gdGhlIHJhbmdlIG9mXG4gICAgICAvLyBzY3JlZW4sIGNhbGN1bGF0ZSB0aGUgaW50ZXJ0aWEuXG4gICAgICB2MCA9IGVbJ3ZlbG9jaXR5JyArIHRoYXQuYXhpcy50b1VwcGVyQ2FzZSgpXVxuXG4gICAgICB2YXIgbWF4ViA9IDJcbiAgICAgIHZhciBmcmljdGlvbiA9IDAuMDAxNVxuICAgICAgaWYgKG9wdGlvbnMuaW5lcnRpYSAmJiBpbmVydGlhQ29lZmZpY2llbnRbb3B0aW9ucy5pbmVydGlhXSkge1xuICAgICAgICBtYXhWID0gaW5lcnRpYUNvZWZmaWNpZW50W29wdGlvbnMuaW5lcnRpYV1bMF1cbiAgICAgICAgZnJpY3Rpb24gPSBpbmVydGlhQ29lZmZpY2llbnRbb3B0aW9ucy5pbmVydGlhXVsxXVxuICAgICAgfVxuXG4gICAgICBpZiAodjAgPiBtYXhWKSB7XG4gICAgICAgIHYwID0gbWF4VlxuICAgICAgfVxuICAgICAgaWYgKHYwIDwgLW1heFYpIHtcbiAgICAgICAgdjAgPSAtbWF4VlxuICAgICAgfVxuICAgICAgYTAgPSBmcmljdGlvbiAqICh2MCAvIE1hdGguYWJzKHYwKSlcbiAgICAgIG1vdGlvbjAgPSBuZXcgbGliLm1vdGlvbih7XG4gICAgICAgIHY6IHYwLFxuICAgICAgICBhOiAtYTBcbiAgICAgIH0pXG4gICAgICB0MCA9IG1vdGlvbjAudFxuICAgICAgcyA9IHMwICsgbW90aW9uMC5zXG5cbiAgICAgIHZhciBib3VuZGFyeU9mZnNldDEgPSBnZXRCb3VuZGFyeU9mZnNldCh0aGF0LCBzKVxuICAgICAgaWYgKGJvdW5kYXJ5T2Zmc2V0MSkge1xuICAgICAgICBkZWJ1Z0xvZygnaW5lcnRpYWwgY2FsY3VsYXRpb24gaGFzIGV4Y2VlZGVkIHRoZSBib3VuZGFyeScsXG4gICAgICAgICAgYm91bmRhcnlPZmZzZXQxKVxuXG4gICAgICAgIHYxID0gdjBcbiAgICAgICAgYTEgPSBhMFxuICAgICAgICBpZiAoYm91bmRhcnlPZmZzZXQxID4gMCkge1xuICAgICAgICAgIHMxID0gdGhhdC5taW5TY3JvbGxPZmZzZXRcbiAgICAgICAgICBzaWduID0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gdGhhdC5tYXhTY3JvbGxPZmZzZXRcbiAgICAgICAgICBzaWduID0gLTFcbiAgICAgICAgfVxuICAgICAgICBtb3Rpb24xID0gbmV3IGxpYi5tb3Rpb24oe1xuICAgICAgICAgIHY6IHNpZ24gKiB2MSxcbiAgICAgICAgICBhOiAtc2lnbiAqIGExLFxuICAgICAgICAgIHM6IE1hdGguYWJzKHMxIC0gczApXG4gICAgICAgIH0pXG4gICAgICAgIHQxID0gbW90aW9uMS50XG4gICAgICAgIHZhciB0aW1lRnVuY3Rpb24xID0gbW90aW9uMS5nZW5lcmF0ZUN1YmljQmV6aWVyKClcblxuICAgICAgICB2MiA9IHYxIC0gYTEgKiB0MVxuICAgICAgICBhMiA9IDAuMDMgKiAodjIgLyBNYXRoLmFicyh2MikpXG4gICAgICAgIG1vdGlvbjIgPSBuZXcgbGliLm1vdGlvbih7XG4gICAgICAgICAgdjogdjIsXG4gICAgICAgICAgYTogLWEyXG4gICAgICAgIH0pXG4gICAgICAgIHQyID0gbW90aW9uMi50XG4gICAgICAgIHMyID0gczEgKyBtb3Rpb24yLnNcbiAgICAgICAgdmFyIHRpbWVGdW5jdGlvbjIgPSBtb3Rpb24yLmdlbmVyYXRlQ3ViaWNCZXppZXIoKVxuXG4gICAgICAgIGlmIChvcHRpb25zLm5vQm91bmNlKSB7XG4gICAgICAgICAgZGVidWdMb2coJ25vIGJvdW5jZSBlZmZlY3QnKVxuXG4gICAgICAgICAgaWYgKHMwICE9PSBzMSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgLy8gZnJhbWVcbiAgICAgICAgICAgICAgdmFyIF9zID0gczEgLSBzMFxuICAgICAgICAgICAgICB2YXIgYmV6aWVyID0gbGliLmN1YmljYmV6aWVyKFxuICAgICAgICAgICAgICAgIHRpbWVGdW5jdGlvbjFbMF1bMF0sXG4gICAgICAgICAgICAgICAgdGltZUZ1bmN0aW9uMVswXVsxXSxcbiAgICAgICAgICAgICAgICB0aW1lRnVuY3Rpb24xWzFdWzBdLFxuICAgICAgICAgICAgICAgIHRpbWVGdW5jdGlvbjFbMV1bMV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBzY3JvbGxBbmltYXRpb24gPSBuZXcgbGliLmFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICAgIHQxLnRvRml4ZWQoMCksXG4gICAgICAgICAgICAgICAgICBiZXppZXIsXG4gICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoczAgKyBfcyAqIGkyKVxuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybU9mZnNldCh0aGF0LCBvZmZzZXQudG9GaXhlZCgyKSlcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycsIHtcbiAgICAgICAgICAgICAgICAgIGFmdGVyRmxpY2s6IHRydWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5vbmVuZChzY3JvbGxFbmQpXG5cbiAgICAgICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLnBsYXkoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY3NzXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzMS50b0ZpeGVkKDApXG4gICAgICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICh0MSAvIDEwMDApLnRvRml4ZWQoMikgKyAncycsXG4gICAgICAgICAgICAgICAgJ2N1YmljLWJlemllcignICsgdGltZUZ1bmN0aW9uMSArICcpJ1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkVuZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgc2Nyb2xsRW5kLFxuICAgICAgICAgICAgICAgICh0MSAvIDEwMDApLnRvRml4ZWQoMikgKiAxMDAwXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsRW5kKClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoczAgIT09IHMyKSB7XG4gICAgICAgICAgZGVidWdMb2coXG4gICAgICAgICAgICAnc2Nyb2xsIGZvciBpbmVydGlhJyxcbiAgICAgICAgICAgICdzPScgKyBzMi50b0ZpeGVkKDApLFxuICAgICAgICAgICAgJ3Q9JyArICgodDEgKyB0MikgLyAxMDAwKS50b0ZpeGVkKDIpXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfcyA9IHMyIC0gczBcbiAgICAgICAgICAgIHZhciBiZXppZXIgPSBsaWIuY3ViaWNiZXppZXIuZWFzZU91dFxuICAgICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uID0gbmV3IGxpYi5hbmltYXRpb24oXG4gICAgICAgICAgICAgICAgKHQxICsgdDIpLnRvRml4ZWQoMCksXG4gICAgICAgICAgICAgICAgYmV6aWVyLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gczAgKyBfcyAqIGkyXG4gICAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldC50b0ZpeGVkKDIpKVxuICAgICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycse1xuICAgICAgICAgICAgICAgIGFmdGVyRmxpY2s6IHRydWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5vbmVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghdGhhdC5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX3MgPSBzMSAtIHMyXG4gICAgICAgICAgICAgIHZhciBiZXppZXIgPSBsaWIuY3ViaWNiZXppZXIuZWFzZVxuICAgICAgICAgICAgICBzY3JvbGxBbmltYXRpb24gPSBuZXcgbGliLmFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICAgIDQwMCxcbiAgICAgICAgICAgICAgICAgIGJlemllcixcbiAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoaTEsIGkyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHMyICsgX3MgKiBpMlxuICAgICAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldC50b0ZpeGVkKDIpKVxuICAgICAgICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJyx7XG4gICAgICAgICAgICAgICAgICBhZnRlckZsaWNrOiB0cnVlXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBzY3JvbGxBbmltYXRpb24ub25lbmQoc2Nyb2xsRW5kKVxuXG4gICAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5wbGF5KClcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5wbGF5KClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHMyLnRvRml4ZWQoMClcbiAgICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZShcbiAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgKCh0MSArIHQyKSAvIDEwMDApLnRvRml4ZWQoMikgKyAncycsXG4gICAgICAgICAgICAgICdlYXNlLW91dCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcblxuICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkVuZEhhbmRsZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGF0LmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlYnVnTG9nKCdpbmVydGlhbCBib3VuY2UnLFxuICAgICAgICAgICAgICAgICdzPScgKyBzMS50b0ZpeGVkKDApLFxuICAgICAgICAgICAgICAgICd0PTQwMCdcbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgIGlmIChzMiAhPT0gczEpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gczEudG9GaXhlZCgwKVxuICAgICAgICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZSh0aGF0LCAnMC40cycsICdlYXNlJylcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2Zvcm1TdHlsZSh0aGF0LCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgc2V0VHJhbnNpdGlvbkVuZEhhbmRsZXIoc2Nyb2xsRW5kLCA0MDApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsRW5kKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgKCh0MSArIHQyKSAvIDEwMDApLnRvRml4ZWQoMikgKiAxMDAwKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY3JvbGxFbmQoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1Z0xvZygnaW5lcnRpYWwgY2FsY3VsYXRpb24gaGFzblxcJ3QgZXhjZWVkZWQgdGhlIGJvdW5kYXJ5JylcbiAgICAgICAgdmFyIHRpbWVGdW5jdGlvbiA9IG1vdGlvbjAuZ2VuZXJhdGVDdWJpY0JlemllcigpXG5cbiAgICAgICAgaWYgKG9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICAvLyBmcmFtZVxuICAgICAgICAgIHZhciBfcyA9IHMgLSBzMFxuICAgICAgICAgIHZhciBiZXppZXIgPSBsaWIuY3ViaWNiZXppZXIoXG4gICAgICAgICAgICB0aW1lRnVuY3Rpb25bMF1bMF0sXG4gICAgICAgICAgICB0aW1lRnVuY3Rpb25bMF1bMV0sXG4gICAgICAgICAgICB0aW1lRnVuY3Rpb25bMV1bMF0sXG4gICAgICAgICAgICB0aW1lRnVuY3Rpb25bMV1bMV1cbiAgICAgICAgICApXG4gICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uID0gbmV3IGxpYi5hbmltYXRpb24oXG4gICAgICAgICAgICAgIHQwLnRvRml4ZWQoMCksXG4gICAgICAgICAgICAgIGJlemllcixcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGkxLCBpMikge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IChzMCArIF9zICogaTIpLnRvRml4ZWQoMilcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgICAgIGZpcmVFdmVudCh0aGF0LCAnc2Nyb2xsaW5nJyx7XG4gICAgICAgICAgICAgIGFmdGVyRmxpY2s6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbi5vbmVuZChzY3JvbGxFbmQpXG5cbiAgICAgICAgICBzY3JvbGxBbmltYXRpb24ucGxheSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY3NzXG4gICAgICAgICAgdmFyIG9mZnNldCA9IHMudG9GaXhlZCgwKVxuICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZShcbiAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAodDAgLyAxMDAwKS50b0ZpeGVkKDIpICsgJ3MnLFxuICAgICAgICAgICAgJ2N1YmljLWJlemllcignICsgdGltZUZ1bmN0aW9uICsgJyknXG4gICAgICAgICAgKVxuICAgICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uRW5kSGFuZGxlcihzY3JvbGxFbmQsICh0MCAvIDEwMDApLnRvRml4ZWQoMikgKiAxMDAwKVxuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgaXNGbGlja1Njcm9sbGluZyA9IHRydWVcbiAgICAgIGlmICghb3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICBsaWIuYW5pbWF0aW9uLnJlcXVlc3RGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nICYmIGlzRmxpY2tTY3JvbGxpbmcgJiYgdGhhdC5lbmFibGVkKSB7XG4gICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycsIHtcbiAgICAgICAgICAgICAgYWZ0ZXJGbGljazogdHJ1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKGFyZ3VtZW50cy5jYWxsZWUpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbEVuZCgpIHtcbiAgICBpZiAoIXRoYXQuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2FuY2VsU2Nyb2xsRW5kID0gZmFsc2VcblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjYW5jZWxTY3JvbGxFbmQgJiYgaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgaXNTY3JvbGxpbmcgPSBmYWxzZVxuICAgICAgICBpc0ZsaWNrU2Nyb2xsaW5nID0gZmFsc2VcblxuICAgICAgICBpZiAob3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICAgIHNjcm9sbEFuaW1hdGlvbiAmJiBzY3JvbGxBbmltYXRpb24uc3RvcCgpXG4gICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uID0gbnVsbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZSh0aGF0LCAnJywgJycpXG4gICAgICAgIH1cbiAgICAgICAgZmlyZUV2ZW50KHRoYXQsICdzY3JvbGxlbmQnKVxuICAgICAgfVxuICAgIH0sIDUwKVxuICB9XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZW5hYmxlKClcbiAgICAgIHRoaXMucmVmcmVzaCgpXG4gICAgICB0aGlzLnNjcm9sbFRvKDApXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBlbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWVcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudFxuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2VcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICBzY3JvbGxBbmltYXRpb24gJiYgc2Nyb2xsQW5pbWF0aW9uLnN0b3AoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddXG4gICAgICAgICAgICA9IGdldENvbXB1dGVkU3R5bGUoZWwpW3N0eWxlUHJlZml4ICsgJ1RyYW5zZm9ybSddXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGdldFNjcm9sbFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxlbWVudCkud2lkdGhcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsSGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxlbWVudCkuaGVpZ2h0XG4gICAgfSxcblxuICAgIGdldFNjcm9sbExlZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAtZ2V0VHJhbnNmb3JtT2Zmc2V0KHRoaXMpLnggLSB0aGlzLm9wdGlvbnMueFBhZGRpbmdUb3BcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLWdldFRyYW5zZm9ybU9mZnNldCh0aGlzKS55IC0gdGhpcy5vcHRpb25zLnlQYWRkaW5nVG9wXG4gICAgfSxcblxuICAgIGdldE1heFNjcm9sbExlZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAtdGhhdC5tYXhTY3JvbGxPZmZzZXQgLSB0aGlzLm9wdGlvbnMueFBhZGRpbmdUb3BcbiAgICB9LFxuXG4gICAgZ2V0TWF4U2Nyb2xsVG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gLXRoYXQubWF4U2Nyb2xsT2Zmc2V0IC0gdGhpcy5vcHRpb25zLnlQYWRkaW5nVG9wXG4gICAgfSxcblxuICAgIGdldEJvdW5kYXJ5T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoXG4gICAgICAgIGdldEJvdW5kYXJ5T2Zmc2V0KHRoaXMsIGdldFRyYW5zZm9ybU9mZnNldCh0aGlzKVt0aGlzLmF4aXNdKSB8fCAwXG4gICAgICApXG4gICAgfSxcblxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudFxuICAgICAgdmFyIGlzVmVydGljYWwgPSAodGhpcy5heGlzID09PSAneScpXG4gICAgICB2YXIgdHlwZSA9IGlzVmVydGljYWw/J2hlaWdodCc6J3dpZHRoJ1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zW3R5cGVdICE9IG51bGwpIHtcbiAgICAgICAgLy8gdXNlIG9wdGlvbnNcbiAgICAgICAgZWwuc3R5bGVbdHlwZV0gPSB0aGlzLm9wdGlvbnNbdHlwZV0gKyAncHgnXG4gICAgICB9IGVsc2UgaWYgKCEhdGhpcy5vcHRpb25zLnVzZUVsZW1lbnRSZWN0KSB7XG4gICAgICAgIGVsLnN0eWxlW3R5cGVdID0gJ2F1dG8nXG4gICAgICAgIGVsLnN0eWxlW3R5cGVdID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsKVt0eXBlXSArICdweCdcbiAgICAgIH0gZWxzZSBpZiAoZWwuY2hpbGRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgIHZhciByYW5nZVxuICAgICAgICB2YXIgcmVjdFxuICAgICAgICB2YXIgZmlyc3RFbCA9IGVsLmZpcnN0RWxlbWVudENoaWxkXG4gICAgICAgIHZhciBsYXN0RWwgPSBlbC5sYXN0RWxlbWVudENoaWxkXG5cbiAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZVJhbmdlICYmICF0aGlzLm9wdGlvbnMuaWdub3JlT3ZlcmZsb3cpIHtcbiAgICAgICAgICAvLyB1c2UgcmFuZ2VcbiAgICAgICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKClcbiAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZWwpXG4gICAgICAgICAgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyYW5nZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgZWwuc3R5bGVbdHlwZV0gPSByZWN0W3R5cGVdICsgJ3B4J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBjaGlsZCBvZmZzZXRzXG4gICAgICAgICAgd2hpbGUgKGZpcnN0RWwpIHtcbiAgICAgICAgICAgIGlmIChnZXRCb3VuZGluZ0NsaWVudFJlY3QoZmlyc3RFbClbdHlwZV0gPT09IDBcbiAgICAgICAgICAgICAgICAmJiBmaXJzdEVsLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgICBmaXJzdEVsID0gZmlyc3RFbC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGxhc3RFbCAmJiBsYXN0RWwgIT09IGZpcnN0RWwpIHtcbiAgICAgICAgICAgIGlmIChnZXRCb3VuZGluZ0NsaWVudFJlY3QobGFzdEVsKVt0eXBlXSA9PT0gMFxuICAgICAgICAgICAgICAgICYmIGxhc3RFbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgIGxhc3RFbCA9IGxhc3RFbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsLnN0eWxlW3R5cGVdID0gKGdldEJvdW5kaW5nQ2xpZW50UmVjdChsYXN0RWwpW1xuICAgICAgICAgICAgICBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnXVxuICAgICAgICAgICAgLSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZmlyc3RFbClbXG4gICAgICAgICAgICAgIGlzVmVydGljYWwgPyAndG9wJyA6ICdsZWZ0J10pXG4gICAgICAgICAgICArICdweCdcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYW5zZm9ybU9mZnNldCA9IGdldFRyYW5zZm9ybU9mZnNldCh0aGlzKVxuICAgICAgdGhpcy5taW5TY3JvbGxPZmZzZXQgPSBnZXRNaW5TY3JvbGxPZmZzZXQodGhpcylcbiAgICAgIHRoaXMubWF4U2Nyb2xsT2Zmc2V0ID0gZ2V0TWF4U2Nyb2xsT2Zmc2V0KHRoaXMpXG4gICAgICB0aGlzLnNjcm9sbFRvKFxuICAgICAgICAtdGhpcy50cmFuc2Zvcm1PZmZzZXRbdGhpcy5heGlzXVxuICAgICAgICAtIHRoaXMub3B0aW9uc1t0aGlzLmF4aXMgKyAnUGFkZGluZ1RvcCddXG4gICAgICApXG4gICAgICBmaXJlRXZlbnQodGhpcywgJ2NvbnRlbnRyZWZyZXNoJylcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgb2Zmc2V0OiBmdW5jdGlvbiAoY2hpbGRFbCkge1xuICAgICAgdmFyIGVsUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLmVsZW1lbnQpXG4gICAgICB2YXIgY2hpbGRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkRWwpXG4gICAgICBpZiAodGhpcy5heGlzID09PSAneScpIHtcbiAgICAgICAgdmFyIG9mZnNldFJlY3QgPSB7XG4gICAgICAgICAgdG9wOiBjaGlsZFJlY3QudG9wIC0gZWxSZWN0LnRvcCAtIHRoaXMub3B0aW9ucy55UGFkZGluZ1RvcCxcbiAgICAgICAgICBsZWZ0OiBjaGlsZFJlY3QubGVmdCAtIGVsUmVjdC5sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBlbFJlY3QucmlnaHQgLSBjaGlsZFJlY3QucmlnaHQsXG4gICAgICAgICAgd2lkdGg6IGNoaWxkUmVjdC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNoaWxkUmVjdC5oZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldFJlY3QuYm90dG9tID0gb2Zmc2V0UmVjdC50b3AgKyBvZmZzZXRSZWN0LmhlaWdodFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9mZnNldFJlY3QgPSB7XG4gICAgICAgICAgdG9wOiBjaGlsZFJlY3QudG9wIC0gZWxSZWN0LnRvcCxcbiAgICAgICAgICBib3R0b206IGVsUmVjdC5ib3R0b20gLSBjaGlsZFJlY3QuYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IGNoaWxkUmVjdC5sZWZ0IC0gZWxSZWN0LmxlZnQgLSB0aGlzLm9wdGlvbnMueFBhZGRpbmdUb3AsXG4gICAgICAgICAgd2lkdGg6IGNoaWxkUmVjdC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNoaWxkUmVjdC5oZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldFJlY3QucmlnaHQgPSBvZmZzZXRSZWN0LmxlZnQgKyBvZmZzZXRSZWN0LndpZHRoXG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0UmVjdFxuICAgIH0sXG5cbiAgICBnZXRSZWN0OiBmdW5jdGlvbiAoY2hpbGRFbCkge1xuICAgICAgdmFyIHZpZXdSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMudmlld3BvcnQpXG4gICAgICB2YXIgY2hpbGRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkRWwpXG4gICAgICBpZiAodGhpcy5heGlzID09PSAneScpIHtcbiAgICAgICAgdmFyIG9mZnNldFJlY3QgPSB7XG4gICAgICAgICAgdG9wOiBjaGlsZFJlY3QudG9wIC0gdmlld1JlY3QudG9wLFxuICAgICAgICAgIGxlZnQ6IGNoaWxkUmVjdC5sZWZ0IC0gdmlld1JlY3QubGVmdCxcbiAgICAgICAgICByaWdodDogdmlld1JlY3QucmlnaHQgLSBjaGlsZFJlY3QucmlnaHQsXG4gICAgICAgICAgd2lkdGg6IGNoaWxkUmVjdC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNoaWxkUmVjdC5oZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldFJlY3QuYm90dG9tID0gb2Zmc2V0UmVjdC50b3AgKyBvZmZzZXRSZWN0LmhlaWdodFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9mZnNldFJlY3QgPSB7XG4gICAgICAgICAgdG9wOiBjaGlsZFJlY3QudG9wIC0gdmlld1JlY3QudG9wLFxuICAgICAgICAgIGJvdHRvbTogdmlld1JlY3QuYm90dG9tIC0gY2hpbGRSZWN0LmJvdHRvbSxcbiAgICAgICAgICBsZWZ0OiBjaGlsZFJlY3QubGVmdCAtIHZpZXdSZWN0LmxlZnQsXG4gICAgICAgICAgd2lkdGg6IGNoaWxkUmVjdC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNoaWxkUmVjdC5oZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldFJlY3QucmlnaHQgPSBvZmZzZXRSZWN0LmxlZnQgKyBvZmZzZXRSZWN0LndpZHRoXG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0UmVjdFxuICAgIH0sXG5cbiAgICBpc0luVmlldzogZnVuY3Rpb24gKGNoaWxkRWwpIHtcbiAgICAgIHZhciB2aWV3UmVjdCA9IHRoaXMuZ2V0UmVjdCh0aGlzLnZpZXdwb3J0KVxuICAgICAgdmFyIGNoaWxkUmVjdCA9IHRoaXMuZ2V0UmVjdChjaGlsZEVsKVxuICAgICAgaWYgKHRoaXMuYXhpcyA9PT0gJ3knKSB7XG4gICAgICAgIHJldHVybiB2aWV3UmVjdC50b3AgPCBjaGlsZFJlY3QuYm90dG9tXG4gICAgICAgICAgJiYgdmlld1JlY3QuYm90dG9tID4gY2hpbGRSZWN0LnRvcFxuICAgICAgfVxuICAgICAgcmV0dXJuIHZpZXdSZWN0LmxlZnQgPCBjaGlsZFJlY3QucmlnaHRcbiAgICAgICAgJiYgdmlld1JlY3QucmlnaHQgPiBjaGlsZFJlY3QubGVmdFxuICAgIH0sXG5cbiAgICBzY3JvbGxUbzogZnVuY3Rpb24gKG9mZnNldCwgaXNTbW9vdGgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRcblxuICAgICAgb2Zmc2V0ID0gLW9mZnNldCAtIHRoaXMub3B0aW9uc1t0aGlzLmF4aXMgKyAnUGFkZGluZ1RvcCddXG4gICAgICBvZmZzZXQgPSB0b3VjaEJvdW5kYXJ5KHRoaXMsIG9mZnNldClcblxuICAgICAgaXNTY3JvbGxpbmcgPSB0cnVlXG4gICAgICBpZiAoaXNTbW9vdGggPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VGcmFtZUFuaW1hdGlvbikge1xuICAgICAgICAgIHZhciBzMCA9IGdldFRyYW5zZm9ybU9mZnNldCh0aGF0KVt0aGlzLmF4aXNdXG4gICAgICAgICAgdmFyIF9zID0gb2Zmc2V0IC0gczBcbiAgICAgICAgICBzY3JvbGxBbmltYXRpb24gPSBuZXcgbGliLmFuaW1hdGlvbihcbiAgICAgICAgICAgICAgNDAwLFxuICAgICAgICAgICAgICBsaWIuY3ViaWNiZXppZXIuZWFzZUluT3V0LFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoaTEsIGkyKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKHMwICsgX3MgKiBpMikudG9GaXhlZCgyKVxuICAgICAgICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgb2Zmc2V0KVxuICAgICAgICAgICAgZmlyZUV2ZW50KHRoYXQsICdzY3JvbGxpbmcnKVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBzY3JvbGxBbmltYXRpb24ub25lbmQoc2Nyb2xsRW5kKVxuXG4gICAgICAgICAgc2Nyb2xsQW5pbWF0aW9uLnBsYXkoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldFRyYW5zaXRpb25TdHlsZSh0aGF0LCAnMC40cycsICdlYXNlLWluLW91dCcpXG4gICAgICAgICAgc2V0VHJhbnNmb3JtU3R5bGUodGhhdCwgb2Zmc2V0KVxuICAgICAgICAgIHNldFRyYW5zaXRpb25FbmRIYW5kbGVyKHNjcm9sbEVuZCwgNDAwKVxuXG4gICAgICAgICAgbGliLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nICYmIHRoYXQuZW5hYmxlZCkge1xuICAgICAgICAgICAgICBmaXJlRXZlbnQodGhhdCwgJ3Njcm9sbGluZycpXG4gICAgICAgICAgICAgIGxpYi5hbmltYXRpb24ucmVxdWVzdEZyYW1lKGFyZ3VtZW50cy5jYWxsZWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMudXNlRnJhbWVBbmltYXRpb24pIHtcbiAgICAgICAgICBzZXRUcmFuc2l0aW9uU3R5bGUodGhhdCwgJycsICcnKVxuICAgICAgICB9XG4gICAgICAgIHNldFRyYW5zZm9ybVN0eWxlKHRoYXQsIG9mZnNldClcbiAgICAgICAgc2Nyb2xsRW5kKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgc2Nyb2xsVG9FbGVtZW50OiBmdW5jdGlvbiAoY2hpbGRFbCwgaXNTbW9vdGgpIHtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldChjaGlsZEVsKVxuICAgICAgb2Zmc2V0ID0gb2Zmc2V0W3RoaXMuYXhpcyA9PT0gJ3knPyd0b3AnOidsZWZ0J11cbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbFRvKG9mZnNldCwgaXNTbW9vdGgpXG4gICAgfSxcblxuICAgIGdldFZpZXdXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLnZpZXdwb3J0KS53aWR0aFxuICAgIH0sXG5cbiAgICBnZXRWaWV3SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMudmlld3BvcnQpLmhlaWdodFxuICAgIH0sXG5cbiAgICBhZGRQdWxsZG93bkhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwdWxsZG93bmVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoYXQuZGlzYWJsZSgpXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGF0LCBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5zY3JvbGxUbygwLCB0cnVlKVxuICAgICAgICAgIHRoYXQucmVmcmVzaCgpXG4gICAgICAgICAgdGhhdC5lbmFibGUoKVxuICAgICAgICB9KVxuICAgICAgfSwgZmFsc2UpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGFkZFB1bGx1cEhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcblxuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3B1bGx1cGVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoYXQuZGlzYWJsZSgpXG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGF0LCBlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5zY3JvbGxUbyh0aGF0LmdldFNjcm9sbEhlaWdodCgpLCB0cnVlKVxuICAgICAgICAgIHRoYXQucmVmcmVzaCgpXG4gICAgICAgICAgdGhhdC5lbmFibGUoKVxuICAgICAgICB9KVxuICAgICAgfSwgZmFsc2UpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGFkZFNjcm9sbHN0YXJ0SGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbHN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoYXQsIGUpXG4gICAgICB9LCBmYWxzZSlcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gICAgYWRkU2Nyb2xsaW5nSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbGluZycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGF0LCBlKVxuICAgICAgfSwgZmFsc2UpXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAgIGFkZFNjcm9sbGVuZEhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGxlbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBoYW5kbGVyLmNhbGwodGhhdCwgZSlcbiAgICAgIH0sIGZhbHNlKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICBhZGRDb250ZW50cmVuZnJlc2hIYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGVudHJlZnJlc2gnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBoYW5kbGVyLmNhbGwodGhhdCwgZSlcbiAgICAgIH0sIGZhbHNlKVxuICAgIH0sXG5cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBoYW5kbGVyLmNhbGwodGhhdCwgZSlcbiAgICAgIH0sICEhdXNlQ2FwdHVyZSlcbiAgICB9LFxuXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpc1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoYXQsIGUpXG4gICAgICB9KVxuICAgIH0sXG5cbiAgICBlbmFibGVQbHVnaW46IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGx1Z2luID0gcGx1Z2luc1tuYW1lXVxuICAgICAgaWYgKHBsdWdpbiAmJiAhdGhpcy5wbHVnaW5zW25hbWVdKSB7XG4gICAgICAgIHRoaXMucGx1Z2luc1tuYW1lXSA9IHRydWVcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICAgICAgcGx1Z2luLmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucylcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgayBpbiBwcm90bykge1xuICAgIHRoaXNba10gPSBwcm90b1trXVxuICB9XG4gIGRlbGV0ZSBwcm90b1xufVxuXG5saWIuc2Nyb2xsID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICEoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXVxuICAgIGlmIChvcHRpb25zLnNjcm9sbEVsZW1lbnQpIHtcbiAgICAgIGVsID0gb3B0aW9ucy5zY3JvbGxFbGVtZW50XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnNjcm9sbFdyYXApIHtcbiAgICAgIGVsID0gb3B0aW9ucy5zY3JvbGxXcmFwLmZpcnN0RWxlbWVudENoaWxkXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gc2Nyb2xsIGVsZW1lbnQnKVxuICAgIH1cbiAgfVxuXG4gIGlmICghZWwucGFyZW50Tm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgZG9tIHRyZWUnKVxuICB9XG4gIGlmIChvcHRpb25zXG4gICAgICAmJiBvcHRpb25zLmRpcmVjdGlvblxuICAgICAgJiYgWyd4JywgJ3knXS5pbmRleE9mKG9wdGlvbnMuZGlyZWN0aW9uKSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIGRpcmVjdGlvbicpXG4gIH1cblxuICB2YXIgc2Nyb2xsXG4gIGlmIChvcHRpb25zLmRvd25ncmFkZSA9PT0gdHJ1ZVxuICAgICAgJiYgbGliLnNjcm9sbC5kb3duZ3JhZGUpIHtcbiAgICBzY3JvbGwgPSBsaWIuc2Nyb2xsLmRvd25ncmFkZShlbCwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWwuc2Nyb2xsSWQpIHtcbiAgICAgIHNjcm9sbCA9IHNjcm9sbE9ianNbZWwuc2Nyb2xsSWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIHNjcm9sbCA9IG5ldyBTY3JvbGwoZWwsIG9wdGlvbnMpXG4gICAgfVxuICB9XG4gIHJldHVybiBzY3JvbGxcbn1cblxubGliLnNjcm9sbC5wbHVnaW4gPSBmdW5jdGlvbiAobmFtZSwgY29uc3RydWN0b3IpIHtcbiAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgbmFtZSA9IG5hbWUuc3BsaXQoJywnKVxuICAgIG5hbWUuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgcGx1Z2luc1tuXSA9IGNvbnN0cnVjdG9yXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGx1Z2luc1tuYW1lXVxuICB9XG59XG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL3Njcm9sbC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIHRyYW5zZmVyIFF1YWRyYXRpYyBCZXppZXIgQ3VydmUgdG8gQ3ViaWMgQmV6aWVyIEN1cnZlXG4gKlxuICogQHBhcmFtICB7bnVtYmVyfSBhIGFic2Npc3NhIG9mIHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGIgb3JkaW5hdGUgb2YgcDFcbiAqIEByZXR1cm4ge0FycmF5fSBwYXJhbWV0ZXIgbWF0cml4IGZvciBjdWJpYyBiZXppZXIgY3VydmVcbiAqICAgbGlrZSBbW3AxeCwgcDF5XSwgW3AyeCwgcDJ5XV1cbiAqL1xuZnVuY3Rpb24gcXVhZHJhdGljMmN1YmljQmV6aWVyKGEsIGIpIHtcbiAgcmV0dXJuIFtcbiAgICBbXG4gICAgICAoYSAvIDMgKyAoYSArIGIpIC8gMyAtIGEpIC8gKGIgLSBhKSxcbiAgICAgIChhICogYSAvIDMgKyBhICogYiAqIDIgLyAzIC0gYSAqIGEpIC8gKGIgKiBiIC0gYSAqIGEpXG4gICAgXSwgW1xuICAgICAgKGIgLyAzICsgKGEgKyBiKSAvIDMgLSBhKSAvIChiIC0gYSksXG4gICAgICAoYiAqIGIgLyAzICsgYSAqIGIgKiAyIC8gMyAtIGEgKiBhKSAvIChiICogYiAtIGEgKiBhKVxuICAgIF1cbiAgXVxufVxuXG4vKipcbiAqIGRlcml2ZSBwb3NpdGlvbiBkYXRhIGZyb20ga25vd2luZyBtb3Rpb24gcGFyYW1ldGVyc1xuICogYmFzZSBvbiBOZXd0b24ncyBzZWNvbmQgbGF3OiBzID0gdnQgKyBhdF4yLzJcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIG9iamVjdCBvZiB7IHYsIGEsIHMsIHQgfVxuICogICAtIHY6IGluaXRpYWwgdmVsb2NpdHlcbiAqICAgLSBhOiBhY2NlbGVyYXRlIHNwZWVkXG4gKiAgIC0gdDogdGltZVxuICogICAtIHM6IHNoaWZ0aW5nXG4gKi9cbmZ1bmN0aW9uIE1vdGlvbihjb25maWcpIHtcblxuICB0aGlzLnYgPSBjb25maWcudiB8fCAwXG4gIHRoaXMuYSA9IGNvbmZpZy5hIHx8IDBcblxuICBpZiAodHlwZW9mIGNvbmZpZy50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMudCA9IGNvbmZpZy50XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbmZpZy5zICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMucyA9IGNvbmZpZy5zXG4gIH1cblxuICAvLyBkZXJpdmUgdGltZSBmcm9tIHNoaWZ0aW5nXG4gIGlmICh0eXBlb2YgdGhpcy50ID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy50ID0gLXRoaXMudiAvIHRoaXMuYVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdDEgPSAoTWF0aC5zcXJ0KHRoaXMudiAqIHRoaXMudiArIDIgKiB0aGlzLmEgKiB0aGlzLnMpIC0gdGhpcy52KVxuICAgICAgICAvIHRoaXMuYVxuICAgICAgdmFyIHQyID0gKC1NYXRoLnNxcnQodGhpcy52ICogdGhpcy52ICsgMiAqIHRoaXMuYSAqIHRoaXMucykgLSB0aGlzLnYpXG4gICAgICAgIC8gdGhpcy5hXG4gICAgICB0aGlzLnQgPSBNYXRoLm1pbih0MSwgdDIpXG4gICAgfVxuICB9XG5cbiAgLy8gZGVyaXZlIHNoaWZ0aW5nIGZyb20gdGltZVxuICBpZiAodHlwZW9mIHRoaXMucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLnMgPSB0aGlzLmEgKiB0aGlzLnQgKiB0aGlzLnQgLyAyICsgdGhpcy52ICogdGhpcy50XG4gIH1cbn1cblxuLyoqXG4gKiBkZXJpdmUgY3ViaWMgYmV6aWVyIHBhcmFtZXRlcnMgZnJvbSBtb3Rpb24gcGFyYW1ldGVyc1xuICogQHJldHVybiB7QXJyYXl9IHBhcmFtZXRlciBtYXRyaXggZm9yIGN1YmljIGJlemllciBjdXJ2ZVxuICogICBsaWtlIFtbcDF4LCBwMXldLCBbcDJ4LCBwMnldXVxuICovXG5Nb3Rpb24ucHJvdG90eXBlLmdlbmVyYXRlQ3ViaWNCZXppZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBxdWFkcmF0aWMyY3ViaWNCZXppZXIoXG4gICAgdGhpcy52IC8gdGhpcy5hLCB0aGlzLnQgKyB0aGlzLnYgLyB0aGlzLmFcbiAgKVxufVxuXG4hbGliICYmIChsaWIgPSB7fSlcbmxpYi5tb3Rpb24gPSBNb3Rpb25cblxubW9kdWxlLmV4cG9ydHMgPSBNb3Rpb25cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9tb3Rpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJ2YXIgTGlzdCA9IHJlcXVpcmUoJy4vbGlzdCcpXG5cbmZ1bmN0aW9uIEhsaXN0KGRhdGEsIG5vZGVUeXBlKSB7XG4gIGRhdGEuYXR0ci5kaXJlY3Rpb24gPSAnaCdcbiAgTGlzdC5jYWxsKHRoaXMsIGRhdGEsIG5vZGVUeXBlKVxufVxuXG5IbGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExpc3QucHJvdG90eXBlKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhsaXN0XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9obGlzdC5qc1xuICoqIG1vZHVsZSBpZCA9IDQ5XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQXRvbWljID0gcmVxdWlyZSgnLi9hdG9taWMnKVxucmVxdWlyZSgna291bnRkb3duL2J1aWxkL2NvdW50ZG93bicpXG5cbnZhciBGT1JNQVRURVJfUkVHRVhQID0gLyhcXFxcKT8oZGQqfGhoP3xtbT98c3M/KS9naVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlVGltZShkYXRhLCBmb3JtYXR0ZXIsIHRpbWVDb2xvcikge1xuICByZXR1cm4gZm9ybWF0dGVyLnJlcGxhY2UoRk9STUFUVEVSX1JFR0VYUCwgZnVuY3Rpb24gKG0pIHtcbiAgICB2YXIgbGVuID0gbS5sZW5ndGhcbiAgICB2YXIgZmlyc3RDaGFyID0gbS5jaGFyQXQoMClcbiAgICAvLyBlc2NhcGUgY2hhcmFjdGVyXG4gICAgaWYgKGZpcnN0Q2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICByZXR1cm4gbS5yZXBsYWNlKCdcXFxcJywgJycpXG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IChmaXJzdENoYXIgPT09ICdkJyA/IGRhdGEuZGF5cyA6XG4gICAgICAgICAgICAgICAgZmlyc3RDaGFyID09PSAnaCcgPyBkYXRhLmhvdXJzIDpcbiAgICAgICAgICAgICAgICBmaXJzdENoYXIgPT09ICdtJyA/IGRhdGEubWludXRlcyA6XG4gICAgICAgICAgICAgICAgZmlyc3RDaGFyID09PSAncycgPyBkYXRhLnNlY29uZHMgOiAwKSArICcnXG5cbiAgICAvLyA1IHplcm8gc2hvdWxkIGJlIGVub3VnaFxuICAgIHJldHVybiAnPHNwYW4gc3R5bGU9XCJtYXJnaW46NHB4O2NvbG9yOidcbiAgICAgICsgdGltZUNvbG9yICsgJ1wiID4nXG4gICAgICArICgnMDAwMDAnICsgdmFsdWUpLnN1YnN0cigtTWF0aC5tYXgodmFsdWUubGVuZ3RoLCBsZW4pKVxuICAgICAgKyAnPC9zcGFuPidcbiAgfSlcbn1cblxuZnVuY3Rpb24gQ291bnRkb3duIChkYXRhKSB7XG4gIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG59XG5cbkNvdW50ZG93bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG5cbkNvdW50ZG93bi5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1lbGVtZW50JylcbiAgdmFyIGRhdGEgPSB0aGlzLmRhdGFcbiAgdmFyIHRpbWUgPSBOdW1iZXIoZGF0YS5hdHRyLmNvdW50ZG93blRpbWUpIHx8IDBcbiAgdmFyIGVuZFRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMCArIHRpbWVcbiAgdmFyIGNkID0gbGliLmNvdW50ZG93bih7XG4gICAgZW5kRGF0ZTogZW5kVGltZSxcbiAgICBvblVwZGF0ZTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgIHZhciB0aW1lQ29sb3IgPSBkYXRhLnN0eWxlLnRpbWVDb2xvciB8fCAnIzAwMCdcbiAgICAgIHZhciByZXN1bHQgPSBmb3JtYXREYXRlVGltZSh0aW1lLCBkYXRhLmF0dHIuZm9ybWF0dGVyVmFsdWUsIHRpbWVDb2xvcilcbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gcmVzdWx0XG4gICAgfSxcbiAgICBvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgIH1cbiAgfSkuc3RhcnQoKVxuXG4gIHJldHVybiBub2RlXG59XG5cbkNvdW50ZG93bi5wcm90b3R5cGUuc3R5bGUgPSB7XG4gIHRleHRDb2xvcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5ub2RlLnN0eWxlLmNvbG9yID0gdmFsdWVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvdW50ZG93blxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9jb3VudGRvd24uanNcbiAqKiBtb2R1bGUgaWQgPSA1MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIhZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe3ZhciBiO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKWI9bmV3IERhdGUoMWUzKmEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGEpe3ZhciBjPWEuY2hhckF0KDApLGQ9XCIrXCI9PT1jLGg9XCItXCI9PT1jO2lmKGR8fGgpe2Zvcih2YXIgaSxqPWEuc3Vic3RyKDEpLGs9ai5zcGxpdChcIjpcIiksbD1bMCwwLDAsMF0sbT00O2subGVuZ3RoJiYtLW0+PTA7KWxbbV09cGFyc2VJbnQoay5wb3AoKSl8fDA7aT1lKmxbMF0rZipsWzFdK2cqbFsyXStsWzNdLGI9bmV3IERhdGUsYi5zZXRTZWNvbmRzKGIuZ2V0U2Vjb25kcygpK2kqKGg/LTE6MSkpLGIuc2V0TWlsbGlzZWNvbmRzKDApfX1yZXR1cm4gYnx8KGI9bmV3IERhdGUoYSkpLGJ9ZnVuY3Rpb24gZChhLGIpe3JldHVybiBiLnJlcGxhY2UoRk9STUFUVEVSX1JFR0VYUCxmdW5jdGlvbihiKXt2YXIgYz1iLmxlbmd0aCxkPWIuY2hhckF0KDApO2lmKFwiXFxcXFwiPT09ZClyZXR1cm4gYi5yZXBsYWNlKFwiXFxcXFwiLFwiXCIpO3ZhciBlPShcImRcIj09PWQ/YS5kYXlzOlwiaFwiPT09ZD9hLmhvdXJzOlwibVwiPT09ZD9hLm1pbnV0ZXM6XCJzXCI9PT1kP2Euc2Vjb25kczowKStcIlwiO3JldHVybihcIjAwMDAwXCIrZSkuc3Vic3RyKC1NYXRoLm1heChlLmxlbmd0aCxjKSl9KX12YXIgZT04NjQwMCxmPTM2MDAsZz02MCxoPVwiZOWkqWho5pe2bW3liIZzc+enklwiO0ZPUk1BVFRFUl9SRUdFWFA9LyhcXFxcKT8oZGQqfGhoP3xtbT98c3M/KS9naTt2YXIgaT1mdW5jdGlvbihhKXthPWF8fHt9O3ZhciBiPXRoaXMsZD1jKGEuZW5kRGF0ZSk7aWYoIWR8fCFkLmdldFRpbWUoKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGVuZERhdGVcIik7Yi5lbmREYXRlPWQsYi5vblVwZGF0ZT1hLm9uVXBkYXRlLGIub25FbmQ9YS5vbkVuZCxiLmludGVydmFsPWEuaW50ZXJ2YWx8fDFlMyxiLnN0cmluZ0Zvcm1hdHRlcj1hLnN0cmluZ0Zvcm1hdHRlcnx8aCxiLmNvcnJlY3REYXRlT2Zmc2V0PWEuY29ycmVjdERhdGVPZmZzZXR8fDAsYi51cGRhdGVFbGVtZW50PWEudXBkYXRlRWxlbWVudCxiLl9kYXRhPXtkYXlzOjAsaG91cnM6MCxtaW51dGVzOjAsc2Vjb25kczowfX07aS5wcm90b3R5cGU9e3N0YXJ0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gYS5zdG9wKCksYS5fdXBkYXRlKCkmJihhLl9pbnRlcnZhbElkPXNldEludGVydmFsKGZ1bmN0aW9uKCl7YS5fdXBkYXRlKCl9LGEuaW50ZXJ2YWwpKSxhfSxfdXBkYXRlOmZ1bmN0aW9uKCl7dmFyIGEsYj10aGlzLGM9Yi5fZGF0YSxoPWIudXBkYXRlRWxlbWVudCxpPStuZXcgRGF0ZSsxZTMqYi5jb3JyZWN0RGF0ZU9mZnNldCxqPU1hdGgubWF4KDAsTWF0aC5yb3VuZCgoYi5lbmREYXRlLmdldFRpbWUoKS1pKS8xZTMpKSxrPTA+PWo7cmV0dXJuIGMudG90YWxTZWNvbmRzPWosai09KGMuZGF5cz1NYXRoLmZsb29yKGovZSkpKmUsai09KGMuaG91cnM9TWF0aC5mbG9vcihqL2YpKSpmLGotPShjLm1pbnV0ZXM9TWF0aC5mbG9vcihqL2cpKSpnLGMuc2Vjb25kcz1qLGMuc3RyaW5nVmFsdWU9ZChjLGIuc3RyaW5nRm9ybWF0dGVyKSxoJiYoaC5pbm5lckhUTUw9Yy5zdHJpbmdWYWx1ZSksKGE9Yi5vblVwZGF0ZSkmJmEuY2FsbChiLGMpLGs/KGIuc3RvcCgpLChhPWIub25FbmQpJiZhLmNhbGwoYiksITEpOiEwfSxzdG9wOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gYS5faW50ZXJ2YWxJZCYmKGNsZWFySW50ZXJ2YWwoYS5faW50ZXJ2YWxJZCksYS5faW50ZXJ2YWxJZD1udWxsKSxhfSxzZXRFbmREYXRlOmZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIGIuZW5kRGF0ZT1jKGEpLGJ9fSxiLmNvdW50ZG93bj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGkoYSl9fSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L34va291bnRkb3duL2J1aWxkL2NvdW50ZG93bi5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJylcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudCcpXG52YXIgQ29tcG9uZW50TWFuYWdlciA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudE1hbmFnZXInKVxudmFyIExhenlMb2FkID0gcmVxdWlyZSgnLi4vbGF6eUxvYWQnKVxuXG5mdW5jdGlvbiBNYXJxdWVlIChkYXRhKSB7XG4gIHRoaXMuaW50ZXJ2YWwgPSBOdW1iZXIoZGF0YS5hdHRyLmludGVydmFsKSB8fCA1ICogMTAwMFxuICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA9IE51bWJlcihkYXRhLmF0dHIudHJhbnNpdGlvbkR1cmF0aW9uKSB8fCA1MDBcbiAgdGhpcy5kZWxheSA9IE51bWJlcihkYXRhLmF0dHIuZGVsYXkpIHx8IDBcbiAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSlcbn1cblxuTWFycXVlZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG5cbk1hcnF1ZWUucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJylcbiAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nXG4gIC8vIGZpeCBwYWdlIHNoYWtpbmcgZHVyaW5nIHNsaWRlcidzIHBsYXlpbmdcbiAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlM0QoMCwwLDApJ1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdFRyYW5zaXRpb25FbmQnLCB0aGlzLmVuZC5iaW5kKHRoaXMpLCBmYWxzZSlcbiAgcmV0dXJuIG5vZGVcbn1cblxuTWFycXVlZS5wcm90b3R5cGUuY3JlYXRlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGZpcnN0IHJ1bjpcbiAgLy8gLSBjcmVhdGUgZWFjaCBjaGlsZFxuICAvLyAtIGFwcGVuZCB0byBwYXJlbnROb2RlXG4gIC8vIC0gZmluZCBjdXJyZW50IGFuZCBuZXh0XG4gIC8vIC0gc2V0IGN1cnJlbnQgYW5kIG5leHQgc2hvd24gYW5kIG90aGVycyBoaWRkZW5cbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuXG4gIHZhciBwYXJlbnRSZWYgPSB0aGlzLmRhdGEucmVmXG4gIHZhciBpbnN0YW5jZUlkID0gdGhpcy5kYXRhLmluc3RhbmNlSWRcbiAgdmFyIGl0ZW1zID0gW11cbiAgdmFyIGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuXG4gIHZhciBmcmFnbWVudCwgaXNGbGV4LCBjaGlsZCwgbm9kZSwgaVxuXG4gIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgIGlzRmxleCA9IGZhbHNlXG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5zY2FsZSA9IHRoaXMuZGF0YS5zY2FsZVxuICAgICAgY2hpbGRyZW5baV0uaW5zdGFuY2VJZCA9IGluc3RhbmNlSWRcbiAgICAgIGNoaWxkID0gY29tcG9uZW50TWFuYWdlci5jcmVhdGVFbGVtZW50KGNoaWxkcmVuW2ldKVxuICAgICAgY2hpbGQucGFyZW50UmVmID0gcGFyZW50UmVmXG4gICAgICB0aGlzLmluaXRDaGlsZChjaGlsZClcbiAgICAgIC8vIGFwcGVuZCBhbmQgcHVzaFxuICAgICAgaXRlbXMucHVzaChjaGlsZClcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkLm5vZGUpXG4gICAgICBpZiAoIWlzRmxleCAmJiBjaGlsZC5kYXRhLnN0eWxlLmhhc093blByb3BlcnR5KCdmbGV4JykpIHtcbiAgICAgICAgaXNGbGV4ID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpXG4gIH1cblxuICAvLyBzZXQgaXRlbXNcbiAgdGhpcy5pdGVtcyA9IGl0ZW1zXG5cbiAgLy8gcmVzZXQgdGhlIGNsb2NrIGZvciBmaXJzdCB0cmFuc2l0aW9uXG4gIHRoaXMucmVzZXQoKVxufVxuXG5NYXJxdWVlLnByb3RvdHlwZS5pbml0Q2hpbGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgdmFyIG5vZGUgPSBjaGlsZC5ub2RlXG4gIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gIG5vZGUuc3R5bGUudG9wID0gJzAnXG4gIG5vZGUuc3R5bGUubGVmdCA9ICcwJ1xufVxuXG5NYXJxdWVlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIC8vIGRvbSArIGl0ZW1zXG4gIHZhciBjb21wb25lbnRNYW5hZ2VyID0gQ29tcG9uZW50TWFuYWdlci5nZXRJbnN0YW5jZSh0aGlzLmRhdGEuaW5zdGFuY2VJZClcbiAgdmFyIGNoaWxkID0gY29tcG9uZW50TWFuYWdlci5jcmVhdGVFbGVtZW50KGRhdGEpXG4gIHRoaXMuaW5pdENoaWxkKGNoaWxkKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcbiAgdGhpcy5pdGVtcy5wdXNoKGNoaWxkKVxuICB0aGlzLnJlc2V0KClcbiAgcmV0dXJuIGNoaWxkIC8vIEB0b2RvIHJlZGVzaWduIENvbXBvbmVudCNhcHBlbmRDaGlsZChjb21wb25lbnQpXG59XG5cbk1hcnF1ZWUucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChjaGlsZCwgYmVmb3JlKSB7XG4gIC8vIGRvbSArIGl0ZW1zXG4gIHZhciBpbmRleCA9IHRoaXMuaXRlbXMuaW5kZXhPZihiZWZvcmUpXG4gIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAwLCBjaGlsZClcbiAgdGhpcy5pbml0Q2hpbGQoY2hpbGQpXG4gIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQubm9kZSwgYmVmb3JlLm5vZGUpXG4gIHRoaXMucmVzZXQoKVxufVxuXG5NYXJxdWVlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAvLyBkb20gKyBpdGVtc1xuICB2YXIgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoY2hpbGQpXG4gIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKVxuICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQubm9kZSlcbiAgdGhpcy5yZXNldCgpXG59XG5cbi8qKlxuICogc3RhdHVzOiB7XG4gKiAgIGN1cnJlbnQ6IHt0cmFuc2xhdGVZOiAwLCBzaG93bjogdHJ1ZX0sXG4gKiAgIG5leHQ6IHt0cmFuc2xhdGVZOiBoZWlnaHQsIHNob3duOiB0cnVlfSxcbiAqICAgb3RoZXJzW106IHtzaG93bjogZmFsc2V9XG4gKiAgIGluZGV4OiBpbmRleFxuICogfVxuICovXG5NYXJxdWVlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGludGVydmFsID0gdGhpcy5pbnRlcnZhbCAtIDBcbiAgdmFyIGRlbGF5ID0gdGhpcy5kZWxheSAtIDBcbiAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtc1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLm5leHQoKVxuICAgIHNlbGYudGltZXJJZCA9IHNldFRpbWVvdXQobG9vcCwgc2VsZi5pbnRlcnZhbClcbiAgfVxuXG4gIC8vIHJlc2V0IGRpc3BsYXkgYW5kIHRyYW5zZm9ybVxuICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHZhciBub2RlID0gaXRlbS5ub2RlXG4gICAgLy8gc2V0IG5vbi1jdXJyZW50KDApfG5leHQoMSkgaXRlbSBoaWRkZW5cbiAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBpbmRleCA+IDEgPyAnbm9uZScgOiAnJ1xuICAgIC8vIHNldCBuZXh0KDEpIGl0ZW0gdHJhbnNsYXRlWVxuICAgIC8vIFRPRE86IGl0IHN1cHBvc2VkIHRvIHVzZSBpdGVtLmRhdGEuc3R5bGVcbiAgICAvLyBidXQgc29tZWhvdyB0aGUgc3R5bGUgb2JqZWN0IGlzIGVtcHR5LlxuICAgIC8vIFRoaXMgcHJvYmxlbSByZWxpZXMgb24ganNmcmFtZXdvcmsncyBidWdmaXguXG5cbiAgICAvLyBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IGluZGV4ID09PSAxXG4gICAgLy8gICAgID8gJ3RyYW5zbGF0ZTNEKDAsJyArIGNvbmZpZy5zY2FsZSAqIGl0ZW0uZGF0YS5zdHlsZS5oZWlnaHQgKyAncHgsMCknXG4gICAgLy8gICAgIDogJydcbiAgICAvLyBub2RlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IGluZGV4ID09PSAxXG4gICAgLy8gICAgID8gJ3RyYW5zbGF0ZTNEKDAsJyArIGNvbmZpZy5zY2FsZSAqIGl0ZW0uZGF0YS5zdHlsZS5oZWlnaHQgKyAncHgsMCknXG4gICAgLy8gICAgIDogJydcbiAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IGluZGV4ID09PSAxXG4gICAgICAgID8gJ3RyYW5zbGF0ZTNEKDAsJyArIHNlbGYuZGF0YS5zY2FsZSAqIHNlbGYuZGF0YS5zdHlsZS5oZWlnaHQgKyAncHgsMCknXG4gICAgICAgIDogJydcbiAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IGluZGV4ID09PSAxXG4gICAgICAgID8gJ3RyYW5zbGF0ZTNEKDAsJyArIHNlbGYuZGF0YS5zY2FsZSAqIHNlbGYuZGF0YS5zdHlsZS5oZWlnaHQgKyAncHgsMCknXG4gICAgICAgIDogJydcbiAgfSlcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZXNldCBjdXJyZW50LCBuZXh0LCBpbmRleFxuICAgIHNlbGYuY3VycmVudEl0ZW0gPSBpdGVtc1swXVxuICAgIHNlbGYubmV4dEl0ZW0gPSBpdGVtc1sxXVxuICAgIHNlbGYuY3VycmVudEluZGV4ID0gMFxuXG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBub2RlID0gaXRlbS5ub2RlXG4gICAgICAvLyBzZXQgdHJhbnNpdGlvblxuICAgICAgbm9kZS5zdHlsZS50cmFuc2l0aW9uID0gJ3RyYW5zZm9ybSAnXG4gICAgICAgICAgKyBzZWxmLnRyYW5zaXRpb25EdXJhdGlvblxuICAgICAgICAgICsgJ21zIGVhc2UnXG4gICAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnLXdlYmtpdC10cmFuc2Zvcm0gJ1xuICAgICAgICAgICsgc2VsZi50cmFuc2l0aW9uRHVyYXRpb25cbiAgICAgICAgICArICdtcyBlYXNlJ1xuICAgIH0pXG5cbiAgICBjbGVhclRpbWVvdXQoc2VsZi50aW1lcklkKVxuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNlbGYudGltZXJJZCA9IHNldFRpbWVvdXQobG9vcCwgZGVsYXkgKyBpbnRlcnZhbClcbiAgICB9XG4gIH0sIDEzKVxuXG59XG5cbi8qKlxuICogbmV4dDpcbiAqIC0gY3VycmVudDoge3RyYW5zbGF0ZVk6IC1oZWlnaHR9XG4gKiAtIG5leHQ6IHt0cmFuc2xhdGVZOiAwfVxuICovXG5NYXJxdWVlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAvLyAtIHVwZGF0ZSBzdGF0ZVxuICAvLyAgIC0gc2V0IGN1cnJlbnQgYW5kIG5leHQgdHJhbnNpdGlvblxuICAvLyAgIC0gaGlkZSBjdXJyZW50IHdoZW4gdHJhbnNpdGlvbiBlbmRcbiAgLy8gICAtIHNldCBuZXh0IHRvIGN1cnJlbnRcbiAgLy8gICAtIGZpbmQgbmV3IG5leHRcbiAgdmFyIG5leHQgPSB0aGlzLm5leHRJdGVtLm5vZGVcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnRJdGVtLm5vZGVcbiAgdGhpcy50cmFuc2l0aW9uSW5kZXggPSB0aGlzLmN1cnJlbnRJbmRleFxuXG4gIC8vIFVzZSBzZXRUaW1lb3V0IHRvIGZpeCB0aGUgcHJvYmxlbSB0aGF0IHdoZW4gdGhlXG4gIC8vIHBhZ2UgcmVjb3ZlciBmcm9tIGJhY2tzdGFnZSwgdGhlIHNsaWRlciB3aWxsXG4gIC8vIG5vdCB3b3JrIGFueSBsb25nZXIuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIG5leHQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNEKDAsMCwwKSdcbiAgICBuZXh0LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzRCgwLDAsMCknXG4gICAgY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM0QoMCwtJ1xuICAgICAgICArIHRoaXMuZGF0YS5zY2FsZSAqIHRoaXMuZGF0YS5zdHlsZS5oZWlnaHRcbiAgICAgICAgKyAncHgsMCknXG4gICAgY3VycmVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlM0QoMCwtJ1xuICAgICAgICArIHRoaXMuZGF0YS5zY2FsZSAqIHRoaXMuZGF0YS5zdHlsZS5oZWlnaHRcbiAgICAgICAgKyAncHgsMCknXG4gICAgdGhpcy5maXJlRXZlbnQoJ2NoYW5nZScpXG4gIH0uYmluZCh0aGlzKSwgMzAwKVxufVxuXG5NYXJxdWVlLnByb3RvdHlwZS5maXJlRXZlbnQgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5pdGVtcy5sZW5ndGhcbiAgdmFyIG5leHRJbmRleCA9ICh0aGlzLmN1cnJlbnRJbmRleCArIDEpICUgbGVuZ3RoXG4gIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpXG4gIGV2dC5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKVxuICBldnQuZGF0YSA9IHtcbiAgICBwcmV2SW5kZXg6IHRoaXMuY3VycmVudEluZGV4LFxuICAgIGluZGV4OiBuZXh0SW5kZXhcbiAgfVxuICB0aGlzLm5vZGUuZGlzcGF0Y2hFdmVudChldnQpXG59XG5cbi8qKlxuICogZW5kOlxuICogLSBvbGQgY3VycmVudDoge3Nob3duOiBmYWxzZX1cbiAqIC0gb2xkIGN1cnJlbnQ6IHt0cmFuc2xhdGVZOiAwfVxuICogLSBpbmRleCsrICUgbGVuZ3RoXG4gKiAtIG5ldyBjdXJyZW50ID0gb2xkIG5leHRcbiAqIC0gbmV3IG5leHQgPSBpdGVtc1tpbmRleCsxICUgbGVuZ3RoXVxuICogLSBuZXcgbmV4dDoge3RyYW5zbGF0ZVk6IGhlaWdodH1cbiAqIC0gbmV3IG5leHQ6IHtzaG93bjogdHJ1ZX1cbiAqL1xuTWFycXVlZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgdmFyIHRhcmdldCA9IGUudGFyZ2V0XG4gIHZhciBpdGVtcyA9IHRoaXMuaXRlbXNcbiAgdmFyIGxlbmd0aCA9IGl0ZW1zLmxlbmd0aFxuICB2YXIgY3VycmVudCwgbmV4dFxuICB2YXIgY3VycmVudEluZGV4LCBuZXh0SW5kZXhcblxuICBjdXJyZW50SW5kZXggPSB0aGlzLnRyYW5zaXRpb25JbmRleFxuXG4gIGlmIChpc05hTihjdXJyZW50SW5kZXgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRoaXMudHJhbnNpdGlvbkluZGV4XG5cbiAgY3VycmVudCA9IHRoaXMuY3VycmVudEl0ZW0ubm9kZVxuICBjdXJyZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgY3VycmVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnJ1xuXG4gIGN1cnJlbnRJbmRleCA9IChjdXJyZW50SW5kZXggKyAxKSAlIGxlbmd0aFxuICBuZXh0SW5kZXggPSAoY3VycmVudEluZGV4ICsgMSkgJSBsZW5ndGhcblxuICB0aGlzLmN1cnJlbnRJbmRleCA9IGN1cnJlbnRJbmRleFxuICB0aGlzLmN1cnJlbnRJdGVtID0gdGhpcy5uZXh0SXRlbVxuICB0aGlzLm5leHRJdGVtID0gaXRlbXNbbmV4dEluZGV4XVxuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIG5leHQgPSB0aGlzLm5leHRJdGVtLm5vZGVcbiAgICAvLyBUT0RPOiBpdCBzdXBwb3NlZCB0byB1c2UgdGhpcy5uZXh0SXRlbS5kYXRhLnN0eWxlXG4gICAgLy8gYnV0IHNvbWVob3cgdGhlIHN0eWxlIG9iamVjdCBpcyBlbXB0eS5cbiAgICAvLyBUaGlzIHByb2JsZW0gcmVsaWVzIG9uIGpzZnJhbWV3b3JrJ3MgYnVnZml4LlxuXG4gICAgbmV4dC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlM0QoMCwnXG4gICAgICAgICsgdGhpcy5kYXRhLnNjYWxlICogdGhpcy5kYXRhLnN0eWxlLmhlaWdodFxuICAgICAgICArICdweCwwKSdcbiAgICBuZXh0LnN0eWxlLmRpc3BsYXkgPSAnJ1xuICAgIExhenlMb2FkLmxvYWRJZk5lZWRlZChuZXh0KVxuICB9LmJpbmQodGhpcykpXG59XG5cbk1hcnF1ZWUucHJvdG90eXBlLmF0dHIgPSB7XG4gIGludGVydmFsOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmludGVydmFsID0gdmFsdWVcbiAgfSxcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA9IHZhbHVlXG4gIH0sXG4gIGRlbGF5OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmRlbGF5ID0gdmFsdWVcbiAgfVxufVxuXG5NYXJxdWVlLnByb3RvdHlwZS5jbGVhckF0dHIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW50ZXJ2YWwgPSA1ICogMTAwMFxuICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbiA9IDUwMFxuICB0aGlzLmRlbGF5ID0gMFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcnF1ZWVcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvbWFycXVlZS5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5leHRlbmRcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi9jb25maWcnKVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50JylcbnZhciBDb21wb25lbnRNYW5hZ2VyID0gcmVxdWlyZSgnLi4vY29tcG9uZW50TWFuYWdlcicpXG52YXIgTGF6eUxvYWQgPSByZXF1aXJlKCcuLi9sYXp5TG9hZCcpXG5yZXF1aXJlKCdjYXJyb3VzZWwnKVxucmVxdWlyZSgnLi4vc3R5bGVzL3NsaWRlci5jc3MnKVxuXG52YXIgREVGQVVMVF9JTlRFUlZBTCA9IDMwMDBcblxuZnVuY3Rpb24gU2xpZGVyIChkYXRhKSB7XG4gIHRoaXMuYXV0b1BsYXkgPSBmYWxzZSAgLy8gZGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cbiAgdGhpcy5pbnRlcnZhbCA9IERFRkFVTFRfSU5URVJWQUxcbiAgdGhpcy5kaXJlY3Rpb24gPSAncm93JyAvLyAnY29sdW1uJyBpcyBub3QgdGVtcG9yYXJpbHkgc3VwcG9ydGVkLlxuICB0aGlzLmNoaWxkcmVuID0gW11cbiAgdGhpcy5pc1BhZ2VTaG93ID0gdHJ1ZVxuICB0aGlzLmlzRG9tUmVuZGVyaW5nID0gdHJ1ZVxuXG4gIC8vIGJpbmQgZXZlbnQgJ3BhZ2VzaG93JyBhbmQgJ3BhZ2VoaWRlJyBvbiB3aW5kb3cuXG4gIHRoaXMuX2lkbGVXaGVuUGFnZURpc2FwcGVhcigpXG4gIC8vIGJpbmQgZXZlbnQgJ3JlbmRlckJlZ2luJyBhbmQgJ3JlbmRlckVuZCcgb24gd2luZG93LlxuICB0aGlzLl9pZGxlV2hlbkRvbVJlbmRlcmluZygpXG5cbiAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSlcbn1cblxuU2xpZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSlcblxuU2xpZGVyLnByb3RvdHlwZS5faWRsZVdoZW5QYWdlRGlzYXBwZWFyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5pc1BhZ2VTaG93ID0gdHJ1ZVxuICAgIF90aGlzLmF1dG9QbGF5ICYmICFfdGhpcy5pc0RvbVJlbmRlcmluZyAmJiBfdGhpcy5wbGF5KClcbiAgfSlcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmlzUGFnZVNob3cgPSBmYWxzZVxuICAgIF90aGlzLnN0b3AoKVxuICB9KVxufVxuXG5TbGlkZXIucHJvdG90eXBlLl9pZGxlV2hlbkRvbVJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpc1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVuZGVyZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmlzRG9tUmVuZGVyaW5nID0gZmFsc2VcbiAgICBfdGhpcy5hdXRvUGxheSAmJiBfdGhpcy5pc1BhZ2VTaG93ICYmIF90aGlzLnBsYXkoKVxuICB9KVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVuZGVyYmVnaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuaXNEb21SZW5kZXJpbmcgPSB0cnVlXG4gICAgX3RoaXMuc3RvcCgpXG4gIH0pXG59XG5cblNsaWRlci5wcm90b3R5cGUuYXR0ciA9IHtcbiAgaW50ZXJ2YWw6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmludGVydmFsID0gcGFyc2VJbnQodmFsKSB8fCBERUZBVUxUX0lOVEVSVkFMXG4gICAgaWYgKHRoaXMuY2Fycm91c2VsKSB7XG4gICAgICB0aGlzLmNhcnJvdXNlbC5wbGF5SW50ZXJ2YWwgPSB0aGlzLmludGVydmFsXG4gICAgfVxuICB9LFxuXG4gIHBsYXlzdGF0dXM6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnBsYXlzdGF0dXMgPSB2YWwgJiYgdmFsICE9PSAnZmFsc2UnID8gdHJ1ZSA6IGZhbHNlXG4gICAgdGhpcy5hdXRvUGxheSA9IHRoaXMucGxheXN0YXR1c1xuICAgIGlmICh0aGlzLmNhcnJvdXNlbCkge1xuICAgICAgaWYgKHRoaXMucGxheXN0YXR1cykge1xuICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gc3VwcG9ydCBwbGF5c3RhdHVzJyBhbGlhcyBhdXRvLXBsYXkgZm9yIGNvbXBhdGliaWxpdHlcbiAgYXV0b1BsYXk6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmF0dHIucGxheXN0YXR1cy5jYWxsKHRoaXMsIHZhbClcbiAgfVxufVxuXG5TbGlkZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBub2RlLmNsYXNzTGlzdC5hZGQoJ3NsaWRlcicpXG4gIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnXG4gIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xuICByZXR1cm4gbm9kZVxufVxuXG5TbGlkZXIucHJvdG90eXBlLl9kb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpc1xuICBfdGhpcy5jcmVhdGVDaGlsZHJlbigpXG4gIF90aGlzLm9uQXBwZW5kKClcbn1cblxuU2xpZGVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNoaWxkLmRhdGEucmVmID09PSBjaGlsZHJlbltpXS5yZWYpIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fZG9SZW5kZXIoKVxufVxuXG5TbGlkZXIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChjaGlsZCwgYmVmb3JlKSB7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICAvLyB2YXIgY2hpbGRJbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihiZWZvcmUuZGF0YSlcbiAgdmFyIGNoaWxkSW5kZXggPSAtMVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChjaGlsZHJlbltpXS5yZWYgPT09IGJlZm9yZS5kYXRhLnJlZikge1xuICAgICAgY2hpbGRJbmRleCA9IGlcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZC5kYXRhKVxuXG4gIHRoaXMuX2RvUmVuZGVyKClcbiAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cbiAgfVxufVxuXG5TbGlkZXIucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5kYXRhLmNoaWxkcmVuIHx8ICh0aGlzLmRhdGEuY2hpbGRyZW4gPSBbXSlcbiAgY2hpbGRyZW4ucHVzaChkYXRhKVxuICB0aGlzLl9kb1JlbmRlcigpXG4gIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdXG4gIH1cbn1cblxuU2xpZGVyLnByb3RvdHlwZS5jcmVhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG5cbiAgLy8gcmVjcmVhdGUgc2xpZGVyIGNvbnRhaW5lci5cbiAgaWYgKHRoaXMuc2xpZGVyQ29udGFpbmVyKSB7XG4gICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMuc2xpZGVyQ29udGFpbmVyKVxuICB9XG4gIGlmICh0aGlzLmluZGljYXRvcikge1xuICAgIHRoaXMuaW5kaWNhdG9yLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmluZGljYXRvci5ub2RlKVxuICB9XG4gIHRoaXMuY2hpbGRyZW4gPSBbXVxuXG4gIHZhciBzbGlkZXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpXG4gIHNsaWRlckNvbnRhaW5lci5zdHlsZS5saXN0U3R5bGUgPSAnbm9uZSdcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHNsaWRlckNvbnRhaW5lcilcbiAgdGhpcy5zbGlkZXJDb250YWluZXIgPSBzbGlkZXJDb250YWluZXJcblxuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgdmFyIHNjYWxlID0gdGhpcy5kYXRhLnNjYWxlXG4gIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICB2YXIgaW5kaWNhdG9yRGF0YSwgd2lkdGgsIGhlaWdodFxuICB2YXIgY2hpbGRXaWR0aCA9IDBcbiAgdmFyIGNoaWxkSGVpZ2h0ID0gMFxuXG4gIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGRcbiAgICAgIGNoaWxkcmVuW2ldLnNjYWxlID0gdGhpcy5kYXRhLnNjYWxlXG4gICAgICBjaGlsZHJlbltpXS5pbnN0YW5jZUlkID0gdGhpcy5kYXRhLmluc3RhbmNlSWRcbiAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAnaW5kaWNhdG9yJykge1xuICAgICAgICBpbmRpY2F0b3JEYXRhID0gZXh0ZW5kKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgIGFtb3VudDogY2hpbGRyZW4ubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBjb21wb25lbnRNYW5hZ2VyLmNyZWF0ZUVsZW1lbnQoY2hpbGRyZW5baV0sICdsaScpXG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZClcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcbiAgICAgICAgd2lkdGggPSBjaGlsZC5kYXRhLnN0eWxlLndpZHRoIHx8IDBcbiAgICAgICAgaGVpZ2h0ID0gY2hpbGQuZGF0YS5zdHlsZS5oZWlnaHQgfHwgMFxuICAgICAgICB3aWR0aCA+IGNoaWxkV2lkdGggJiYgKGNoaWxkV2lkdGggPSB3aWR0aClcbiAgICAgICAgaGVpZ2h0ID4gY2hpbGRIZWlnaHQgJiYgKGNoaWxkSGVpZ2h0ID0gaGVpZ2h0KVxuICAgICAgICBjaGlsZC5wYXJlbnRSZWYgPSB0aGlzLmRhdGEucmVmXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFwcGVuZCBpbmRpY2F0b3JcbiAgICBpZiAoaW5kaWNhdG9yRGF0YSkge1xuICAgICAgaW5kaWNhdG9yRGF0YS5leHRyYS53aWR0aCA9IHRoaXMuZGF0YS5zdHlsZS53aWR0aCB8fCBjaGlsZFdpZHRoXG4gICAgICBpbmRpY2F0b3JEYXRhLmV4dHJhLmhlaWdodCA9IHRoaXMuZGF0YS5zdHlsZS5oZWlnaHQgfHwgY2hpbGRIZWlnaHRcbiAgICAgIHRoaXMuaW5kaWNhdG9yID0gY29tcG9uZW50TWFuYWdlci5jcmVhdGVFbGVtZW50KGluZGljYXRvckRhdGEpXG4gICAgICB0aGlzLmluZGljYXRvci5wYXJlbnRSZWYgPSB0aGlzLmRhdGEucmVmXG4gICAgICB0aGlzLmluZGljYXRvci5zbGlkZXIgPSB0aGlzXG4gICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5pbmRpY2F0b3Iubm9kZSlcbiAgICB9XG5cbiAgICBzbGlkZXJDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2NhbGUgKiB0aGlzLmRhdGEuc3R5bGUuaGVpZ2h0ICsgJ3B4J1xuICAgIHNsaWRlckNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudClcbiAgfVxufVxuXG5TbGlkZXIucHJvdG90eXBlLm9uQXBwZW5kID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jYXJyb3VzZWwpIHtcbiAgICB0aGlzLmNhcnJvdXNlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9nZXRTbGlkZXJDaGFuZ2VIYW5kbGVyKCkpXG4gICAgdGhpcy5jYXJyb3VzZWwuc3RvcCgpXG4gICAgdGhpcy5jYXJyb3VzZWwgPSBudWxsXG4gIH1cbiAgdGhpcy5jYXJyb3VzZWwgPSBuZXcgbGliLmNhcnJvdXNlbCh0aGlzLnNsaWRlckNvbnRhaW5lciwge1xuICAgIGF1dG9wbGF5OiB0aGlzLmF1dG9QbGF5LFxuICAgIHVzZUdlc3R1cmU6IHRydWVcbiAgfSlcblxuICB0aGlzLmNhcnJvdXNlbC5wbGF5SW50ZXJ2YWwgPSB0aGlzLmludGVydmFsXG4gIHRoaXMuY2Fycm91c2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2dldFNsaWRlckNoYW5nZUhhbmRsZXIoKSlcbiAgdGhpcy5jdXJyZW50SW5kZXggPSAwXG5cbiAgLy8gcHJlbG9hZCBhbGwgaW1hZ2VzIGZvciBzbGlkZXJcbiAgLy8gYmVjYXVzZTpcbiAgLy8gMS4gbGliLWltZyBkb2Vzbid0IGxpc3RlbiB0byBldmVudCB0cmFuc2l0aW9uZW5kXG4gIC8vIDIuIGV2ZW4gaWYgd2UgZmlyZSBsYXp5IGxvYWQgaW4gc2xpZGVyJ3MgY2hhbmdlIGV2ZW50IGhhbmRsZXIsXG4gIC8vICAgIHRoZSBuZXh0IGltYWdlIHN0aWxsIHdvbid0IGJlIHByZWxvYWRlZCB1dGlsbCB0aGUgbW9tZW50IGl0XG4gIC8vICAgIHNsaWRlcyBpbnRvIHRoZSB2aWV3LCB3aGljaCBpcyB0b28gbGF0ZS5cbiAgaWYgKHRoaXMucHJlbG9hZEltZ3NUaW1lcikge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnByZWxvYWRJbWdzVGltZXIpXG4gIH1cbiAgLy8gVGhlIHRpbWUganVzdCBiZWZvcmUgdGhlIHNlY29uZCBzbGlkZSBhcHBlYXIgYW5kIGVub3VnaFxuICAvLyBmb3IgYWxsIGNoaWxkIGVsZW1lbnRzIHRvIGFwcGVuZCBpcyBvay5cbiAgdmFyIHByZWxvYWRUaW1lID0gMC44XG4gIHRoaXMucHJlbG9hZEltZ3NUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbWdzID0gdGhpcy5jYXJyb3VzZWwuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcud2VleC1pbWcnKVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW1ncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBpbWcgPSBpbWdzW2ldXG4gICAgICB2YXIgaUxhenlTcmMgPSBpbWcuZ2V0QXR0cmlidXRlKCdpLWxhenktc3JjJylcbiAgICAgIHZhciBpbWdTcmMgPSBpbWcuZ2V0QXR0cmlidXRlKCdpbWctc3JjJylcbiAgICAgIGlmIChpTGF6eVNyYykge1xuICAgICAgICBpbWcuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgaUxhenlTcmMgKyAnKSdcbiAgICAgIH0gZWxzZSBpZiAoaW1nU3JjKSB7XG4gICAgICAgIGltZy5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKCcgKyBpbWdTcmMgKyAnKSdcbiAgICAgIH1cbiAgICAgIGltZy5yZW1vdmVBdHRyaWJ1dGUoJ2ktbGF6eS1zcmMnKVxuICAgICAgaW1nLnJlbW92ZUF0dHJpYnV0ZSgnaW1nLXNyYycpXG4gICAgfVxuICB9LmJpbmQodGhpcyksIHByZWxvYWRUaW1lICogMTAwMClcblxuICAvLyBhdm9pZCBwYWdlIHNjcm9sbCB3aGVuIHBhbm5pbmdcbiAgdmFyIHBhbm5pbmcgPSBmYWxzZVxuICB0aGlzLmNhcnJvdXNlbC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUuaXNWZXJ0aWNhbCkge1xuICAgICAgcGFubmluZyA9IHRydWVcbiAgICB9XG4gIH0pXG4gIHRoaXMuY2Fycm91c2VsLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFuZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUuaXNWZXJ0aWNhbCkge1xuICAgICAgcGFubmluZyA9IGZhbHNlXG4gICAgfVxuICB9KVxuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHBhbm5pbmcpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0uYmluZCh0aGlzKSlcblxufVxuXG5TbGlkZXIucHJvdG90eXBlLl91cGRhdGVJbmRpY2F0b3JzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmluZGljYXRvciAmJiB0aGlzLmluZGljYXRvci5zZXRJbmRleCh0aGlzLmN1cnJlbnRJbmRleClcbn1cblxuU2xpZGVyLnByb3RvdHlwZS5fZ2V0U2xpZGVyQ2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gIGlmICghdGhpcy5zbGlkZXJDaGFuZ2VIYW5kbGVyKSB7XG4gICAgdGhpcy5zbGlkZXJDaGFuZ2VIYW5kbGVyID0gKGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNhcnJvdXNlbC5pdGVtcy5pbmRleFxuICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBpbmRleFxuXG4gICAgICAvLyB1cGRhdGVJbmRpY2F0b3JzXG4gICAgICB0aGlzLl91cGRhdGVJbmRpY2F0b3JzKClcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdjaGFuZ2UnLCB7IGluZGV4OiBpbmRleCB9KVxuICAgIH0pLmJpbmQodGhpcylcbiAgfVxuICByZXR1cm4gdGhpcy5zbGlkZXJDaGFuZ2VIYW5kbGVyXG59XG5cblNsaWRlci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYXJyb3VzZWwucGxheSgpXG59XG5cblNsaWRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYXJyb3VzZWwuc3RvcCgpXG59XG5cblNsaWRlci5wcm90b3R5cGUuc2xpZGVUbyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB2YXIgb2Zmc2V0ID0gaW5kZXggLSB0aGlzLmN1cnJlbnRJbmRleFxuICB0aGlzLmNhcnJvdXNlbC5pdGVtcy5zbGlkZShvZmZzZXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3NsaWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgJiYgKHdpbmRvdyA9IHtjdHJsOiB7fSwgbGliOiB7fX0pOyF3aW5kb3cuY3RybCAmJiAod2luZG93LmN0cmwgPSB7fSk7IXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSk7cmVxdWlyZSgnYW5pbWF0aW9uanMnKTtyZXF1aXJlKCdjdWJpY2JlemllcicpO3JlcXVpcmUoJ2dlc3R1cmVqcycpOyFmdW5jdGlvbigpe3ZhciBhPVwiW2RhdGEtY3RybC1uYW1lPWNhcnJvdXNlbF17cG9zaXRpb246cmVsYXRpdmU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWigxcHgpOy1tcy10cmFuc2Zvcm06dHJhbnNsYXRlWigxcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDFweCl9XCIsYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7aWYoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKGIpLGIuc3R5bGVTaGVldCliLnN0eWxlU2hlZXQuZGlzYWJsZWR8fChiLnN0eWxlU2hlZXQuY3NzVGV4dD1hKTtlbHNlIHRyeXtiLmlubmVySFRNTD1hfWNhdGNoKGMpe2IuaW5uZXJUZXh0PWF9fSgpOyFmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXt2YXIgYixjPXt4OjAseTowfSxkPWdldENvbXB1dGVkU3R5bGUoYSlbbCtcIlRyYW5zZm9ybVwiXTtyZXR1cm5cIm5vbmVcIiE9PWQmJihiPWQubWF0Y2goL15tYXRyaXgzZFxcKCg/OlstXFxkLl0rLFxccyopezEyfShbLVxcZC5dKyksXFxzKihbLVxcZC5dKykoPzosXFxzKlstXFxkLl0rKXsyfVxcKS8pfHxkLm1hdGNoKC9ebWF0cml4XFwoKD86Wy1cXGQuXSssXFxzKil7NH0oWy1cXGQuXSspLFxccyooWy1cXGQuXSspXFwpJC8pKSYmKGMueD1wYXJzZUZsb2F0KGJbMV0pfHwwLGMueT1wYXJzZUZsb2F0KGJbMl0pfHwwKSxjfWZ1bmN0aW9uIGUoYSxiKXtyZXR1cm4gYT1wYXJzZUZsb2F0KGEpLGI9cGFyc2VGbG9hdChiKSwwIT1hJiYoYSs9XCJweFwiKSwwIT1iJiYoYis9XCJweFwiKSxuP1widHJhbnNsYXRlM2QoXCIrYStcIiwgXCIrYitcIiwgMClcIjpcInRyYW5zbGF0ZShcIithK1wiLCBcIitiK1wiKVwifWZ1bmN0aW9uIGYoYSl7cmV0dXJuIG8uY2FsbChhKX1mdW5jdGlvbiBnKGEsYyl7ZnVuY3Rpb24gZyhhLGIpe3ZhciBjPWguY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpO2lmKGMuaW5pdEV2ZW50KGEsITEsITEpLGIpZm9yKHZhciBkIGluIGIpY1tkXT1iW2RdO24uZGlzcGF0Y2hFdmVudChjKX1mdW5jdGlvbiBpKGEpe2Zvcig7MD5hOylhKz1yO2Zvcig7YT49cjspYS09cjtyZXR1cm4gYX1mdW5jdGlvbiBqKGEpe2lmKDAhPT1yKXt2YXIgYixjLGQ9cS5nZXQoYSk7cj4xJiYoYj1xLmdldChhLTEpLGM9Mj09PXI/cS5nZXRDbG9uZWQoYSsxKTpxLmdldChhKzEpLGQuc3R5bGUubGVmdD0tbytcInB4XCIsYi5zdHlsZS5sZWZ0PS1vLXMrXCJweFwiLGMuc3R5bGUubGVmdD0tbytzK1wicHhcIiksdD1kLmluZGV4LGcoXCJjaGFuZ2VcIix7cHJldkl0ZW06YixjdXJJdGVtOmQsbmV4dEl0ZW06Y30pfX12YXIgaz10aGlzLG09RGF0ZS5ub3coKStcIi1cIisgKytwLG49ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOzEhPT1hcmd1bWVudHMubGVuZ3RofHxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEhUTUxFbGVtZW50fHwoYz1hcmd1bWVudHNbMF0sYT1udWxsKSxhfHwoYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIiksbi5hcHBlbmRDaGlsZChhKSksYz1jfHx7fSxhLnNldEF0dHJpYnV0ZShcImRhdGEtY3RybC1uYW1lXCIsXCJjYXJyb3VzZWxcIiksYS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWN0cmwtaWRcIixtKSxhLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIixhLnN0eWxlW2wrXCJUcmFuc2Zvcm1cIl09ZSgwLDApO3ZhciBvPTAscT17fSxyPTAscz1jLnN0ZXB8fGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsdD0wO3EuYWRkPWZ1bmN0aW9uKGIpe3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtyZXR1cm4gYy5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGMuc3R5bGVbXCJmbG9hdFwiXT1cImxlZnRcIixjLmluZGV4PXIsXCJzdHJpbmdcIj09dHlwZW9mIGI/Yy5pbm5lckhUTUw9YjpiIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJmMuYXBwZW5kQ2hpbGQoYiksYS5hcHBlbmRDaGlsZChjKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocSxyK1wiXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBjfX0pLHIrKyxjfSxxLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gcVtpKGEpXX0scS5nZXRDbG9uZWQ9ZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGIsZCl7dmFyIGU9YS5fbGlzdGVuZXJzO2lmKGUpe2IuX2xpc3RlbmVycz1lO2Zvcih2YXIgZiBpbiBlKWIuYWRkRXZlbnRMaXN0ZW5lcihmLGVbZl0pfWlmKGQmJmEuY2hpbGRyZW4mJmEuY2hpbGRyZW4ubGVuZ3RoKWZvcih2YXIgZz0wLGg9YS5jaGlsZHJlbi5sZW5ndGg7aD5nO2crKyljKGEuY2hpbGRyZW5bZ10sYi5jaGlsZHJlbltnXSxkKX12YXIgYj1pKGIpLGQ9YS5xdWVyeVNlbGVjdG9yKCdbY2xvbmVkPVwiY2xvbmVkLScrYisnXCJdJyksZT1xW2JdO3JldHVybiBkfHwoZD1lLmNsb25lTm9kZSghMCksYyhlLGQsITApLGEuYXBwZW5kQ2hpbGQoZCksZC5zZXRBdHRyaWJ1dGUoXCJjbG9uZWRcIixcImNsb25lZC1cIitiKSxkLmluZGV4PWIpLGR9LHEuc2xpZGU9ZnVuY3Rpb24oYyl7aWYoMCE9PXIpezE9PT1yJiYoYz0wKTt2YXIgZj1kKGEpLngsZz1vK3MqLWMsaD1nLWY7aWYoMCE9PWgpe25ldyBiLmFuaW1hdGlvbig0MDAsYi5jdWJpY2Jlemllci5lYXNlLGZ1bmN0aW9uKGIsYyl7YS5zdHlsZVtsK1wiVHJhbnNmb3JtXCJdPWUoZitoKmMsMCl9KS5wbGF5KCkudGhlbihmdW5jdGlvbigpe289ZyxhLnN0eWxlW2wrXCJUcmFuc2Zvcm1cIl09ZShnLDApLGMmJmoodCtjKX0pfX19LHEubmV4dD1mdW5jdGlvbigpe3Euc2xpZGUoMSl9LHEucHJldj1mdW5jdGlvbigpe3Euc2xpZGUoLTEpfSxmKGEucXVlcnlTZWxlY3RvckFsbChcImxpXCIpKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2Euc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLGEuc3R5bGUudG9wPVwiMFwiLGEuc3R5bGUubGVmdD1yKnMrXCJweFwiLGEuc3R5bGVbXCJmbG9hdFwiXT1cImxlZnRcIixhLmluZGV4PXIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHEscitcIlwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX19KSxyKyt9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcIml0ZW1zXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBxfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShxLFwibGVuZ3RoXCIse2dldDpmdW5jdGlvbigpe3JldHVybiByfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShxLFwiaW5kZXhcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHEsXCJzdGVwXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBzfSxzZXQ6ZnVuY3Rpb24oYSl7cz1hfX0pO3ZhciB1PSExLHY9ITEsdz0hMTt0aGlzLnBsYXk9ZnVuY3Rpb24oKXtyZXR1cm4gdT92b2lkKHZ8fCh2PXNldFRpbWVvdXQoZnVuY3Rpb24oKXt3PSEwLHEubmV4dCgpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXt3PSExfSw1MDApLHY9c2V0VGltZW91dChhcmd1bWVudHMuY2FsbGVlLDQwMCt6KX0sNDAwK3opKSk6KHU9ITAsaigwKSl9LHRoaXMuc3RvcD1mdW5jdGlvbigpe3YmJihjbGVhclRpbWVvdXQodiksc2V0VGltZW91dChmdW5jdGlvbigpe3Y9ITF9LDUwMCkpfTt2YXIgeD0hMSx5PSExO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiYXV0b3BsYXlcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHh9LHNldDpmdW5jdGlvbihhKXt4PSEhYSx5JiYoY2xlYXJUaW1lb3V0KHkpLHk9ITEpLHg/eT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ay5wbGF5KCl9LDJlMyk6ay5zdG9wKCl9fSksdGhpcy5hdXRvcGxheT0hIWMuYXV0b3BsYXk7dmFyIHo9MTUwMDtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInBsYXlJbnRlcnZhbFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gen0sc2V0OmZ1bmN0aW9uKGEpe3o9YX19KSx0aGlzLnBsYXlJbnRlcnZhbD0hIWMucGxheUludGVydmFsfHwxNTAwLGMudXNlR2VzdHVyZSl7dmFyIEEsQj0hMTthLmFkZEV2ZW50TGlzdGVuZXIoXCJwYW5zdGFydFwiLGZ1bmN0aW9uKGEpe2EuaXNWZXJ0aWNhbHx8QiYmd3x8KGEucHJldmVudERlZmF1bHQoKSxhLnN0b3BQcm9wYWdhdGlvbigpLHgmJmsuc3RvcCgpLEE9MCxCPSEwKX0pLGEuYWRkRXZlbnRMaXN0ZW5lcihcInBhbm1vdmVcIixmdW5jdGlvbihiKXshYi5pc1ZlcnRpY2FsJiZCJiYoYi5wcmV2ZW50RGVmYXVsdCgpLGIuc3RvcFByb3BhZ2F0aW9uKCksQT1iLmRpc3BsYWNlbWVudFgsYS5zdHlsZVtsK1wiVHJhbnNmb3JtXCJdPWUobytBLDApKX0pLGEuYWRkRXZlbnRMaXN0ZW5lcihcInBhbmVuZFwiLGZ1bmN0aW9uKGEpeyFhLmlzVmVydGljYWwmJkImJihhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSxCPSExLGEuaXNmbGljaz8wPkE/cS5uZXh0KCk6cS5wcmV2KCk6TWF0aC5hYnMoQSk8cy8yP3Euc2xpZGUoMCk6cS5zbGlkZSgwPkE/MTotMSkseCYmc2V0VGltZW91dChmdW5jdGlvbigpe2sucGxheSgpfSwyZTMpKX0sITEpLGEuYWRkRXZlbnRMaXN0ZW5lcihcInN3aXBlXCIsZnVuY3Rpb24oYSl7YS5pc1ZlcnRpY2FsfHwoYS5wcmV2ZW50RGVmYXVsdCgpLGEuc3RvcFByb3BhZ2F0aW9uKCkpfSl9dGhpcy5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGEsYil7dGhpcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoYSxiLCExKX0sdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGEsYil7dGhpcy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxiLCExKX0sdGhpcy5yb290PW4sdGhpcy5lbGVtZW50PWF9dmFyIGg9YS5kb2N1bWVudCxpPWEubmF2aWdhdG9yLnVzZXJBZ2VudCxqPSEhaS5tYXRjaCgvRmlyZWZveC9pKSxrPSEhaS5tYXRjaCgvSUVNb2JpbGUvaSksbD1qP1wiTW96XCI6az9cIm1zXCI6XCJ3ZWJraXRcIixtPWs/XCJNU0NTU01hdHJpeFwiOlwiV2ViS2l0Q1NTTWF0cml4XCIsbj0hIWp8fG0gaW4gYSYmXCJtMTFcImluIG5ldyBhW21dLG89QXJyYXkucHJvdG90eXBlLnNsaWNlLHA9MDtiLmNhcnJvdXNlbD1nfSh3aW5kb3csd2luZG93LmxpYix3aW5kb3cuY3RybHx8KHdpbmRvdy5jdHJsPXt9KSk7O21vZHVsZS5leHBvcnRzID0gd2luZG93LmxpYlsnY2Fycm91c2VsJ107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9+L2NhcnJvdXNlbC9idWlsZC9jYXJyb3VzZWwuY29tbW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSAmJiAod2luZG93ID0ge2N0cmw6IHt9LCBsaWI6IHt9fSk7IXdpbmRvdy5jdHJsICYmICh3aW5kb3cuY3RybCA9IHt9KTshd2luZG93LmxpYiAmJiAod2luZG93LmxpYiA9IHt9KTshZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBzZXRUaW1lb3V0KGEsbCl9ZnVuY3Rpb24gZChhKXtjbGVhclRpbWVvdXQoYSl9ZnVuY3Rpb24gZSgpe3ZhciBhPXt9LGI9bmV3IG0oZnVuY3Rpb24oYixjKXthLnJlc29sdmU9YixhLnJlamVjdD1jfSk7cmV0dXJuIGEucHJvbWlzZT1iLGF9ZnVuY3Rpb24gZihhLGIpe3JldHVybltcInRoZW5cIixcImNhdGNoXCJdLmZvckVhY2goZnVuY3Rpb24oYyl7YltjXT1mdW5jdGlvbigpe3JldHVybiBhW2NdLmFwcGx5KGEsYXJndW1lbnRzKX19KSxifWZ1bmN0aW9uIGcoYil7dmFyIGMsZCxoPSExO3RoaXMucmVxdWVzdD1mdW5jdGlvbigpe2g9ITE7dmFyIGc9YXJndW1lbnRzO3JldHVybiBjPWUoKSxmKGMucHJvbWlzZSx0aGlzKSxkPW4oZnVuY3Rpb24oKXtofHxjJiZjLnJlc29sdmUoYi5hcHBseShhLGcpKX0pLHRoaXN9LHRoaXMuY2FuY2VsPWZ1bmN0aW9uKCl7cmV0dXJuIGQmJihoPSEwLG8oZCksYyYmYy5yZWplY3QoXCJDQU5DRUxcIikpLHRoaXN9LHRoaXMuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGcoYil9fWZ1bmN0aW9uIGgoYSxiKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiYoYj17MDpifSk7Zm9yKHZhciBjPWEvbCxkPTEvYyxlPVtdLGY9T2JqZWN0LmtleXMoYikubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBwYXJzZUludChhKX0pLGg9MDtjPmg7aCsrKXt2YXIgaT1mWzBdLGo9ZCpoO2lmKG51bGwhPWkmJjEwMCpqPj1pKXt2YXIgaz1iW1wiXCIraV07ayBpbnN0YW5jZW9mIGd8fChrPW5ldyBnKGspKSxlLnB1c2goayksZi5zaGlmdCgpfWVsc2UgZS5sZW5ndGgmJmUucHVzaChlW2UubGVuZ3RoLTFdLmNsb25lKCkpfXJldHVybiBlfWZ1bmN0aW9uIGkoYSl7dmFyIGM7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGF8fGEgaW5zdGFuY2VvZiBBcnJheT9iLmN1YmljYmV6aWVyP1wic3RyaW5nXCI9PXR5cGVvZiBhP2IuY3ViaWNiZXppZXJbYV0mJihjPWIuY3ViaWNiZXppZXJbYV0pOmEgaW5zdGFuY2VvZiBBcnJheSYmND09PWEubGVuZ3RoJiYoYz1iLmN1YmljYmV6aWVyLmFwcGx5KGIuY3ViaWNiZXppZXIsYSkpOmNvbnNvbGUuZXJyb3IoXCJyZXF1aXJlIGxpYi5jdWJpY2JlemllclwiKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBhJiYoYz1hKSxjfWZ1bmN0aW9uIGooYSxiLGMpe3ZhciBkLGc9aChhLGMpLGo9MS8oYS9sKSxrPTAsbT1pKGIpO2lmKCFtKXRocm93IG5ldyBFcnJvcihcInVuZXhjZXB0IHRpbWluZyBmdW5jdGlvblwiKTt2YXIgbj0hMTt0aGlzLnBsYXk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7dmFyIGM9aiooaysxKS50b0ZpeGVkKDEwKSxlPWdba107ZS5yZXF1ZXN0KGMudG9GaXhlZCgxMCksYihjKS50b0ZpeGVkKDEwKSkudGhlbihmdW5jdGlvbigpe24mJihrPT09Zy5sZW5ndGgtMT8obj0hMSxkJiZkLnJlc29sdmUoXCJGSU5JU0hcIiksZD1udWxsKTooaysrLGEoKSkpfSxmdW5jdGlvbigpe30pfWlmKCFuKXJldHVybiBuPSEwLGR8fChkPWUoKSxmKGQucHJvbWlzZSx0aGlzKSksYSgpLHRoaXN9LHRoaXMuc3RvcD1mdW5jdGlvbigpe3JldHVybiBuPyhuPSExLGdba10mJmdba10uY2FuY2VsKCksdGhpcyk6dm9pZCAwfX12YXIgaz02MCxsPTFlMy9rLG09YS5Qcm9taXNlfHxiLnByb21pc2UmJmIucHJvbWlzZS5FUzZQcm9taXNlLG49d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8d2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lfHxjLG89d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZXx8d2luZG93LndlYmtpdENhbmNlbEFuaW1hdGlvbkZyYW1lfHx3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWV8fGQ7KG49PT1jfHxvPT09ZCkmJihuPWMsbz1kKSxiLmFuaW1hdGlvbj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBqKGEsYixjKX0sYi5hbmltYXRpb24uZnJhbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBnKGEpfSxiLmFuaW1hdGlvbi5yZXF1ZXN0RnJhbWU9ZnVuY3Rpb24oYSl7dmFyIGI9bmV3IGcoYSk7cmV0dXJuIGIucmVxdWVzdCgpfX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSk7O21vZHVsZS5leHBvcnRzID0gd2luZG93LmxpYlsnYW5pbWF0aW9uJ107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9+L2FuaW1hdGlvbmpzL2J1aWxkL2FuaW1hdGlvbi5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpICYmICh3aW5kb3cgPSB7Y3RybDoge30sIGxpYjoge319KTshd2luZG93LmN0cmwgJiYgKHdpbmRvdy5jdHJsID0ge30pOyF3aW5kb3cubGliICYmICh3aW5kb3cubGliID0ge30pOyFmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGMsZCl7ZnVuY3Rpb24gZShhKXtyZXR1cm4oMyprKmErMipsKSphK219ZnVuY3Rpb24gZihhKXtyZXR1cm4oKGsqYStsKSphK20pKmF9ZnVuY3Rpb24gZyhhKXtyZXR1cm4oKG4qYStvKSphK3ApKmF9ZnVuY3Rpb24gaChhKXtmb3IodmFyIGIsYyxkPWEsZz0wOzg+ZztnKyspe2lmKGM9ZihkKS1hLE1hdGguYWJzKGMpPGopcmV0dXJuIGQ7aWYoYj1lKGQpLE1hdGguYWJzKGIpPGopYnJlYWs7ZC09Yy9ifXZhciBoPTEsaT0wO2ZvcihkPWE7aD5pOyl7aWYoYz1mKGQpLWEsTWF0aC5hYnMoYyk8ailyZXR1cm4gZDtjPjA/aD1kOmk9ZCxkPShoK2kpLzJ9cmV0dXJuIGR9ZnVuY3Rpb24gaShhKXtyZXR1cm4gZyhoKGEpKX12YXIgaj0xZS02LGs9MyphLTMqYysxLGw9MypjLTYqYSxtPTMqYSxuPTMqYi0zKmQrMSxvPTMqZC02KmIscD0zKmI7cmV0dXJuIGl9Yi5jdWJpY2Jlemllcj1jLGIuY3ViaWNiZXppZXIubGluZWFyPWMoMCwwLDEsMSksYi5jdWJpY2Jlemllci5lYXNlPWMoLjI1LC4xLC4yNSwxKSxiLmN1YmljYmV6aWVyLmVhc2VJbj1jKC40MiwwLDEsMSksYi5jdWJpY2Jlemllci5lYXNlT3V0PWMoMCwwLC41OCwxKSxiLmN1YmljYmV6aWVyLmVhc2VJbk91dD1jKC40MiwwLC41OCwxKX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSk7O21vZHVsZS5leHBvcnRzID0gd2luZG93LmxpYlsnY3ViaWNiZXppZXInXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L34vY3ViaWNiZXppZXIvYnVpbGQvY3ViaWNiZXppZXIuY29tbW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSAmJiAod2luZG93ID0ge2N0cmw6IHt9LCBsaWI6IHt9fSk7IXdpbmRvdy5jdHJsICYmICh3aW5kb3cuY3RybCA9IHt9KTshd2luZG93LmxpYiAmJiAod2luZG93LmxpYiA9IHt9KTshZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihhLGIpe2Zvcih2YXIgYz1hO2M7KXtpZihjLmNvbnRhaW5zKGIpfHxjPT1iKXJldHVybiBjO2M9Yy5wYXJlbnROb2RlfXJldHVybiBudWxsfWZ1bmN0aW9uIGMoYSxiLGMpe3ZhciBkPWkuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpO2lmKGQuaW5pdEV2ZW50KGIsITAsITApLFwib2JqZWN0XCI9PXR5cGVvZiBjKWZvcih2YXIgZSBpbiBjKWRbZV09Y1tlXTthLmRpc3BhdGNoRXZlbnQoZCl9ZnVuY3Rpb24gZChhLGIsYyxkLGUsZixnLGgpe3ZhciBpPU1hdGguYXRhbjIoaC1mLGctZSktTWF0aC5hdGFuMihkLWIsYy1hKSxqPU1hdGguc3FydCgoTWF0aC5wb3coaC1mLDIpK01hdGgucG93KGctZSwyKSkvKE1hdGgucG93KGQtYiwyKStNYXRoLnBvdyhjLWEsMikpKSxrPVtlLWoqYSpNYXRoLmNvcyhpKStqKmIqTWF0aC5zaW4oaSksZi1qKmIqTWF0aC5jb3MoaSktaiphKk1hdGguc2luKGkpXTtyZXR1cm57cm90YXRlOmksc2NhbGU6aix0cmFuc2xhdGU6ayxtYXRyaXg6W1tqKk1hdGguY29zKGkpLC1qKk1hdGguc2luKGkpLGtbMF1dLFtqKk1hdGguc2luKGkpLGoqTWF0aC5jb3MoaSksa1sxXV0sWzAsMCwxXV19fWZ1bmN0aW9uIGUoYSl7MD09PU9iamVjdC5rZXlzKGwpLmxlbmd0aCYmKGouYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLGYsITEpLGouYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsZywhMSksai5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIixoLCExKSk7Zm9yKHZhciBkPTA7ZDxhLmNoYW5nZWRUb3VjaGVzLmxlbmd0aDtkKyspe3ZhciBlPWEuY2hhbmdlZFRvdWNoZXNbZF0saT17fTtmb3IodmFyIG0gaW4gZSlpW21dPWVbbV07dmFyIG49e3N0YXJ0VG91Y2g6aSxzdGFydFRpbWU6RGF0ZS5ub3coKSxzdGF0dXM6XCJ0YXBwaW5nXCIsZWxlbWVudDphLnNyY0VsZW1lbnR8fGEudGFyZ2V0LHByZXNzaW5nSGFuZGxlcjpzZXRUaW1lb3V0KGZ1bmN0aW9uKGIsZCl7cmV0dXJuIGZ1bmN0aW9uKCl7XCJ0YXBwaW5nXCI9PT1uLnN0YXR1cyYmKG4uc3RhdHVzPVwicHJlc3NpbmdcIixjKGIsXCJsb25ncHJlc3NcIix7dG91Y2g6ZCx0b3VjaGVzOmEudG91Y2hlcyxjaGFuZ2VkVG91Y2hlczphLmNoYW5nZWRUb3VjaGVzLHRvdWNoRXZlbnQ6YX0pKSxjbGVhclRpbWVvdXQobi5wcmVzc2luZ0hhbmRsZXIpLG4ucHJlc3NpbmdIYW5kbGVyPW51bGx9fShhLnNyY0VsZW1lbnR8fGEudGFyZ2V0LGEuY2hhbmdlZFRvdWNoZXNbZF0pLDUwMCl9O2xbZS5pZGVudGlmaWVyXT1ufWlmKDI9PU9iamVjdC5rZXlzKGwpLmxlbmd0aCl7dmFyIG89W107Zm9yKHZhciBtIGluIGwpby5wdXNoKGxbbV0uZWxlbWVudCk7YyhiKG9bMF0sb1sxXSksXCJkdWFsdG91Y2hzdGFydFwiLHt0b3VjaGVzOmsuY2FsbChhLnRvdWNoZXMpLHRvdWNoRXZlbnQ6YX0pfX1mdW5jdGlvbiBmKGEpe2Zvcih2YXIgZT0wO2U8YS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7ZSsrKXt2YXIgZj1hLmNoYW5nZWRUb3VjaGVzW2VdLGc9bFtmLmlkZW50aWZpZXJdO2lmKCFnKXJldHVybjtnLmxhc3RUb3VjaHx8KGcubGFzdFRvdWNoPWcuc3RhcnRUb3VjaCksZy5sYXN0VGltZXx8KGcubGFzdFRpbWU9Zy5zdGFydFRpbWUpLGcudmVsb2NpdHlYfHwoZy52ZWxvY2l0eVg9MCksZy52ZWxvY2l0eVl8fChnLnZlbG9jaXR5WT0wKSxnLmR1cmF0aW9ufHwoZy5kdXJhdGlvbj0wKTt2YXIgaD1EYXRlLm5vdygpLWcubGFzdFRpbWUsaT0oZi5jbGllbnRYLWcubGFzdFRvdWNoLmNsaWVudFgpL2gsaj0oZi5jbGllbnRZLWcubGFzdFRvdWNoLmNsaWVudFkpL2gsaz03MDtoPmsmJihoPWspLGcuZHVyYXRpb24raD5rJiYoZy5kdXJhdGlvbj1rLWgpLGcudmVsb2NpdHlYPShnLnZlbG9jaXR5WCpnLmR1cmF0aW9uK2kqaCkvKGcuZHVyYXRpb24raCksZy52ZWxvY2l0eVk9KGcudmVsb2NpdHlZKmcuZHVyYXRpb24raipoKS8oZy5kdXJhdGlvbitoKSxnLmR1cmF0aW9uKz1oLGcubGFzdFRvdWNoPXt9O2Zvcih2YXIgbSBpbiBmKWcubGFzdFRvdWNoW21dPWZbbV07Zy5sYXN0VGltZT1EYXRlLm5vdygpO3ZhciBuPWYuY2xpZW50WC1nLnN0YXJ0VG91Y2guY2xpZW50WCxvPWYuY2xpZW50WS1nLnN0YXJ0VG91Y2guY2xpZW50WSxwPU1hdGguc3FydChNYXRoLnBvdyhuLDIpK01hdGgucG93KG8sMikpOyhcInRhcHBpbmdcIj09PWcuc3RhdHVzfHxcInByZXNzaW5nXCI9PT1nLnN0YXR1cykmJnA+MTAmJihnLnN0YXR1cz1cInBhbm5pbmdcIixnLmlzVmVydGljYWw9IShNYXRoLmFicyhuKT5NYXRoLmFicyhvKSksYyhnLmVsZW1lbnQsXCJwYW5zdGFydFwiLHt0b3VjaDpmLHRvdWNoZXM6YS50b3VjaGVzLGNoYW5nZWRUb3VjaGVzOmEuY2hhbmdlZFRvdWNoZXMsdG91Y2hFdmVudDphLGlzVmVydGljYWw6Zy5pc1ZlcnRpY2FsfSksYyhnLmVsZW1lbnQsKGcuaXNWZXJ0aWNhbD9cInZlcnRpY2FsXCI6XCJob3Jpem9udGFsXCIpK1wicGFuc3RhcnRcIix7dG91Y2g6Zix0b3VjaEV2ZW50OmF9KSksXCJwYW5uaW5nXCI9PT1nLnN0YXR1cyYmKGcucGFuVGltZT1EYXRlLm5vdygpLGMoZy5lbGVtZW50LFwicGFubW92ZVwiLHtkaXNwbGFjZW1lbnRYOm4sZGlzcGxhY2VtZW50WTpvLHRvdWNoOmYsdG91Y2hlczphLnRvdWNoZXMsY2hhbmdlZFRvdWNoZXM6YS5jaGFuZ2VkVG91Y2hlcyx0b3VjaEV2ZW50OmEsaXNWZXJ0aWNhbDpnLmlzVmVydGljYWx9KSxnLmlzVmVydGljYWw/YyhnLmVsZW1lbnQsXCJ2ZXJ0aWNhbHBhbm1vdmVcIix7ZGlzcGxhY2VtZW50WTpvLHRvdWNoOmYsdG91Y2hFdmVudDphfSk6YyhnLmVsZW1lbnQsXCJob3Jpem9udGFscGFubW92ZVwiLHtkaXNwbGFjZW1lbnRYOm4sdG91Y2g6Zix0b3VjaEV2ZW50OmF9KSl9aWYoMj09T2JqZWN0LmtleXMobCkubGVuZ3RoKXtmb3IodmFyIHEscj1bXSxzPVtdLHQ9W10sZT0wO2U8YS50b3VjaGVzLmxlbmd0aDtlKyspe3ZhciBmPWEudG91Y2hlc1tlXSxnPWxbZi5pZGVudGlmaWVyXTtyLnB1c2goW2cuc3RhcnRUb3VjaC5jbGllbnRYLGcuc3RhcnRUb3VjaC5jbGllbnRZXSkscy5wdXNoKFtmLmNsaWVudFgsZi5jbGllbnRZXSl9Zm9yKHZhciBtIGluIGwpdC5wdXNoKGxbbV0uZWxlbWVudCk7cT1kKHJbMF1bMF0sclswXVsxXSxyWzFdWzBdLHJbMV1bMV0sc1swXVswXSxzWzBdWzFdLHNbMV1bMF0sc1sxXVsxXSksYyhiKHRbMF0sdFsxXSksXCJkdWFsdG91Y2hcIix7dHJhbnNmb3JtOnEsdG91Y2hlczphLnRvdWNoZXMsdG91Y2hFdmVudDphfSl9fWZ1bmN0aW9uIGcoYSl7aWYoMj09T2JqZWN0LmtleXMobCkubGVuZ3RoKXt2YXIgZD1bXTtmb3IodmFyIGUgaW4gbClkLnB1c2gobFtlXS5lbGVtZW50KTtjKGIoZFswXSxkWzFdKSxcImR1YWx0b3VjaGVuZFwiLHt0b3VjaGVzOmsuY2FsbChhLnRvdWNoZXMpLHRvdWNoRXZlbnQ6YX0pfWZvcih2YXIgaT0wO2k8YS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7aSsrKXt2YXIgbj1hLmNoYW5nZWRUb3VjaGVzW2ldLG89bi5pZGVudGlmaWVyLHA9bFtvXTtpZihwKXtpZihwLnByZXNzaW5nSGFuZGxlciYmKGNsZWFyVGltZW91dChwLnByZXNzaW5nSGFuZGxlcikscC5wcmVzc2luZ0hhbmRsZXI9bnVsbCksXCJ0YXBwaW5nXCI9PT1wLnN0YXR1cyYmKHAudGltZXN0YW1wPURhdGUubm93KCksYyhwLmVsZW1lbnQsXCJ0YXBcIix7dG91Y2g6bix0b3VjaEV2ZW50OmF9KSxtJiZwLnRpbWVzdGFtcC1tLnRpbWVzdGFtcDwzMDAmJmMocC5lbGVtZW50LFwiZG91YmxldGFwXCIse3RvdWNoOm4sdG91Y2hFdmVudDphfSksbT1wKSxcInBhbm5pbmdcIj09PXAuc3RhdHVzKXt2YXIgcT1EYXRlLm5vdygpLHI9cS1wLnN0YXJ0VGltZSxzPSgobi5jbGllbnRYLXAuc3RhcnRUb3VjaC5jbGllbnRYKS9yLChuLmNsaWVudFktcC5zdGFydFRvdWNoLmNsaWVudFkpL3Isbi5jbGllbnRYLXAuc3RhcnRUb3VjaC5jbGllbnRYKSx0PW4uY2xpZW50WS1wLnN0YXJ0VG91Y2guY2xpZW50WSx1PU1hdGguc3FydChwLnZlbG9jaXR5WSpwLnZlbG9jaXR5WStwLnZlbG9jaXR5WCpwLnZlbG9jaXR5WCksdj11Pi41JiZxLXAubGFzdFRpbWU8MTAwLHc9e2R1cmF0aW9uOnIsaXNmbGljazp2LHZlbG9jaXR5WDpwLnZlbG9jaXR5WCx2ZWxvY2l0eVk6cC52ZWxvY2l0eVksZGlzcGxhY2VtZW50WDpzLGRpc3BsYWNlbWVudFk6dCx0b3VjaDpuLHRvdWNoZXM6YS50b3VjaGVzLGNoYW5nZWRUb3VjaGVzOmEuY2hhbmdlZFRvdWNoZXMsdG91Y2hFdmVudDphLGlzVmVydGljYWw6cC5pc1ZlcnRpY2FsfTtjKHAuZWxlbWVudCxcInBhbmVuZFwiLHcpLHYmJihjKHAuZWxlbWVudCxcInN3aXBlXCIsdykscC5pc1ZlcnRpY2FsP2MocC5lbGVtZW50LFwidmVydGljYWxzd2lwZVwiLHcpOmMocC5lbGVtZW50LFwiaG9yaXpvbnRhbHN3aXBlXCIsdykpfVwicHJlc3NpbmdcIj09PXAuc3RhdHVzJiZjKHAuZWxlbWVudCxcInByZXNzZW5kXCIse3RvdWNoOm4sdG91Y2hFdmVudDphfSksZGVsZXRlIGxbb119fTA9PT1PYmplY3Qua2V5cyhsKS5sZW5ndGgmJihqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIixmLCExKSxqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLGcsITEpLGoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsaCwhMSkpfWZ1bmN0aW9uIGgoYSl7aWYoMj09T2JqZWN0LmtleXMobCkubGVuZ3RoKXt2YXIgZD1bXTtmb3IodmFyIGUgaW4gbClkLnB1c2gobFtlXS5lbGVtZW50KTtjKGIoZFswXSxkWzFdKSxcImR1YWx0b3VjaGVuZFwiLHt0b3VjaGVzOmsuY2FsbChhLnRvdWNoZXMpLHRvdWNoRXZlbnQ6YX0pfWZvcih2YXIgaT0wO2k8YS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7aSsrKXt2YXIgbT1hLmNoYW5nZWRUb3VjaGVzW2ldLG49bS5pZGVudGlmaWVyLG89bFtuXTtvJiYoby5wcmVzc2luZ0hhbmRsZXImJihjbGVhclRpbWVvdXQoby5wcmVzc2luZ0hhbmRsZXIpLG8ucHJlc3NpbmdIYW5kbGVyPW51bGwpLFwicGFubmluZ1wiPT09by5zdGF0dXMmJmMoby5lbGVtZW50LFwicGFuZW5kXCIse3RvdWNoOm0sdG91Y2hlczphLnRvdWNoZXMsY2hhbmdlZFRvdWNoZXM6YS5jaGFuZ2VkVG91Y2hlcyx0b3VjaEV2ZW50OmF9KSxcInByZXNzaW5nXCI9PT1vLnN0YXR1cyYmYyhvLmVsZW1lbnQsXCJwcmVzc2VuZFwiLHt0b3VjaDptLHRvdWNoRXZlbnQ6YX0pLGRlbGV0ZSBsW25dKX0wPT09T2JqZWN0LmtleXMobCkubGVuZ3RoJiYoai5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsZiwhMSksai5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIixnLCExKSxqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLGgsITEpKX12YXIgaT1hLmRvY3VtZW50LGo9aS5kb2N1bWVudEVsZW1lbnQsaz1BcnJheS5wcm90b3R5cGUuc2xpY2UsbD17fSxtPW51bGw7ai5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGUsITEpfSh3aW5kb3cpOzttb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5saWJbJ2dlc3R1cmVqcyddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvfi9jYXJyb3VzZWwvfi9nZXN0dXJlanMvYnVpbGQvZ2VzdHVyZWpzLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zbGlkZXIuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zbGlkZXIuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zbGlkZXIuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvc2xpZGVyLmNzc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2xpZGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLnNsaWRlciAuaW5kaWNhdG9yLWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xcbiAgYm94LWFsaWduOiBjZW50ZXI7XFxuICAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcbiAgYm94LXBhY2s6IGNlbnRlcjtcXG4gIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMDtcXG59XFxuLnNsaWRlciAuaW5kaWNhdG9yLWNvbnRhaW5lciAuaW5kaWNhdG9yIHtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG59XFxuLnNsaWRlciAuaW5kaWNhdG9yLWNvbnRhaW5lci5yb3cge1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiBob3Jpem9udGFsO1xcbiAgYm94LW9yaWVudDogaG9yaXpvbnRhbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxufVxcbi5zbGlkZXIgLmluZGljYXRvci1jb250YWluZXIuY29sdW1uIHtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XFxuICBib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9zbGlkZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gNTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCcuLi91dGlscycpLmV4dGVuZFxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpXG52YXIgQXRvbWljID0gcmVxdWlyZSgnLi9hdG9taWMnKVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50JylcblxucmVxdWlyZSgnLi4vc3R5bGVzL2luZGljYXRvci5jc3MnKVxuXG52YXIgREVGQVVMVF9JVEVNX0NPTE9SID0gJyM5OTknXG52YXIgREVGQVVMVF9JVEVNX1NFTEVDVEVEX0NPTE9SID0gJyMwMDAwZmYnXG52YXIgREVGQVVMVF9JVEVNX1NJWkUgPSAyMFxudmFyIERFRkFVTFRfTUFSR0lOX1NJWkUgPSAxMFxuXG4vLyBTdHlsZSBzdXBwb3J0ZWQ6XG4vLyAgIHBvc2l0aW9uOiAoZGVmYXVsdCAtIGFic29sdXRlKVxuLy8gICBpdGVtQ29sb3I6IGNvbG9yIG9mIGluZGljYXRvciBkb3RzXG4vLyAgIGl0ZW1TZWxlY3RlZENvbG9yOiBjb2xvciBvZiB0aGUgc2VsZWN0ZWQgaW5kaWNhdG9yIGRvdFxuLy8gICBpdGVtU2l6ZTogc2l6ZSBvZiBpbmRpY2F0b3JzXG4vLyAgIG90aGVyIGxheW91dCBzdHlsZXNcbmZ1bmN0aW9uIEluZGljYXRvciAoZGF0YSkge1xuICB0aGlzLmRpcmVjdGlvbiA9ICdyb3cnIC8vICdjb2x1bW4nIGlzIG5vdCB0ZW1wb3JhcmlseSBzdXBwb3J0ZWQuXG4gIHRoaXMuYW1vdW50ID0gZGF0YS5leHRyYS5hbW91bnRcbiAgdGhpcy5pbmRleCA9IGRhdGEuZXh0cmEuaW5kZXhcbiAgdGhpcy5zbGlkZXJXaWR0aCA9IGRhdGEuZXh0cmEud2lkdGhcbiAgdGhpcy5zbGlkZXJIZWlnaHQgPSBkYXRhLmV4dHJhLmhlaWdodFxuICB2YXIgc3R5bGVzID0gZGF0YS5zdHlsZSB8fCB7fVxuICB0aGlzLmRhdGEgPSBkYXRhXG4gIHRoaXMuc3R5bGUud2lkdGguY2FsbCh0aGlzLCBzdHlsZXMud2lkdGgpXG4gIHRoaXMuc3R5bGUuaGVpZ2h0LmNhbGwodGhpcywgc3R5bGVzLmhlaWdodClcbiAgdGhpcy5pdGVtcyA9IFtdXG4gIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG59XG5cbkluZGljYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG5cbkluZGljYXRvci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1pbmRpY2F0b3JzJylcbiAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWVsZW1lbnQnKVxuICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICB0aGlzLm5vZGUgPSBub2RlXG4gIHRoaXMuc3R5bGUuaXRlbVNpemUuY2FsbCh0aGlzLCAwKVxuICB0aGlzLml0ZW1Db2xvciA9IERFRkFVTFRfSVRFTV9DT0xPUlxuICB0aGlzLml0ZW1TZWxlY3RlZENvbG9yID0gREVGQVVMVF9JVEVNX1NFTEVDVEVEX0NPTE9SXG4gIHRoaXMudXBkYXRlU3R5bGUoe1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGl0ZW1TaXplOiAwXG4gIH0pXG4gIHJldHVybiBub2RlXG59XG5cbkluZGljYXRvci5wcm90b3R5cGUuY3JlYXRlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByb290ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hbW91bnQ7IGkrKykge1xuICAgIHZhciBpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGluZGljYXRvci5jbGFzc0xpc3QuYWRkKCd3ZWV4LWluZGljYXRvcicpXG4gICAgaW5kaWNhdG9yLnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94J1xuICAgIGluZGljYXRvci5zdHlsZS5tYXJnaW4gPSAnMCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAoREVGQVVMVF9NQVJHSU5fU0laRSAqIHRoaXMuZGF0YS5zY2FsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArICdweCdcbiAgICBpbmRpY2F0b3Iuc3R5bGUud2lkdGggPSB0aGlzLml0ZW1TaXplICsgJ3B4J1xuICAgIGluZGljYXRvci5zdHlsZS5oZWlnaHQgPSB0aGlzLml0ZW1TaXplICsgJ3B4J1xuICAgIGluZGljYXRvci5zZXRBdHRyaWJ1dGUoJ2luZGV4JywgaSlcbiAgICBpZiAodGhpcy5pbmRleCA9PT0gaSkge1xuICAgICAgaW5kaWNhdG9yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuaXRlbVNlbGVjdGVkQ29sb3JcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNhdG9yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuaXRlbUNvbG9yXG4gICAgfVxuICAgIGluZGljYXRvci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NsaWNrSGFuZGxlci5iaW5kKHRoaXMsIGkpKVxuICAgIHRoaXMuaXRlbXNbaV0gPSBpbmRpY2F0b3JcbiAgICByb290LmFwcGVuZENoaWxkKGluZGljYXRvcilcbiAgfVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQocm9vdClcbn1cblxuSW5kaWNhdG9yLnByb3RvdHlwZS5zdHlsZVxuICAgID0gZXh0ZW5kKE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZS5zdHlsZSksIHtcbiAgaXRlbUNvbG9yOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdGhpcy5pdGVtQ29sb3IgPSB2YWwgfHwgREVGQVVMVF9JVEVNX0NPTE9SXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLml0ZW1Db2xvclxuICAgIH1cbiAgfSxcblxuICBpdGVtU2VsZWN0ZWRDb2xvcjogZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuaXRlbVNlbGVjdGVkQ29sb3IgPSB2YWwgfHwgREVGQVVMVF9JVEVNX1NFTEVDVEVEX0NPTE9SXG4gICAgaWYgKHR5cGVvZiB0aGlzLmluZGV4ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgIHRoaXMuaXRlbXNbdGhpcy5pbmRleF0uc3R5bGUuYmFja2dyb3VuZENvbG9yXG4gICAgICAgICAgPSB0aGlzLml0ZW1TZWxlY3RlZENvbG9yXG4gICAgfVxuICB9LFxuXG4gIGl0ZW1TaXplOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VJbnQodmFsKSAqIHRoaXMuZGF0YS5zY2FsZVxuICAgICAgICAgIHx8IERFRkFVTFRfSVRFTV9TSVpFICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5pdGVtU2l6ZSA9IHZhbFxuICAgIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSB2YWwgKyAncHgnXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLml0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5pdGVtc1tpXS5zdHlsZS53aWR0aCA9IHZhbCArICdweCdcbiAgICAgIHRoaXMuaXRlbXNbaV0uc3R5bGUuaGVpZ2h0ID0gdmFsICsgJ3B4J1xuICAgIH1cbiAgfSxcblxuICB3aWR0aDogZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhbCA9IHBhcnNlSW50KHZhbCkgKiB0aGlzLmRhdGEuc2NhbGUgfHwgcGFyc2VJbnQodGhpcy5zbGlkZXJXaWR0aClcbiAgICB0aGlzLnZpcnR1YWxXcmFwcGVyV2lkdGggPSB2YWxcbiAgfSxcblxuICBoZWlnaHQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBwYXJzZUludCh2YWwpICogdGhpcy5kYXRhLnNjYWxlIHx8IHBhcnNlSW50KHRoaXMuc2xpZGVySGVpZ2h0KVxuICAgIHRoaXMudmlydHVhbFdyYXBwZXJIZWlnaHQgPSB2YWxcbiAgfSxcblxuICB0b3A6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSB0aGlzLnZpcnR1YWxXcmFwcGVySGVpZ2h0IC8gMiAtIHRoaXMuaXRlbVNpemUgLyAyXG4gICAgICAgICsgdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5ub2RlLnN0eWxlLmJvdHRvbSA9ICcnXG4gICAgdGhpcy5ub2RlLnN0eWxlLnRvcCA9IHZhbCArICdweCdcbiAgfSxcblxuICBib3R0b206IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSB0aGlzLnZpcnR1YWxXcmFwcGVySGVpZ2h0IC8gMiAtIHRoaXMuaXRlbVNpemUgLyAyXG4gICAgICAgICsgdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5ub2RlLnN0eWxlLnRvcCA9ICcnXG4gICAgdGhpcy5ub2RlLnN0eWxlLmJvdHRvbSA9IHZhbCArICdweCdcbiAgfSxcblxuICBsZWZ0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gdGhpcy52aXJ0dWFsV3JhcHBlcldpZHRoIC8gMlxuICAgICAgICAgIC0gKHRoaXMuaXRlbVNpemUgKyAyICogREVGQVVMVF9NQVJHSU5fU0laRSAqIHRoaXMuZGF0YS5zY2FsZSlcbiAgICAgICAgICAgICAgKiB0aGlzLmFtb3VudCAvIDJcbiAgICAgICAgICArIHZhbCAqIHRoaXMuZGF0YS5zY2FsZVxuICAgIHRoaXMubm9kZS5zdHlsZS5yaWdodCA9ICcnXG4gICAgdGhpcy5ub2RlLnN0eWxlLmxlZnQgPSB2YWwgKyAncHgnXG4gIH0sXG5cbiAgcmlnaHQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSB0aGlzLnZpcnR1YWxXcmFwcGVyV2lkdGggLyAyXG4gICAgICAgICAgLSAodGhpcy5pdGVtU2l6ZSArIDIgKiBERUZBVUxUX01BUkdJTl9TSVpFICogdGhpcy5kYXRhLnNjYWxlKVxuICAgICAgICAgICAgICAqIHRoaXMuYW1vdW50IC8gMlxuICAgICAgICAgICsgdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgdGhpcy5ub2RlLnN0eWxlLmxlZnQgPSAnJ1xuICAgIHRoaXMubm9kZS5zdHlsZS5yaWdodCA9IHZhbCArICdweCdcbiAgfVxufSlcblxuSW5kaWNhdG9yLnByb3RvdHlwZS5zZXRJbmRleCA9IGZ1bmN0aW9uIChpZHgpIHtcbiAgaWYgKGlkeCA+PSB0aGlzLmFtb3VudCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBwcmV2ID0gdGhpcy5pdGVtc1t0aGlzLmluZGV4XVxuICB2YXIgY3VyID0gdGhpcy5pdGVtc1tpZHhdXG4gIHByZXYuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJylcbiAgcHJldi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLml0ZW1Db2xvclxuICBjdXIuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJylcbiAgY3VyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuaXRlbVNlbGVjdGVkQ29sb3JcbiAgdGhpcy5pbmRleCA9IGlkeFxufVxuXG5JbmRpY2F0b3IucHJvdG90eXBlLl9jbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoaWR4KSB7XG4gIHRoaXMuc2xpZGVyLnNsaWRlVG8oaWR4KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZGljYXRvclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9pbmRpY2F0b3IuanNcbiAqKiBtb2R1bGUgaWQgPSA2MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kaWNhdG9yLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kaWNhdG9yLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kaWNhdG9yLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2luZGljYXRvci5jc3NcbiAqKiBtb2R1bGUgaWQgPSA2MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlZXgtaW5kaWNhdG9ycyB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbn1cXG4ud2VleC1pbmRpY2F0b3JzIC53ZWV4LWluZGljYXRvciB7XFxuICBmbG9hdDogbGVmdDtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2luZGljYXRvci5jc3NcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIEF0b21pYyA9IHJlcXVpcmUoJy4vYXRvbWljJylcbnZhciBtc2dRdWV1ZSA9IHJlcXVpcmUoJy4uL21lc3NhZ2VRdWV1ZScpXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi4vY29uZmlnJylcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJylcblxuLy8gVE9ETzogcmVmYWN0b3IgdGhpcyBzY3NzIGNvZGUgc2luY2UgdGhpcyBpcyBzdHJvbmdseVxuLy8gZGVwZW5kZW50IG9uIGxpYi5mbGV4aWJsZSBvdGhlciB0aGFuIHRoZSB2YWx1ZSBvZlxuLy8gc2NhbGUuXG5yZXF1aXJlKCcuLi9zdHlsZXMvdGFiaGVhZGVyLmNzcycpXG5cbmZ1bmN0aW9uIFRhYkhlYWRlcihkYXRhKSB7XG4gIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG59XG5cbnZhciBwcm90byA9IFRhYkhlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG5cbnByb3RvLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gb3V0c2lkZSBjb250YWluZXIuXG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgbm9kZS5jbGFzc05hbWUgPSAndGFiLWhlYWRlcidcbiAgLy8gdGlwIG9uIHRoZSB0b3AuXG4gIHZhciBiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBiYXIuY2xhc3NOYW1lID0gJ2hlYWRlci1iYXInXG4gIGJhci50ZXh0Q29udGVudCA9ICdDSEFOR0UgRkxPT1InXG4gIC8vIG1pZGRsZSBsYXllci5cbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBib2R5LmNsYXNzTmFtZSA9ICdoZWFkZXItYm9keSdcbiAgdmFyIGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJylcbiAgYm94LmNsYXNzTmFtZSA9ICd0YWJoZWFkZXInXG5cbiAgYm9keS5hcHBlbmRDaGlsZChib3gpXG4gIG5vZGUuYXBwZW5kQ2hpbGQoYmFyKVxuICBub2RlLmFwcGVuZENoaWxkKGJvZHkpXG4gIHRoaXMuX2JhciA9IGJhclxuICB0aGlzLl9ib2R5ID0gYm9keVxuICB0aGlzLmJveCA9IGJveFxuICB0aGlzLm5vZGUgPSBub2RlXG4gIC8vIGluaXQgZXZlbnRzLlxuICB0aGlzLl9pbml0Rm9sZEJ0bigpXG4gIHRoaXMuX2luaXRFdmVudCgpXG4gIHJldHVybiBub2RlXG59XG5cbnByb3RvLl9pbml0Rm9sZEJ0biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpc1xuICB2YXIgbm9kZSA9IHRoaXMubm9kZVxuICB2YXIgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIGJ0bi5jbGFzc05hbWUgPSAnZm9sZC10b2dnbGUgaWNvbmZvbnQnXG4gIGJ0bi5pbm5lckhUTUwgPSAnJiN4ZTY2MTsnXG4gIG5vZGUuYXBwZW5kQ2hpbGQoYnRuKVxuXG4gIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RoaXMudW5mb2xkaW5nKSB7XG4gICAgICBfdGhpcy5fZm9sZGluZygpXG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLl91bmZvbGRpbmcoKVxuICAgIH1cbiAgfSlcbn1cblxucHJvdG8uX2luaXRNYXNrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG1hc2suY2xhc3NOYW1lID0gJ3RhYmhlYWRlci1tYXNrJ1xuICB0aGlzLm1hc2sgPSBtYXNrXG4gIC8vIHN0b3AgZGVmYXVsdCBiZWhhdmlvcjogcGFnZSBtb3ZpbmcuXG4gIG1hc2suYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gIH0pXG4gIC8vIGNsaWNrIHRvIHVuZm9sZC5cbiAgdmFyIF90aGlzID0gdGhpc1xuICBtYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLl9mb2xkaW5nKClcbiAgfSlcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1hc2spXG59XG5cbnByb3RvLl91bmZvbGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIG1hcmsgdGhlIGluaXRpYWwgcG9zaWl0b24gb2YgdGFiaGVhZGVyXG4gIGlmICghdGhpcy5mbGFnKSB7XG4gICAgdmFyIGZsYWcgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCd0YWJoZWFkZXInKVxuICAgIHRoaXMuZmxhZyA9IGZsYWdcbiAgICB0aGlzLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZmxhZywgdGhpcy5ub2RlKVxuICB9XG4gIGlmICghdGhpcy5tYXNrKSB7XG4gICAgdGhpcy5faW5pdE1hc2soKVxuICB9XG5cbiAgLy8gcmVjb3JkIHRoZSBzY3JvbGwgcG9zaXRpb24uXG4gIHRoaXMuX3Njcm9sbFZhbCA9IHRoaXMuX2JvZHkuc2Nyb2xsTGVmdFxuICAvLyByZWNvcmQgdGhlIHBvc2l0aW9uIGluIGRvY3VtZW50LlxuICB0aGlzLl90b3BWYWwgPSB0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gIHRoaXMuX3N0eWxlVG9wID0gdGhpcy5ub2RlLnN0eWxlLnRvcFxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICB0aGlzLm5vZGUuY2xhc3NMaXN0LmFkZCgndW5mb2xkLWhlYWRlcicpXG4gIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSAnYXV0bydcbiAgLy8gcmVjYWxjIHRoZSBwb3NpdGlvbiB3aGVuIGl0IGlzIHVuZm9sZGVkLlxuICB2YXIgdGhIZWlnaHQgPSB0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gIGlmICh0aEhlaWdodCArIHRoaXMuX3RvcFZhbCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xuICAgIHRoaXMuX3RvcFZhbCA9IHRoaXMuX3RvcFZhbFxuICAgICAgICArICh3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aEhlaWdodCAtIHRoaXMuX3RvcFZhbClcbiAgfVxuXG4gIHRoaXMubm9kZS5zdHlsZS50b3AgPSB0aGlzLl90b3BWYWwgKyAncHgnXG4gIC8vIHByb2Nlc3MgbWFzayBzdHlsZVxuICB0aGlzLm1hc2suY2xhc3NMaXN0LmFkZCgndW5mb2xkLWhlYWRlcicpXG4gIHRoaXMubWFzay5zdHlsZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKyAncHgnXG4gIHRoaXMudW5mb2xkaW5nID0gdHJ1ZVxufVxuXG5wcm90by5fZm9sZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMudW5mb2xkaW5nICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLm1hc2suY2xhc3NMaXN0LnJlbW92ZSgndW5mb2xkLWhlYWRlcicpXG4gIHRoaXMubm9kZS5jbGFzc0xpc3QucmVtb3ZlKCd1bmZvbGQtaGVhZGVyJylcblxuICB0aGlzLm5vZGUuc3R5bGUuaGVpZ2h0ID0gJydcbiAgdGhpcy5ub2RlLnN0eWxlLnRvcCA9IHRoaXMuX3N0eWxlVG9wXG5cbiAgLy8gcmVjb3ZlciB0aGUgcG9zaXRpb24gb2YgdGFiaGVhZGVyLlxuICB0aGlzLmZsYWcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5ub2RlLCB0aGlzLmZsYWcpXG4gIC8vIHJlY292ZXIgdGhlIHBvc2l0aW9uIG9mIHNjb2xsZXIuXG4gIHRoaXMuX2JvZHkuc2Nyb2xsTGVmdCA9IHRoaXMuX3Njcm9sbFZhbFxuXG4gIHRoaXMuX3Njcm9sbFRvVmlldygpXG4gIHRoaXMudW5mb2xkaW5nID0gZmFsc2Vcbn1cblxucHJvdG8uX2luaXRFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5faW5pdENsaWNrRXZlbnQoKVxuICB0aGlzLl9pbml0U2VsZWN0RXZlbnQoKVxufVxuXG4vLyBpbml0IGV2ZW50cy5cbnByb3RvLl9pbml0Q2xpY2tFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJveCA9IHRoaXMuYm94XG4gIHZhciBfdGhpcyA9IHRoaXNcblxuICBib3guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2dC50YXJnZXRcbiAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnVUwnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LnBhcmVudE5vZGUubm9kZU5hbWUgPT09ICdMSScpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlXG4gICAgfVxuXG4gICAgdmFyIGZsb29yID0gdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1mbG9vcicpXG5cbiAgICBpZiAoX3RoaXMuZGF0YS5hdHRyLnNlbGVjdGVkSW5kZXggPT0gZmxvb3IpIHtcbiAgICAgIC8vIER1cGxpY2F0ZWQgY2xpY2tpbmcsIG5vdCB0byB0cmlnZ2VyIHNlbGVjdCBldmVudC5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZpcmVFdmVudCh0YXJnZXQsICdzZWxlY3QnLCB7aW5kZXg6ICBmbG9vcn0pXG4gIH0pXG59XG5cbnByb3RvLl9pbml0U2VsZWN0RXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5ub2RlXG4gIHZhciBfdGhpcyA9IHRoaXNcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3QnLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgdmFyIGluZGV4XG4gICAgaWYgKGV2dC5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmRleCA9IGV2dC5pbmRleFxuICAgIH0gZWxzZSBpZiAoZXZ0LmRhdGEgJiYgZXZ0LmRhdGEuaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5kZXggPSBldnQuZGF0YS5pbmRleFxuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBfdGhpcy5hdHRyLnNlbGVjdGVkSW5kZXguY2FsbChfdGhpcywgaW5kZXgpXG4gIH0pXG59XG5cbnByb3RvLmF0dHIgPSB7XG4gIGhpZ2hsaWdodEljb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSGlnaGxpZ2h0SWNvbigpXG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXR0ciA9IHRoaXMuZGF0YS5hdHRyXG4gICAgLy8gRW5zdXJlIHRoZXJlIGlzIGEgZGVmYXVsdCBzZWxlY3RlZCB2YWx1ZS5cbiAgICBpZiAoYXR0ci5zZWxlY3RlZEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF0dHIuc2VsZWN0ZWRJbmRleCA9IDBcbiAgICB9XG5cbiAgICB2YXIgbGlzdCA9IGF0dHIuZGF0YSB8fCBbXVxuICAgIHZhciBjdXJJdGVtID0gYXR0ci5zZWxlY3RlZEluZGV4XG5cbiAgICB2YXIgcmV0ID0gW11cbiAgICB2YXIgaXRlbVRtcGwgPSAnPGxpIGNsYXNzPVwidGgtaXRlbVwiIGRhdGEtZmxvb3I9XCJ7e2Zsb29yfX1cIj4nXG4gICAgICAgICsgJ3t7aGxJY29ufX17e2Zsb29yTmFtZX19PC9saT4nXG5cbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGh0bWwgPSBpdGVtVG1wbC5yZXBsYWNlKCd7e2Zsb29yfX0nLCBpZHgpXG4gICAgICBpZiAoY3VySXRlbSA9PSBpZHgpIHtcbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgne3tobEljb259fScsIGNyZWF0ZUhpZ2hsaWdodEljb24oKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSBodG1sLnJlcGxhY2UoJ3t7aGxJY29ufX0nLCAnJylcbiAgICAgIH1cblxuICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZSgne3tmbG9vck5hbWV9fScsIGl0ZW0pXG5cbiAgICAgIHJldC5wdXNoKGh0bWwpXG4gICAgfSwgdGhpcylcblxuICAgIHRoaXMuYm94LmlubmVySFRNTCA9IHJldC5qb2luKCcnKVxuICB9LFxuICBzZWxlY3RlZEluZGV4OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIGF0dHIgPSB0aGlzLmRhdGEuYXR0clxuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWwgPSAwXG4gICAgfVxuXG4gICAgLy8gaWYgKHZhbCA9PSBhdHRyLnNlbGVjdGVkSW5kZXgpIHtcbiAgICAvLyAgIHJldHVyblxuICAgIC8vIH1cblxuICAgIGF0dHIuc2VsZWN0ZWRJbmRleCA9IHZhbFxuXG4gICAgdGhpcy5hdHRyLmRhdGEuY2FsbCh0aGlzKVxuXG4gICAgdGhpcy5fZm9sZGluZygpXG4gICAgdGhpcy5zdHlsZS50ZXh0SGlnaGxpZ2h0Q29sb3IuY2FsbCh0aGlzLCB0aGlzLnRleHRIaWdobGlnaHRDb2xvcilcbiAgfVxufVxuXG5wcm90by5zdHlsZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZS5zdHlsZSlcblxucHJvdG8uc3R5bGUub3BhY2l0eSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA8IDAgfHwgdmFsID4gMSkge1xuICAgIHZhbCA9IDFcbiAgfVxuXG4gIHRoaXMubm9kZS5zdHlsZS5vcGFjaXR5ID0gdmFsXG59XG5cbnByb3RvLnN0eWxlLnRleHRDb2xvciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKCFpc1ZhbGlkQ29sb3IodmFsKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdGhpcy5ub2RlLnN0eWxlLmNvbG9yID0gdmFsXG59XG5cbnByb3RvLnN0eWxlLnRleHRIaWdobGlnaHRDb2xvciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgaWYgKCFpc1ZhbGlkQ29sb3IodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIHRoaXMudGV4dEhpZ2hsaWdodENvbG9yID0gdmFsXG4gIHZhciBhdHRyID0gdGhpcy5kYXRhLmF0dHJcblxuICB2YXIgbm9kZSA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1mbG9vcj1cIidcbiAgICAgICsgYXR0ci5zZWxlY3RlZEluZGV4ICsgJ1wiXScpXG4gIGlmIChub2RlKSB7XG4gICAgbm9kZS5zdHlsZS5jb2xvciA9IHZhbFxuICAgIHRoaXMuX3Njcm9sbFRvVmlldyhub2RlKVxuICB9XG59XG5cbnByb3RvLl9zY3JvbGxUb1ZpZXcgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICB2YXIgYXR0ciA9IHRoaXMuZGF0YS5hdHRyXG4gICAgbm9kZSA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1mbG9vcj1cIicgKyBhdHRyLnNlbGVjdGVkSW5kZXggKyAnXCJdJylcbiAgfVxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBkZWZhdWx0VmFsID0gdGhpcy5fYm9keS5zY3JvbGxMZWZ0XG4gIHZhciBsZWZ0VmFsID0gZGVmYXVsdFZhbCAgLSBub2RlLm9mZnNldExlZnQgKyAzMDBcblxuICB2YXIgc2Nyb2xsVmFsID0gZ2V0U2Nyb2xsVmFsKHRoaXMuX2JvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG5vZGUpXG4gIGRvU2Nyb2xsKHRoaXMuX2JvZHksIHNjcm9sbFZhbClcbn1cblxuLy8gc2Nyb2xsIHRoZSB0YWJoZWFkZXIuXG4vLyBwb3NpdGl2ZSB2YWwgbWVhbnMgdG8gc2Nyb2xsIHJpZ2h0LlxuLy8gbmVnYXRpdmUgdmFsIG1lYW5zIHRvIHNjcm9sbCBsZWZ0LlxuZnVuY3Rpb24gZG9TY3JvbGwobm9kZSwgdmFsLCBmaW5pc2gpIHtcbiAgaWYgKCF2YWwpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoZmluaXNoID09PSB1bmRlZmluZWQpIHtcbiAgICBmaW5pc2ggPSBNYXRoLmFicyh2YWwpXG4gIH1cblxuICBpZiAoZmluaXNoIDw9IDApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICh2YWwgPiAwKSB7XG4gICAgICBub2RlLnNjcm9sbExlZnQgKz0gMlxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNjcm9sbExlZnQgLT0gMlxuICAgIH1cbiAgICBmaW5pc2ggLT0gMlxuXG4gICAgZG9TY3JvbGwobm9kZSwgdmFsLCBmaW5pc2gpXG4gIH0pXG59XG5cbi8vIGdldCBzY3JvbGwgZGlzdGFuY2UuXG5mdW5jdGlvbiBnZXRTY3JvbGxWYWwocmVjdCwgbm9kZSkge1xuICB2YXIgbGVmdCA9IG5vZGUucHJldmlvdXNTaWJsaW5nXG4gIHZhciByaWdodCA9IG5vZGUubmV4dFNpYmxpbmdcbiAgdmFyIHNjcm9sbFZhbFxuXG4gIC8vIHByb2Nlc3MgbGVmdC1zaWRlIGVsZW1lbnQgZmlyc3QuXG4gIGlmIChsZWZ0KSB7XG4gICAgdmFyIGxlZnRSZWN0ID0gbGVmdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIC8vIG9ubHkgbmVlZCB0byBjb21wYXJlIHRoZSB2YWx1ZSBvZiBsZWZ0LlxuICAgIGlmIChsZWZ0UmVjdC5sZWZ0IDwgcmVjdC5sZWZ0KSB7XG4gICAgICBzY3JvbGxWYWwgPSBsZWZ0UmVjdC5sZWZ0XG4gICAgICByZXR1cm4gc2Nyb2xsVmFsXG4gICAgfVxuICB9XG5cbiAgaWYgKHJpZ2h0KSB7XG4gICAgdmFyIHJpZ2h0UmVjdCA9IHJpZ2h0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgLy8gY29tcGFyZSB0aGUgdmFsdWUgb2YgcmlnaHQuXG4gICAgaWYgKHJpZ2h0UmVjdC5yaWdodCA+IHJlY3QucmlnaHQpIHtcbiAgICAgIHNjcm9sbFZhbCA9IHJpZ2h0UmVjdC5yaWdodCAtIHJlY3QucmlnaHRcbiAgICAgIHJldHVybiBzY3JvbGxWYWxcbiAgICB9XG4gIH1cblxuICAvLyBwcm9jZXNzIGN1cnJlbnQgbm9kZSwgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICB2YXIgbm9kZVJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGlmIChub2RlUmVjdC5sZWZ0IDwgcmVjdC5sZWZ0KSB7XG4gICAgc2Nyb2xsVmFsID0gbm9kZVJlY3QubGVmdFxuICB9IGVsc2UgaWYgKG5vZGVSZWN0LnJpZ2h0ID4gcmVjdC5yaWdodCkge1xuICAgIHNjcm9sbFZhbCA9IG5vZGVSZWN0LnJpZ2h0IC0gcmVjdC5yaWdodFxuICB9XG5cbiAgcmV0dXJuIHNjcm9sbFZhbFxufVxuXG4vLyB0cmlnZ2VyIGFuZCBicm9hZGNhc3QgZXZlbnRzLlxuZnVuY3Rpb24gZmlyZUV2ZW50KGVsZW1lbnQsIHR5cGUsIGRhdGEpIHtcbiAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpXG4gIGV2dC5kYXRhID0gZGF0YVxuICB1dGlscy5leHRlbmQoZXZ0LCBkYXRhKVxuICAvLyBuZWVkIGJ1YmJsZS5cbiAgZXZ0LmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKVxuXG4gIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodEljb24oY29kZSkge1xuICB2YXIgaHRtbCA9ICc8aSBjbGFzcz1cImhsLWljb24gaWNvbmZvbnRcIj4nICsgJyYjeGU2NTAnICsgJzwvaT4nXG4gIHJldHVybiBodG1sXG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRDb2xvcihjb2xvcikge1xuICBpZiAoIWNvbG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoY29sb3IuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChjb2xvci5sZW5ndGggIT09IDcpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gVGFiSGVhZGVyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3RhYmhlYWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDYzXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKVxudmFyIG1lc3NhZ2VRdWV1ZSA9IFtdXG5cbmZ1bmN0aW9uIGZsdXNoTWVzc2FnZSgpIHtcbiAgaWYgKHR5cGVvZiBjYWxsSlMgPT09ICdmdW5jdGlvbicgJiYgbWVzc2FnZVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICBjYWxsSlMoY29uZmlnLmluc3RhbmNlSWQsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VRdWV1ZSkpXG4gICAgbWVzc2FnZVF1ZXVlLmxlbmd0aCA9IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoKG1zZykge1xuICBtZXNzYWdlUXVldWUucHVzaChtc2cpXG59XG5cbi8qKlxuICogVG8gZml4IHRoZSBwcm9ibGVtIG9mIGNhbGxhcHAsIHRoZSB0d28td2F5IHRpbWUgbG9vcCBtZWNoYW5pc20gbXVzdFxuICogYmUgcmVwbGFjZWQgYnkgZGlyZWN0bHkgcHJvY2VkdXJlIGNhbGwgZXhjZXB0IHRoZSBzaXR1YXRpb24gb2ZcbiAqIHBhZ2UgbG9hZGluZy5cbiAqIDIwMTUtMTEtMDNcbiAqL1xuZnVuY3Rpb24gcHVzaERpcmVjdGx5KG1zZykge1xuICBjYWxsSlMoY29uZmlnLmluc3RhbmNlSWQsIFttc2ddKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcHVzaDogcHVzaERpcmVjdGx5XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9tZXNzYWdlUXVldWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdGFiaGVhZGVyLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdGFiaGVhZGVyLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdGFiaGVhZGVyLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3RhYmhlYWRlci5jc3NcbiAqKiBtb2R1bGUgaWQgPSA2NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnRhYi1oZWFkZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDEwcmVtO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgY29sb3I6ICMzMzM7XFxufVxcbi50YWItaGVhZGVyIC5oZWFkZXItYmFyIHtcXG4gIGhlaWdodDogMS4xN3JlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjE3cmVtO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGNvbG9yOiAjOTk5O1xcbiAgcGFkZGluZy1sZWZ0OiAwLjRyZW07XFxufVxcbi50YWItaGVhZGVyIC5oZWFkZXItYm9keSB7XFxuICBtYXJnaW4tcmlnaHQ6IDEuMDdyZW07XFxuICBvdmVyZmxvdy14OiBhdXRvO1xcbiAgb3ZlcmZsb3cteTogaGlkZGVuO1xcbn1cXG4udGFiLWhlYWRlciAuaGVhZGVyLWJvZHk6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcXG4gIHdpZHRoOiAwO1xcbiAgaGVpZ2h0OiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuLnRhYi1oZWFkZXIgLmZvbGQtdG9nZ2xlIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMC41OXJlbTtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xcbiAgcmlnaHQ6IDAuMjlyZW07XFxuICB3aWR0aDogMC40OHJlbTtcXG4gIGhlaWdodDogMC40OHJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjQ4cmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgei1pbmRleDogOTk7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi50YWItaGVhZGVyLnVuZm9sZC1oZWFkZXIge1xcbiAgcG9zaXRpb246IGZpeGVkICFpbXBvcnRhbnQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLnRhYmhlYWRlciB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXG4gIGhlaWdodDogMS4xN3JlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjE3cmVtO1xcbn1cXG4udGFiaGVhZGVyIC50aC1pdGVtIHtcXG4gIHBhZGRpbmctbGVmdDogMC43MnJlbTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLnRhYmhlYWRlciAuaGwtaWNvbiB7XFxuICB3aWR0aDogMC40cmVtO1xcbiAgaGVpZ2h0OiAwLjRyZW07XFxuICBsaW5lLWhlaWdodDogMC40cmVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gIGxlZnQ6IDAuMjRyZW07XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcblxcbi51bmZvbGQtaGVhZGVyIC5oZWFkZXItYmFyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4udW5mb2xkLWhlYWRlciAuZm9sZC10b2dnbGUge1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTUwJSkgcm90YXRlKDE4MGRlZyk7XFxufVxcbi51bmZvbGQtaGVhZGVyIC5oZWFkZXItYm9keSB7XFxuICBtYXJnaW4tcmlnaHQ6IDA7XFxuICBwYWRkaW5nOiAwLjI0cmVtO1xcbn1cXG4udW5mb2xkLWhlYWRlciAudGFiaGVhZGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG4udW5mb2xkLWhlYWRlciAudGgtaXRlbSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICB3aWR0aDogMzMuMzMzMyU7XFxuICBoZWlnaHQ6IDEuMDFyZW07XFxuICBsaW5lLWhlaWdodDogMS4wMXJlbTtcXG59XFxuLnVuZm9sZC1oZWFkZXIgLmhsLWljb24ge1xcbiAgbWFyZ2luLXJpZ2h0OiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4udW5mb2xkLWhlYWRlci50YWJoZWFkZXItbWFzayB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjYpO1xcbn1cXG5cXG4udGFiaGVhZGVyLW1hc2sge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxufVxcblxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJpY29uZm9udFxcXCI7XFxuICBzcmM6IHVybChcXFwiZGF0YTphcHBsaWNhdGlvbi94LWZvbnQtdHRmO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LEFBRUFBQUFQQUlBQUF3QndSa1pVVFhCRDk4VUFBQUQ4QUFBQUhFOVRMekpYTDF6SUFBQUJHQUFBQUdCamJXRndzNklIYmdBQUFYZ0FBQUZhWTNaMElBeVYvc3dBQUFwUUFBQUFKR1p3WjIwdzk1NlZBQUFLZEFBQUNaWm5ZWE53QUFBQUVBQUFDa2dBQUFBSVoyeDVadXhvUEZJQUFBTFVBQUFFV0dobFlXUUhBNWgzQUFBSExBQUFBRFpvYUdWaEJ6SURjZ0FBQjJRQUFBQWthRzEwZUFzMkFXMEFBQWVJQUFBQUdHeHZZMkVEY0FRZUFBQUhvQUFBQUJCdFlYaHdBU2tLS3dBQUI3QUFBQUFnYm1GdFpRbC8zaGdBQUFmUUFBQUNMbkJ2YzNUbTdmMGJBQUFLQUFBQUFFaHdjbVZ3cGJtK1pnQUFGQXdBQUFDVkFBQUFBUUFBQUFETVBhTFBBQUFBQU5JREtub0FBQUFBMGdNcWV3QUVBL29COUFBRkFBQUNtUUxNQUFBQWp3S1pBc3dBQUFIckFETUJDUUFBQWdBR0F3QUFBQUFBQUFBQUFBRVFBQUFBQUFBQUFBQUFBQUJRWmtWa0FNQUFlT2JlQXl6L0xBQmNBeGdBbEFBQUFBRUFBQUFBQXhnQUFBQUFBQ0FBQVFBQUFBTUFBQUFEQUFBQUhBQUJBQUFBQUFCVUFBTUFBUUFBQUJ3QUJBQTRBQUFBQ2dBSUFBSUFBZ0I0NWxEbVllYmUvLzhBQUFCNDVsRG1ZZWJlLy8vL2l4bTBHYVFaS0FBQkFBQUFBQUFBQUFBQUFBQUFBUVlBQUFFQUFBQUFBQUFBQVFJQUFBQUNBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDQUNJQUFBRXlBcW9BQXdBSEFDbEFKZ0FBQUFNQ0FBTlhBQUlCQVFKTEFBSUNBVThFQVFFQ0FVTUFBQWNHQlFRQUF3QURFUVVQS3pNUklSRW5NeEVqSWdFUTdzek1BcXI5VmlJQ1pnQUFBQVVBTFAvaEE3d0RHQUFXQURBQU9nQlNBRjRCZDB1d0UxQllRRW9DQVFBTkRnMEFEbVlBQXc0QkRnTmVBQUVJQ0FGY0VBRUpDQW9HQ1Y0UkFRd0dCQVlNWGdBTEJBdHBEd0VJQUFZTUNBWllBQW9IQlFJRUN3b0VXUklCRGc0TlVRQU5EUW9PUWh0THNCZFFXRUJMQWdFQURRNE5BQTVtQUFNT0FRNERYZ0FCQ0FnQlhCQUJDUWdLQ0FrS1poRUJEQVlFQmd4ZUFBc0VDMmtQQVFnQUJnd0lCbGdBQ2djRkFnUUxDZ1JaRWdFT0RnMVJBQTBOQ2c1Q0cwdXdHRkJZUUV3Q0FRQU5EZzBBRG1ZQUF3NEJEZ05lQUFFSUNBRmNFQUVKQ0FvSUNRcG1FUUVNQmdRR0RBUm1BQXNFQzJrUEFRZ0FCZ3dJQmxnQUNnY0ZBZ1FMQ2dSWkVnRU9EZzFSQUEwTkNnNUNHMEJPQWdFQURRNE5BQTVtQUFNT0FRNERBV1lBQVFnT0FRaGtFQUVKQ0FvSUNRcG1FUUVNQmdRR0RBUm1BQXNFQzJrUEFRZ0FCZ3dJQmxnQUNnY0ZBZ1FMQ2dSWkVnRU9EZzFSQUEwTkNnNUNXVmxaUUNoVFV6czdNakVYRjFOZVUxNWJXRHRTTzFKTFF6YzFNVG95T2hjd0Z6QlJFVEVZRVNnVlFCTVdLd0VHS3dFaURnSWRBU0UxTkNZMU5DNENLd0VWSVFVVkZCWVVEZ0lqQmlZckFTY2hCeXNCSWljaUxnSTlBUmNpQmhRV016STJOQ1lYQmdjT0F4NEJPd1l5TmljdUFTY21Kd0UxTkQ0Q093RXlGaDBCQVJrYkdsTVNKUndTQTVBQkNoZ25Ib1grU2dLaUFSVWZJdzRPSHc0Z0xmNUpMQjBpRkJrWklCTUlkd3dTRWd3TkVoS01DQVlGQ3dRQ0JBOE9KVU5SVUVBa0Z4WUpCUWtGQlFiK3BBVVBHaFc4SHlrQ0h3RU1HU2NhVENrUUhBUU5JQnNTWVlnMEZ6bzZKUmNKQVFHQWdBRVRHeUFPcHo4UkdoRVJHaEY4R2hZVEpBNFFEUWdZR2cwakVSTVVBWGZrQ3hnVERCMG00d0FBQWdDZy8yd0RZQUxzQUJJQUdnQWhRQjRBQUFBREFnQURXUUFDQVFFQ1RRQUNBZ0ZSQUFFQ0FVVVRGamtRQkJJckFDQUdGUlFlQXhjV093RXlQd0VTTlRRQUlpWTBOaklXRkFLUy90ek9SRlZ2TVJBSkRnRU9DVzNiL3VLRVhsNkVYZ0xzenBJMWxYeUpOaEVLQzMwQkRJeVMvczVlaEY1ZWhBQUFBQUVBZ2dCSkE0UUI2QUFkQUJ0QUdCSVJBZ0VBQVVBRkFRQStBQUFCQUdnQUFRRmZFeDhDRUNzQkpnY0dCd2tCTGdFR0J3WVVGd0V3TXhjVkZqSTNBVDRETGdJRGVoRVdBd1ArdVA2MEJoRVFCZ29LQVdFQkFRb2FDUUZlQXdRQ0FRRUNCQUhoRWcwREF2NjFBVWtIQkFVR0NSc0ovcUlCQVFrSkFXSUNCd1lIQ0FZR0FBRUFmd0NMQTRFQ0p3QWhBQjFBR2hZUEFnRUFBVUFGQVFBK0FBQUJBR2dDQVFFQlh5UXVFd01SS3lVQk1DY2pOU1lIQmdjQkRnRVVGaGNlQWpNeU53a0JGak15TmpjK0FpNEJBM2YrbndFQkVoVUVBdjZpQlFVRkJRTUhDQVFPQ1FGSUFVd0tEUVlNQlFNRkFRRUZ3d0ZlQVFFUkRRSUQvcDhGREF3TUJBTUVBZ2tCUy82MkNRVUZBd29KQ2drQUFBRUFBQUFCQUFBTEl5bm9Ydzg4OVFBTEJBQUFBQUFBMGdNcWV3QUFBQURTQXlwN0FDTC9iQU84QXhnQUFBQUlBQUlBQUFBQUFBQUFBUUFBQXhqL2JBQmNCQUFBQUFBQUE3d0FBUUFBQUFBQUFBQUFBQUFBQUFBQUFBVUJkZ0FpQUFBQUFBRlZBQUFENlFBc0JBQUFvQUNDQUg4QUFBQW9BQ2dBS0FGa0FhSUI1QUlzQUFFQUFBQUhBRjhBQlFBQUFBQUFBZ0FtQURRQWJBQUFBSW9KbGdBQUFBQUFBQUFNQUpZQUFRQUFBQUFBQVFBSUFBQUFBUUFBQUFBQUFnQUdBQWdBQVFBQUFBQUFBd0FrQUE0QUFRQUFBQUFBQkFBSUFESUFBUUFBQUFBQUJRQkdBRG9BQVFBQUFBQUFCZ0FJQUlBQUF3QUJCQWtBQVFBUUFJZ0FBd0FCQkFrQUFnQU1BSmdBQXdBQkJBa0FBd0JJQUtRQUF3QUJCQWtBQkFBUUFPd0FBd0FCQkFrQUJRQ01BUHdBQXdBQkJBa0FCZ0FRQVlocFkyOXVabTl1ZEUxbFpHbDFiVVp2Ym5SR2IzSm5aU0F5TGpBZ09pQnBZMjl1Wm05dWRDQTZJREkyTFRndE1qQXhOV2xqYjI1bWIyNTBWbVZ5YzJsdmJpQXhMakFnT3lCMGRHWmhkWFJ2YUdsdWRDQW9kakF1T1RRcElDMXNJRGdnTFhJZ05UQWdMVWNnTWpBd0lDMTRJREUwSUMxM0lDSkhJaUF0WmlBdGMybGpiMjVtYjI1MEFHa0FZd0J2QUc0QVpnQnZBRzRBZEFCTkFHVUFaQUJwQUhVQWJRQkdBRzhBYmdCMEFFWUFid0J5QUdjQVpRQWdBRElBTGdBd0FDQUFPZ0FnQUdrQVl3QnZBRzRBWmdCdkFHNEFkQUFnQURvQUlBQXlBRFlBTFFBNEFDMEFNZ0F3QURFQU5RQnBBR01BYndCdUFHWUFid0J1QUhRQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdBQ0FBT3dBZ0FIUUFkQUJtQUdFQWRRQjBBRzhBYUFCcEFHNEFkQUFnQUNnQWRnQXdBQzRBT1FBMEFDa0FJQUF0QUd3QUlBQTRBQ0FBTFFCeUFDQUFOUUF3QUNBQUxRQkhBQ0FBTWdBd0FEQUFJQUF0QUhnQUlBQXhBRFFBSUFBdEFIY0FJQUFpQUVjQUlnQWdBQzBBWmdBZ0FDMEFjd0JwQUdNQWJ3QnVBR1lBYndCdUFIUUFBQUFDQUFBQUFBQUEvNE1BTWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBY0FBQUFCQUFJQVd3RUNBUU1CQkFkMWJtbEZOalV3QjNWdWFVVTJOakVIZFc1cFJUWkVSUUFCQUFILy93QVBBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQXlBRElER1AvaEF4ai9iQU1ZLytFREdQOXNzQUFzc0NCZ1ppMndBU3dnWkNDd3dGQ3dCQ1phc0FSRlcxZ2hJeUViaWxnZ3NGQlFXQ0d3UUZrYklMQTRVRmdoc0RoWldTQ3dDa1ZoWkxBb1VGZ2hzQXBGSUxBd1VGZ2hzREJaR3lDd3dGQllJR1lnaW9waElMQUtVRmhnR3lDd0lGQllJYkFLWUJzZ3NEWlFXQ0d3Tm1BYllGbFpXUnV3QUN0WldTT3dBRkJZWlZsWkxiQUNMQ0JGSUxBRUpXRmtJTEFGUTFCWXNBVWpRckFHSTBJYklTRlpzQUZnTGJBRExDTWhJeUVnWkxFRllrSWdzQVlqUXJJS0FBSXFJU0N3QmtNZ2lpQ0tzQUFyc1RBRkpZcFJXR0JRRzJGU1dWZ2pXU0Vnc0VCVFdMQUFLeHNoc0VCWkk3QUFVRmhsV1Myd0JDeXdDQ05Dc0FjalFyQUFJMEt3QUVPd0IwTlJXTEFJUXl1eUFBRUFRMkJDc0JabEhGa3RzQVVzc0FCRElFVWdzQUpGWTdBQlJXSmdSQzJ3Qml5d0FFTWdSU0N3QUNzanNRUUVKV0FnUllvallTQmtJTEFnVUZnaHNBQWJzREJRV0xBZ0c3QkFXVmtqc0FCUVdHVlpzQU1sSTJGRVJDMndCeXl4QlFWRnNBRmhSQzJ3Q0N5d0FXQWdJTEFLUTBxd0FGQllJTEFLSTBKWnNBdERTckFBVWxnZ3NBc2pRbGt0c0Frc0lMZ0VBR0lndUFRQVk0b2pZYkFNUTJBZ2ltQWdzQXdqUWlNdHNBb3NTMVJZc1FjQlJGa2tzQTFsSTNndHNBc3NTMUZZUzFOWXNRY0JSRmtiSVZra3NCTmxJM2d0c0F3c3NRQU5RMVZZc1EwTlE3QUJZVUt3Q1N0WnNBQkRzQUlsUXJJQUFRQkRZRUt4Q2dJbFFyRUxBaVZDc0FFV0l5Q3dBeVZRV0xBQVE3QUVKVUtLaWlDS0kyR3dDQ29oSTdBQllTQ0tJMkd3Q0NvaEc3QUFRN0FDSlVLd0FpVmhzQWdxSVZtd0NrTkhzQXREUjJDd2dHSWdzQUpGWTdBQlJXSmdzUUFBRXlORXNBRkRzQUErc2dFQkFVTmdRaTJ3RFN5eEFBVkZWRmdBc0EwalFpQmdzQUZodFE0T0FRQU1BRUpDaW1DeERBUXJzR3NyR3lKWkxiQU9MTEVBRFNzdHNBOHNzUUVOS3kyd0VDeXhBZzByTGJBUkxMRUREU3N0c0JJc3NRUU5LeTJ3RXl5eEJRMHJMYkFVTExFR0RTc3RzQlVzc1FjTkt5MndGaXl4Q0EwckxiQVhMTEVKRFNzdHNCZ3NzQWNyc1FBRlJWUllBTEFOSTBJZ1lMQUJZYlVPRGdFQURBQkNRb3Bnc1F3RUs3QnJLeHNpV1Myd0dTeXhBQmdyTGJBYUxMRUJHQ3N0c0Jzc3NRSVlLeTJ3SEN5eEF4Z3JMYkFkTExFRUdDc3RzQjRzc1FVWUt5MndIeXl4QmhnckxiQWdMTEVIR0NzdHNDRXNzUWdZS3kyd0lpeXhDUmdyTGJBakxDQmdzQTVnSUVNanNBRmdRN0FDSmJBQ0pWRllJeUE4c0FGZ0k3QVNaUndiSVNGWkxiQWtMTEFqSzdBaktpMndKU3dnSUVjZ0lMQUNSV093QVVWaVlDTmhPQ01naWxWWUlFY2dJTEFDUldPd0FVVmlZQ05oT0JzaFdTMndKaXl4QUFWRlZGZ0FzQUVXc0NVcXNBRVZNQnNpV1Myd0p5eXdCeXV4QUFWRlZGZ0FzQUVXc0NVcXNBRVZNQnNpV1Myd0tDd2dOYkFCWUMyd0tTd0FzQU5GWTdBQlJXS3dBQ3V3QWtWanNBRkZZckFBSzdBQUZyUUFBQUFBQUVRK0l6aXhLQUVWS2kyd0tpd2dQQ0JISUxBQ1JXT3dBVVZpWUxBQVEyRTRMYkFyTEM0WFBDMndMQ3dnUENCSElMQUNSV093QVVWaVlMQUFRMkd3QVVOak9DMndMU3l4QWdBV0pTQXVJRWV3QUNOQ3NBSWxTWXFLUnlOSEkyRWdXR0liSVZtd0FTTkNzaXdCQVJVVUtpMndMaXl3QUJhd0JDV3dCQ1ZISTBjalliQUdSU3RsaWk0aklDQThpamd0c0M4c3NBQVdzQVFsc0FRbElDNUhJMGNqWVNDd0JDTkNzQVpGS3lDd1lGQllJTEJBVVZpekFpQURJQnV6QWlZREdsbENRaU1nc0FsRElJb2pSeU5ISTJFalJtQ3dCRU93Z0dKZ0lMQUFLeUNLaW1FZ3NBSkRZR1Fqc0FORFlXUlFXTEFDUTJFYnNBTkRZRm13QXlXd2dHSmhJeUFnc0FRbUkwWmhPQnNqc0FsRFJyQUNKYkFKUTBjalJ5TmhZQ0N3QkVPd2dHSmdJeUN3QUNzanNBUkRZTEFBSzdBRkpXR3dCU1d3Z0dLd0JDWmhJTEFFSldCa0k3QURKV0JrVUZnaEd5TWhXU01nSUxBRUppTkdZVGhaTGJBd0xMQUFGaUFnSUxBRkppQXVSeU5ISTJFalBEZ3RzREVzc0FBV0lMQUpJMElnSUNCR0kwZXdBQ3NqWVRndHNESXNzQUFXc0FNbHNBSWxSeU5ISTJHd0FGUllMaUE4SXlFYnNBSWxzQUlsUnlOSEkyRWdzQVVsc0FRbFJ5TkhJMkd3QmlXd0JTVkpzQUlsWWJBQlJXTWpJRmhpR3lGWlk3QUJSV0pnSXk0aklDQThpamdqSVZrdHNETXNzQUFXSUxBSlF5QXVSeU5ISTJFZ1lMQWdZR2F3Z0dJaklDQThpamd0c0RRc0l5QXVSckFDSlVaU1dDQThXUzZ4SkFFVUt5MndOU3dqSUM1R3NBSWxSbEJZSUR4WkxyRWtBUlFyTGJBMkxDTWdMa2F3QWlWR1VsZ2dQRmtqSUM1R3NBSWxSbEJZSUR4WkxyRWtBUlFyTGJBM0xMQXVLeU1nTGthd0FpVkdVbGdnUEZrdXNTUUJGQ3N0c0Rnc3NDOHJpaUFnUExBRUkwS0tPQ01nTGthd0FpVkdVbGdnUEZrdXNTUUJGQ3V3QkVNdXNDUXJMYkE1TExBQUZyQUVKYkFFSmlBdVJ5TkhJMkd3QmtVckl5QThJQzRqT0xFa0FSUXJMYkE2TExFSkJDVkNzQUFXc0FRbHNBUWxJQzVISTBjallTQ3dCQ05Dc0FaRkt5Q3dZRkJZSUxCQVVWaXpBaUFESUJ1ekFpWURHbGxDUWlNZ1I3QUVRN0NBWW1BZ3NBQXJJSXFLWVNDd0FrTmdaQ093QTBOaFpGQllzQUpEWVJ1d0EwTmdXYkFESmJDQVltR3dBaVZHWVRnaklEd2pPQnNoSUNCR0kwZXdBQ3NqWVRnaFdiRWtBUlFyTGJBN0xMQXVLeTZ4SkFFVUt5MndQQ3l3THlzaEl5QWdQTEFFSTBJak9MRWtBUlFyc0FSRExyQWtLeTJ3UFN5d0FCVWdSN0FBSTBLeUFBRUJGUlFUTHJBcUtpMndQaXl3QUJVZ1I3QUFJMEt5QUFFQkZSUVRMckFxS2kyd1B5eXhBQUVVRTdBcktpMndRQ3l3TFNvdHNFRXNzQUFXUlNNZ0xpQkdpaU5oT0xFa0FSUXJMYkJDTExBSkkwS3dRU3N0c0VNc3NnQUFPaXN0c0VRc3NnQUJPaXN0c0VVc3NnRUFPaXN0c0VZc3NnRUJPaXN0c0Vjc3NnQUFPeXN0c0Vnc3NnQUJPeXN0c0Vrc3NnRUFPeXN0c0Vvc3NnRUJPeXN0c0Vzc3NnQUFOeXN0c0V3c3NnQUJOeXN0c0Uwc3NnRUFOeXN0c0U0c3NnRUJOeXN0c0U4c3NnQUFPU3N0c0ZBc3NnQUJPU3N0c0ZFc3NnRUFPU3N0c0ZJc3NnRUJPU3N0c0ZNc3NnQUFQQ3N0c0ZRc3NnQUJQQ3N0c0ZVc3NnRUFQQ3N0c0ZZc3NnRUJQQ3N0c0Zjc3NnQUFPQ3N0c0Znc3NnQUJPQ3N0c0Zrc3NnRUFPQ3N0c0Zvc3NnRUJPQ3N0c0Zzc3NEQXJMckVrQVJRckxiQmNMTEF3SzdBMEt5MndYU3l3TUN1d05Tc3RzRjRzc0FBV3NEQXJzRFlyTGJCZkxMQXhLeTZ4SkFFVUt5MndZQ3l3TVN1d05Dc3RzR0Vzc0RFcnNEVXJMYkJpTExBeEs3QTJLeTJ3WXl5d01pc3VzU1FCRkNzdHNHUXNzRElyc0RRckxiQmxMTEF5SzdBMUt5MndaaXl3TWl1d05pc3RzR2Nzc0RNckxyRWtBUlFyTGJCb0xMQXpLN0EwS3kyd2FTeXdNeXV3TlNzdHNHb3NzRE1yc0RZckxiQnJMQ3V3Q0dXd0F5UlFlTEFCRlRBdEFBQkx1QURJVWxpeEFRR09XYmtJQUFnQVl5Q3dBU05FSUxBREkzQ3dEa1VnSUV1NEFBNVJTN0FHVTFwWXNEUWJzQ2haWUdZZ2lsVllzQUlsWWJBQlJXTWpZckFDSTBTekNna0ZCQ3V6Q2dzRkJDdXpEZzhGQkN0WnNnUW9DVVZTUkxNS0RRWUVLN0VHQVVTeEpBR0lVVml3UUloWXNRWURSTEVtQVloUldMZ0VBSWhZc1FZQlJGbFpXVm00QWYrRnNBU05zUVVBUkFBQUFBPT1cXFwiKSBmb3JtYXQoXFxcInRydWV0eXBlXFxcIik7XFxufVxcbi5pY29uZm9udCB7XFxuICBmb250LWZhbWlseTogaWNvbmZvbnQgIWltcG9ydGFudDtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbiAgLXdlYmtpdC10ZXh0LXN0cm9rZS13aWR0aDogMC4ycHg7XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjJcXFwiXSAudGFiLWhlYWRlciB7XFxuICBmb250LXNpemU6IDI4cHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiM1xcXCJdIC50YWItaGVhZGVyIHtcXG4gIGZvbnQtc2l6ZTogNDJweDtcXG59XFxuXFxuW2RhdGEtZHByPVxcXCIyXFxcIl0gLnRhYmhlYWRlciAuaGwtaWNvbiB7XFxuICBmb250LXNpemU6IDI4cHg7XFxufVxcblxcbltkYXRhLWRwcj1cXFwiM1xcXCJdIC50YWJoZWFkZXIgLmhsLWljb24ge1xcbiAgZm9udC1zaXplOiA0MnB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjJcXFwiXSAudGFiLWhlYWRlciAuZm9sZC10b2dnbGUge1xcbiAgZm9udC1zaXplOiAyOHB4O1xcbn1cXG5cXG5bZGF0YS1kcHI9XFxcIjNcXFwiXSAudGFiLWhlYWRlciAuZm9sZC10b2dnbGUge1xcbiAgZm9udC1zaXplOiA0MnB4O1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvdGFiaGVhZGVyLmNzc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuLi9zdHlsZXMvc2Nyb2xsZXIuY3NzJylcbnJlcXVpcmUoJy4uL3Njcm9sbCcpXG5cbi8vIGxpYi5zY3JvbGwgZXZlbnRzOlxuLy8gIC0gc2Nyb2xsc3RhcnRcbi8vICAtIHNjcm9sbGluZ1xuLy8gIC0gcHVsbGRvd25lbmRcbi8vICAtIHB1bGx1cGVuZFxuLy8gIC0gcHVsbGxlZnRlbmRcbi8vICAtIHB1bGxyaWdodGVuZFxuLy8gIC0gcHVsbGRvd25cbi8vICAtIHB1bGx1cFxuLy8gIC0gcHVsbGxlZnRcbi8vICAtIHB1bGxyaWdodFxuLy8gIC0gY29udGVudHJlZnJlc2hcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50JylcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJylcblxudmFyIGRpcmVjdGlvbk1hcCA9IHtcbiAgaDogWydyb3cnLCAnaG9yaXpvbnRhbCcsICdoJywgJ3gnXSxcbiAgdjogWydjb2x1bW4nLCAndmVydGljYWwnLCAndicsICd5J11cbn1cblxudmFyIERFRkFVTFRfRElSRUNUSU9OID0gJ2NvbHVtbidcblxuLy8gYXR0cnM6XG4vLyAgLSBzY3JvbGwtZGlyZWNpdG9uOiBub25lfHZlcnRpY2FsfGhvcml6b250YWwgKGRlZmF1bHQgaXMgdmVydGljYWwpXG4vLyAgLSBzaG93LXNjcm9sbGJhcjogdHJ1ZXxmYWxzZSAoZGVmYXVsdCBpcyB0cnVlKVxuZnVuY3Rpb24gU2Nyb2xsZXIgKGRhdGEsIG5vZGVUeXBlKSB7XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0ciB8fCB7fVxuICB2YXIgZGlyZWN0aW9uID0gYXR0cnMuc2Nyb2xsRGlyZWN0aW9uXG4gICAgfHwgYXR0cnMuZGlyZWN0aW9uXG4gICAgfHwgREVGQVVMVF9ESVJFQ1RJT05cbiAgdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb25NYXAuaC5pbmRleE9mKGRpcmVjdGlvbikgPT09IC0xXG4gICAgPyAndidcbiAgICA6ICdoJ1xuICB0aGlzLnNob3dTY3JvbGxiYXIgPSBhdHRycy5zaG93U2Nyb2xsYmFyIHx8IHRydWVcbiAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSwgbm9kZVR5cGUpXG59XG5cblNjcm9sbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSlcblxuU2Nyb2xsZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChub2RlVHlwZSkge1xuICB2YXIgU2Nyb2xsID0gbGliLnNjcm9sbFxuICB2YXIgbm9kZSA9IENvbXBvbmVudC5wcm90b3R5cGUuY3JlYXRlLmNhbGwodGhpcywgbm9kZVR5cGUpXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInLCAnc2Nyb2xsLXdyYXAnKVxuICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICB0aGlzLnNjcm9sbEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcbiAgICAnd2VleC1jb250YWluZXInLFxuICAgICdzY3JvbGwtZWxlbWVudCcsXG4gICAgdGhpcy5kaXJlY3Rpb24gKyAnLXNjcm9sbGVyJ1xuICApXG5cbiAgLy8gRmxleCB3aWxsIGNhdXNlIGEgYnVnIHRvIHJlc2NhbGUgY2hpbGRyZW4ncyBzaXplIGlmIHRoZWlyIHRvdGFsXG4gIC8vIHNpemUgZXhjZWVkIHRoZSBsaW1pdCBvZiB0aGVpciBwYXJlbnQuIFNvIHRvIHVzZSBib3ggaW5zdGVhZC5cbiAgdGhpcy5zY3JvbGxFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnLXdlYmtpdC1ib3gnXG4gIHRoaXMuc2Nyb2xsRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2JveCdcbiAgdGhpcy5zY3JvbGxFbGVtZW50LnN0eWxlLndlYmtpdEJveE9yaWVudCA9IHRoaXMuZGlyZWN0aW9uID09PSAnaCdcbiAgICA/ICdob3Jpem9udGFsJ1xuICAgIDogJ3ZlcnRpY2FsJ1xuICB0aGlzLnNjcm9sbEVsZW1lbnQuc3R5bGUuYm94T3JpZW50ID0gdGhpcy5zY3JvbGxFbGVtZW50LnN0eWxlLndlYmtpdEJveE9yaWVudFxuXG4gIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxFbGVtZW50KVxuICB0aGlzLnNjcm9sbGVyID0gbmV3IFNjcm9sbCh7XG4gICAgLy8gaWYgdGhlIGRpcmVjdGlvbiBpcyB4LCB0aGVuIHRoZSBib3VuZGluZyByZWN0IG9mIHRoZSBzY3JvbGwgZWxlbWVudFxuICAgIC8vIHNob3VsZCBiZSBnb3QgYnkgdGhlICdSYW5nZScgQVBJIG90aGVyIHRoYW4gdGhlICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnXG4gICAgLy8gQVBJLCBiZWNhdXNlIHRoZSB3aWR0aCBvdXRzaWRlIHRoZSB2aWV3cG9ydCB3b24ndCBiZSBjb3VudCBpbiBieVxuICAgIC8vICdnZXRCb3VuZGluZ0NsaWVudFJlY3QnLlxuICAgIC8vIE90aGVyd2lzZSBzaG91bGQgdXNlIHRoZSBlbGVtZW50IHJlY3QgaW4gY2FzZSB0aGVyZSBpcyBhIGNoaWxkIHNjcm9sbGVyXG4gICAgLy8gb3IgbGlzdCBpbiB0aGlzIHNjcm9sbGVyLiBJZiB1c2luZyAnUmFuZ2UnLCB0aGUgd2hvbGUgc2Nyb2xsIGVsZW1lbnRcbiAgICAvLyBpbmNsdWRpbmcgdGhlIGhpZGluZyBwYXJ0IHdpbGwgYmUgY291bnQgaW4gdGhlIHJlY3QuXG4gICAgdXNlRWxlbWVudFJlY3Q6IHRoaXMuZGlyZWN0aW9uID09PSAndicsXG4gICAgc2Nyb2xsRWxlbWVudDogdGhpcy5zY3JvbGxFbGVtZW50LFxuICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24gPT09ICdoJyA/ICd4JyA6ICd5J1xuICB9KVxuICB0aGlzLnNjcm9sbGVyLmluaXQoKVxuICB0aGlzLm9mZnNldCA9IDBcbiAgcmV0dXJuIG5vZGVcbn1cblxuU2Nyb2xsZXIucHJvdG90eXBlLmJpbmRFdmVudHMgPSBmdW5jdGlvbiAoZXZ0cykge1xuICBDb21wb25lbnQucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbCh0aGlzLCBldnRzKVxuICAvLyB0byBlbmFibGUgbGF6eWxvYWQgZm9yIEltYWdlc1xuICB0aGlzLnNjcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbGluZycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvID0gZS5zY3JvbGxPYmpcbiAgICB2YXIgc2Nyb2xsVG9wID0gc28uZ2V0U2Nyb2xsVG9wKClcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IHNvLmdldFNjcm9sbExlZnQoKVxuICAgIHZhciBvZmZzZXQgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3YnID8gc2Nyb2xsVG9wIDogc2Nyb2xsTGVmdFxuICAgIHZhciBkaWZmID0gb2Zmc2V0IC0gdGhpcy5vZmZzZXRcbiAgICB2YXIgZGlyXG4gICAgaWYgKGRpZmYgPj0gMCkge1xuICAgICAgZGlyID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2JyA/ICd1cCcgOiAnbGVmdCdcbiAgICB9IGVsc2Uge1xuICAgICAgZGlyID0gdGhpcy5kaXJlY3Rpb24gPT09ICd2JyA/ICdkb3duJyA6ICdyaWdodCdcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdzY3JvbGwnLCB7XG4gICAgICBvcmlnaW5hbFR5cGU6ICdzY3JvbGxpbmcnLFxuICAgICAgc2Nyb2xsVG9wOiBzby5nZXRTY3JvbGxUb3AoKSxcbiAgICAgIHNjcm9sbExlZnQ6IHNvLmdldFNjcm9sbExlZnQoKSxcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgZGlyZWN0aW9uOiBkaXJcbiAgICB9LCB7XG4gICAgICBidWJibGVzOiB0cnVlXG4gICAgfSlcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldFxuICB9LmJpbmQodGhpcykpXG5cbiAgdmFyIHB1bGxlbmRFdmVudCA9ICdwdWxsJ1xuICAgICsgKHsgdjogJ3VwJywgaDogJ2xlZnQnIH0pW3RoaXMuZGlyZWN0aW9uXVxuICAgICsgJ2VuZCdcbiAgdGhpcy5zY3JvbGxlci5hZGRFdmVudExpc3RlbmVyKHB1bGxlbmRFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2xvYWRtb3JlJylcbiAgfS5iaW5kKHRoaXMpKVxufVxuXG5TY3JvbGxlci5wcm90b3R5cGUuY3JlYXRlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICB2YXIgcGFyZW50UmVmID0gdGhpcy5kYXRhLnJlZlxuICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICB2YXIgaXNGbGV4ID0gZmFsc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5pbnN0YW5jZUlkID0gdGhpcy5kYXRhLmluc3RhbmNlSWRcbiAgICAgIGNoaWxkcmVuW2ldLnNjYWxlID0gdGhpcy5kYXRhLnNjYWxlXG4gICAgICB2YXIgY2hpbGQgPSBjb21wb25lbnRNYW5hZ2VyLmNyZWF0ZUVsZW1lbnQoY2hpbGRyZW5baV0pXG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZC5ub2RlKVxuICAgICAgY2hpbGQucGFyZW50UmVmID0gcGFyZW50UmVmXG4gICAgICBpZiAoIWlzRmxleFxuICAgICAgICAgICYmIGNoaWxkLmRhdGEuc3R5bGVcbiAgICAgICAgICAmJiBjaGlsZC5kYXRhLnN0eWxlLmhhc093blByb3BlcnR5KCdmbGV4JylcbiAgICAgICAgKSB7XG4gICAgICAgIGlzRmxleCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KVxuICB9XG4gIC8vIHdhaXQgZm9yIGZyYWdtZW50IHRvIGFwcGVuZGVkIG9uIHNjcm9sbEVsZW1lbnQgb24gVUkgdGhyZWFkLlxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjcm9sbGVyLnJlZnJlc2goKVxuICB9LmJpbmQodGhpcyksIDApXG59XG5cblNjcm9sbGVyLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gIHZhciBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChkYXRhKVxuICB0aGlzLnNjcm9sbEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcblxuICAvLyB3YWl0IGZvciBVSSB0aHJlYWQgdG8gdXBkYXRlLlxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjcm9sbGVyLnJlZnJlc2goKVxuICB9LmJpbmQodGhpcyksIDApXG5cbiAgLy8gdXBkYXRlIHRoaXMuZGF0YS5jaGlsZHJlblxuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB0aGlzLmRhdGEuY2hpbGRyZW4gPSBbZGF0YV1cbiAgfSBlbHNlIHtcbiAgICBjaGlsZHJlbi5wdXNoKGRhdGEpXG4gIH1cblxuICByZXR1cm4gY2hpbGRcbn1cblxuU2Nyb2xsZXIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChjaGlsZCwgYmVmb3JlKSB7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICB2YXIgaSA9IDBcbiAgdmFyIGlzQXBwZW5kID0gZmFsc2VcblxuICAvLyB1cGRhdGUgdGhpcy5kYXRhLmNoaWxkcmVuXG4gIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCAhYmVmb3JlKSB7XG4gICAgaXNBcHBlbmQgPSB0cnVlXG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGNoaWxkcmVuW2ldLnJlZiA9PT0gYmVmb3JlLmRhdGEucmVmKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBsKSB7XG4gICAgICBpc0FwcGVuZCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBpZiAoaXNBcHBlbmQpIHtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQuYXBwZW5kQ2hpbGQoY2hpbGQubm9kZSlcbiAgICBjaGlsZHJlbi5wdXNoKGNoaWxkLmRhdGEpXG4gIH0gZWxzZSB7XG4gICAgaWYgKGJlZm9yZS5maXhlZFBsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLm5vZGUsIGJlZm9yZS5maXhlZFBsYWNlaG9sZGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLm5vZGUsIGJlZm9yZS5ub2RlKVxuICAgIH1cbiAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMCwgY2hpbGQuZGF0YSlcbiAgfVxuXG4gIC8vIHdhaXQgZm9yIFVJIHRocmVhZCB0byB1cGRhdGUuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2Nyb2xsZXIucmVmcmVzaCgpXG4gIH0uYmluZCh0aGlzKSwgMClcbn1cblxuU2Nyb2xsZXIucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICAvLyByZW1vdmUgZnJvbSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgdmFyIGkgPSAwXG4gIHZhciBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS5yZWYgPT09IGNoaWxkLmRhdGEucmVmKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpIDwgbCkge1xuICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpXG4gICAgfVxuICB9XG4gIC8vIHJlbW92ZSBmcm9tIGNvbXBvbmVudE1hcCByZWN1cnNpdmVseVxuICBjb21wb25lbnRNYW5hZ2VyLnJlbW92ZUVsZW1lbnRCeVJlZihjaGlsZC5kYXRhLnJlZilcbiAgaWYgKGNoaWxkLmZpeGVkUGxhY2Vob2xkZXIpIHtcbiAgICB0aGlzLnNjcm9sbEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGQuZml4ZWRQbGFjZWhvbGRlcilcbiAgfVxuICBjaGlsZC5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQubm9kZSlcblxuICAvLyB3YWl0IGZvciBVSSB0aHJlYWQgdG8gdXBkYXRlLlxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNjcm9sbGVyLnJlZnJlc2goKVxuICB9LmJpbmQodGhpcyksIDApXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsZXJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvc2Nyb2xsZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc2Nyb2xsZXIuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zY3JvbGxlci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3Njcm9sbGVyLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3Njcm9sbGVyLmNzc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuc2Nyb2xsLXdyYXAge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5cXG4uc2Nyb2xsLWVsZW1lbnQuaG9yaXpvbnRhbCB7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IGhvcml6b250YWw7XFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbn1cXG4uc2Nyb2xsLWVsZW1lbnQudmVydGljYWwge1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9zY3JvbGxlci5jc3NcbiAqKiBtb2R1bGUgaWQgPSA2OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIEF0b21pYyA9IHJlcXVpcmUoJy4vYXRvbWljJylcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJylcblxuLy8gYXR0cnM6XG4vLyAgIC0gdHlwZTogdGV4dHxwYXNzd29yZHx0ZWx8ZW1haWx8dXJsXG4vLyAgIC0gdmFsdWVcbi8vICAgLSBwbGFjZWhvbGRlclxuLy8gICAtIGRpc2FibGVkXG4vLyAgIC0gYXV0b2ZvY3VzXG5mdW5jdGlvbiBJbnB1dCAoZGF0YSkge1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHIgfHwge31cbiAgdGhpcy50eXBlID0gYXR0cnMudHlwZSB8fCAndGV4dCdcbiAgdGhpcy52YWx1ZSA9IGF0dHJzLnZhbHVlXG4gIHRoaXMucGxhY2Vob2xkZXIgPSBhdHRycy5wbGFjZWhvbGRlclxuICB0aGlzLmF1dG9mb2N1cyA9IGF0dHJzLmF1dG9mb2N1cyAmJiAoYXR0cnMuYXV0b2ZvY3VzICE9PSAnZmFsc2UnKVxuICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgOiBmYWxzZVxuICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxufVxuXG5JbnB1dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG5cbklucHV0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICB2YXIgdXVpZCA9IE1hdGguZmxvb3IoMTAwMDAwMDAwMDAwMDAgKiBNYXRoLnJhbmRvbSgpKSArIERhdGUubm93KClcbiAgdGhpcy5jbGFzc05hbWUgPSAnd2VleC1pcHQtJyArIHV1aWRcbiAgdGhpcy5zdHlsZUlkID0gJ3dlZXgtc3R5bGUtJyArIHV1aWRcbiAgbm9kZS5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lKVxuICBub2RlLnNldEF0dHJpYnV0ZSgndHlwZScsIHRoaXMudHlwZSlcbiAgbm9kZS50eXBlID0gdGhpcy50eXBlXG4gIC8vIEZvciB0aGUgY29uc2lzdGVuY3kgb2YgaW5wdXQgY29tcG9uZW50J3Mgd2lkdGguXG4gIC8vIFRoZSBkYXRlIGFuZCB0aW1lIHR5cGUgb2YgaW5wdXQgd2lsbCBoYXZlIGEgYmlnZ2VyIHdpZHRoXG4gIC8vIHdoZW4gdGhlICdib3gtc2l6aW5nJyBpcyBub3Qgc2V0IHRvICdib3JkZXItYm94J1xuICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtZWxlbWVudCcpXG4gIHRoaXMudmFsdWUgJiYgKG5vZGUudmFsdWUgPSB0aGlzLnZhbHVlKVxuICB0aGlzLnBsYWNlaG9sZGVyICYmIChub2RlLnBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlcilcbiAgcmV0dXJuIG5vZGVcbn1cblxuSW5wdXQucHJvdG90eXBlLnVwZGF0ZVN0eWxlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gIEF0b21pYy5wcm90b3R5cGUudXBkYXRlU3R5bGUuY2FsbCh0aGlzLCBzdHlsZSlcbiAgaWYgKHN0eWxlICYmIHN0eWxlLnBsYWNlaG9sZGVyQ29sb3IpIHtcbiAgICB0aGlzLnBsYWNlaG9sZGVyQ29sb3IgPSBzdHlsZS5wbGFjZWhvbGRlckNvbG9yXG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlckNvbG9yKClcbiAgfVxufVxuXG5JbnB1dC5wcm90b3R5cGUuYXR0ciA9IHtcbiAgZGlzYWJsZWQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLm5vZGUuZGlzYWJsZWQgPSB2YWwgJiYgdmFsICE9PSAnZmFsc2UnXG4gICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlXG4gIH1cbn1cblxuSW5wdXQucHJvdG90eXBlLnNldFBsYWNlaG9sZGVyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5wbGFjZWhvbGRlckNvbG9yKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZlbmRvcnMgPSBbXG4gICAgJzo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcicsXG4gICAgJzotbW96LXBsYWNlaG9sZGVyJyxcbiAgICAnOjotbW96LXBsYWNlaG9sZGVyJyxcbiAgICAnOi1tcy1pbnB1dC1wbGFjZWhvbGRlcicsXG4gICAgJzpwbGFjZWhvbGRlci1zaG93bidcbiAgXVxuICB2YXIgY3NzID0gJydcbiAgdmFyIGNzc1J1bGUgPSAnY29sb3I6ICcgKyB0aGlzLnBsYWNlaG9sZGVyQ29sb3IgKyAnOydcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2ZW5kb3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNzcyArPSAnLicgKyB0aGlzLmNsYXNzTmFtZSArIHZlbmRvcnNbaV0gKyAneydcbiAgICAgICAgICAgKyBjc3NSdWxlICsgJ30nXG4gIH1cbiAgdXRpbHMuYXBwZW5kU3R5bGUoY3NzLCB0aGlzLnN0eWxlSWQsIHRydWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSW5wdXRcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvaW5wdXQuanNcbiAqKiBtb2R1bGUgaWQgPSA3MFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIEF0b21pYyA9IHJlcXVpcmUoJy4vY29tcG9uZW50JylcbnZhciBzZW5kZXIgPSByZXF1aXJlKCcuLi9icmlkZ2Uvc2VuZGVyJylcblxuLy8gYXR0cnM6XG4vLyAgIC0gb3B0aW9uczogdGhlIG9wdGlvbnMgdG8gYmUgbGlzdGVkLCBhcyBhIGFycmF5IG9mIHN0cmluZ3MuXG4vLyAgIC0gc2VsZWN0ZWRJbmRleDogdGhlIHNlbGVjdGVkIG9wdGlvbnMnIGluZGV4IG51bWJlci5cbi8vICAgLSBkaXNhYmxlZFxuZnVuY3Rpb24gU2VsZWN0IChkYXRhKSB7XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0ciB8fCB7fVxuICB0aGlzLm9wdGlvbnMgPSBbXVxuICB0aGlzLnNlbGVjdGVkSW5kZXggPSAwXG4gIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG59XG5cblNlbGVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG5cblNlbGVjdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpXG4gIHZhciB1dWlkID0gTWF0aC5mbG9vcigxMDAwMDAwMDAwMDAwMCAqIE1hdGgucmFuZG9tKCkpICsgRGF0ZS5ub3coKVxuICB0aGlzLmNsYXNzTmFtZSA9ICd3ZWV4LXNsY3QtJyArIHV1aWRcbiAgdGhpcy5zdHlsZUlkID0gJ3dlZXgtc3R5bGUtJyArIHV1aWRcbiAgbm9kZS5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lKVxuICAvLyBGb3IgdGhlIGNvbnNpc3RlbmN5IG9mIGlucHV0IGNvbXBvbmVudCdzIHdpZHRoLlxuICAvLyBUaGUgZGF0ZSBhbmQgdGltZSB0eXBlIG9mIGlucHV0IHdpbGwgaGF2ZSBhIGJpZ2dlciB3aWR0aFxuICAvLyB3aGVuIHRoZSAnYm94LXNpemluZycgaXMgbm90IHNldCB0byAnYm9yZGVyLWJveCdcbiAgbm9kZS5zdHlsZVsnYm94LXNpemluZyddID0gJ2JvcmRlci1ib3gnXG4gIHJldHVybiBub2RlXG59XG5cblNlbGVjdC5wcm90b3R5cGUuYXR0ciA9IHtcbiAgZGlzYWJsZWQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLm5vZGUuZGlzYWJsZWQgPSB2YWwgJiYgdmFsICE9PSAnZmFsc2UnXG4gICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlXG4gIH0sXG4gIG9wdGlvbnM6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSB2YWxcbiAgICB0aGlzLm5vZGUuaW5uZXJIVE1MID0gJydcbiAgICB0aGlzLmNyZWF0ZU9wdGlvbnModmFsKVxuICB9LFxuICBzZWxlY3RlZEluZGV4OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VJbnQodmFsKVxuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJyB8fCB2YWwgIT09IHZhbCB8fCB2YWwgPj0gdGhpcy5vcHRpb25zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMubm9kZS52YWx1ZSA9IHRoaXMub3B0aW9uc1t2YWxdXG4gIH1cbn1cblxuU2VsZWN0LnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKGV2dHMpIHtcbiAgdmFyIGlzTGlzdGVuVG9DaGFuZ2UgPSBmYWxzZVxuICBBdG9taWMucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICBldnRzLmZpbHRlcihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciBwYXNzID0gdmFsICE9PSAnY2hhbmdlJ1xuICAgICAgICAhcGFzcyAmJiAoaXNMaXN0ZW5Ub0NoYW5nZSA9IHRydWUpXG4gICAgICAgIHJldHVybiBwYXNzXG4gICAgICB9KSlcbiAgaWYgKGlzTGlzdGVuVG9DaGFuZ2UpIHtcbiAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUuaW5kZXggPSB0aGlzLm9wdGlvbnMuaW5kZXhPZih0aGlzLm5vZGUudmFsdWUpXG4gICAgICBzZW5kZXIuZmlyZUV2ZW50KHRoaXMuZGF0YS5yZWYsICdjaGFuZ2UnLCBlKVxuICAgIH0uYmluZCh0aGlzKSlcbiAgfVxufVxuXG5TZWxlY3QucHJvdG90eXBlLmNyZWF0ZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgb3B0RG9jID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIHZhciBvcHRcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpXG4gICAgb3B0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG9wdHNbaV0pKVxuICAgIG9wdERvYy5hcHBlbmRDaGlsZChvcHQpXG4gIH1cbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKG9wdERvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvc2VsZWN0LmpzXG4gKiogbW9kdWxlIGlkID0gNzFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBBdG9taWMgPSByZXF1aXJlKCcuL2F0b21pYycpXG5cbi8vIGF0dHJzOlxuLy8gICAtIHZhbHVlXG4vLyAgIC0gZGlzYWJsZWRcbmZ1bmN0aW9uIERhdGVwaWNrZXIgKGRhdGEpIHtcbiAgQXRvbWljLmNhbGwodGhpcywgZGF0YSlcbn1cblxuRGF0ZXBpY2tlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG5cbkRhdGVwaWNrZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gIHZhciB1dWlkID0gTWF0aC5mbG9vcigxMDAwMDAwMDAwMDAwMCAqIE1hdGgucmFuZG9tKCkpICsgRGF0ZS5ub3coKVxuICB0aGlzLmNsYXNzTmFtZSA9ICd3ZWV4LWlwdC0nICsgdXVpZFxuICB0aGlzLnN0eWxlSWQgPSAnd2VleC1zdHlsZS0nICsgdXVpZFxuICBub2RlLmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWUpXG4gIG5vZGUuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2RhdGUnKVxuICBub2RlLnR5cGUgPSAnZGF0ZSdcbiAgLy8gRm9yIHRoZSBjb25zaXN0ZW5jeSBvZiBpbnB1dCBjb21wb25lbnQncyB3aWR0aC5cbiAgLy8gVGhlIGRhdGUgYW5kIHRpbWUgdHlwZSBvZiBpbnB1dCB3aWxsIGhhdmUgYSBiaWdnZXIgd2lkdGhcbiAgLy8gd2hlbiB0aGUgJ2JveC1zaXppbmcnIGlzIG5vdCBzZXQgdG8gJ2JvcmRlci1ib3gnXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1lbGVtZW50JylcbiAgcmV0dXJuIG5vZGVcbn1cblxuRGF0ZXBpY2tlci5wcm90b3R5cGUuYXR0ciA9IHtcbiAgZGlzYWJsZWQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLm5vZGUuZGlzYWJsZWQgPSB2YWwgJiYgdmFsICE9PSAnZmFsc2UnXG4gICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRlcGlja2VyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2RhdGVwaWNrZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIEF0b21pYyA9IHJlcXVpcmUoJy4vYXRvbWljJylcblxuLy8gYXR0cnM6XG4vLyAgIC0gdmFsdWVcbi8vICAgLSBkaXNhYmxlZFxuZnVuY3Rpb24gVGltZXBpY2tlciAoZGF0YSkge1xuICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxufVxuXG5UaW1lcGlja2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcblxuVGltZXBpY2tlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgdmFyIHV1aWQgPSBNYXRoLmZsb29yKDEwMDAwMDAwMDAwMDAwICogTWF0aC5yYW5kb20oKSkgKyBEYXRlLm5vdygpXG4gIHRoaXMuY2xhc3NOYW1lID0gJ3dlZXgtaXB0LScgKyB1dWlkXG4gIHRoaXMuc3R5bGVJZCA9ICd3ZWV4LXN0eWxlLScgKyB1dWlkXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZSlcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGltZScpXG4gIG5vZGUudHlwZSA9ICd0aW1lJ1xuICAvLyBGb3IgdGhlIGNvbnNpc3RlbmN5IG9mIGlucHV0IGNvbXBvbmVudCdzIHdpZHRoLlxuICAvLyBUaGUgZGF0ZSBhbmQgdGltZSB0eXBlIG9mIGlucHV0IHdpbGwgaGF2ZSBhIGJpZ2dlciB3aWR0aFxuICAvLyB3aGVuIHRoZSAnYm94LXNpemluZycgaXMgbm90IHNldCB0byAnYm9yZGVyLWJveCdcbiAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWVsZW1lbnQnKVxuICByZXR1cm4gbm9kZVxufVxuXG5UaW1lcGlja2VyLnByb3RvdHlwZS5hdHRyID0ge1xuICBkaXNhYmxlZDogZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMubm9kZS5kaXNhYmxlZCA9IHZhbCAmJiB2YWwgIT09ICdmYWxzZSdcbiAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVwaWNrZXJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvdGltZXBpY2tlci5qc1xuICoqIG1vZHVsZSBpZCA9IDczXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQXRvbWljID0gcmVxdWlyZSgnLi9hdG9taWMnKVxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKVxucmVxdWlyZSgnLi4vc3R5bGVzL3ZpZGVvLmNzcycpXG5cbi8vIGF0dHJzOlxuLy8gICAtIGF1dG9QbGF5OiB0cnVlIHwgZmFsc2UgKGRlZmF1bHQ6IGZhbHNlKVxuLy8gICAtIHBsYXlTdGF0dXM6IHBsYXkgfCBwYXVzZSB8IHN0b3Bcbi8vICAgLSBzcmM6IHtzdHJpbmd9XG4vLyAgIC0gcG9zdGVyOiB7c3RyaW5nfVxuLy8gICAtIGxvb3A6IHRydWUgfCBmYWxzZSAoZGVmYXVsdDogZmFsc2UpXG4vLyAgIC0gbXV0ZWQ6IHRydWUgfCBmYWxzZSAoZGVmYXVsdDogZmFsc2UpXG4vLyBldmVudHM6XG4vLyAgIC0gc3RhcnRcbi8vICAgLSBwYXVzZVxuLy8gICAtIGZpbmlzaFxuLy8gICAtIGZhaWxcbmZ1bmN0aW9uIFZpZGVvIChkYXRhKSB7XG4gIHZhciBhdXRvUGxheSA9IGRhdGEuYXR0ci5hdXRvUGxheVxuICB2YXIgcGxheVN0YXR1cyA9IGRhdGEuYXR0ci5wbGF5U3RhdHVzXG4gIHRoaXMuYXV0b1BsYXkgPSBhdXRvUGxheSA9PT0gdHJ1ZSB8fCBhdXRvUGxheSA9PT0gJ3RydWUnXG4gIGlmIChwbGF5U3RhdHVzICE9PSAncGxheSdcbiAgICAgICYmIHBsYXlTdGF0dXMgIT09ICdzdG9wJ1xuICAgICAgJiYgcGxheVN0YXR1cyAhPT0gJ3BhdXNlJykge1xuICAgIHRoaXMucGxheVN0YXR1cyA9ICdwYXVzZSdcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBsYXlTdGF0dXMgPSBwbGF5U3RhdHVzXG4gIH1cbiAgQXRvbWljLmNhbGwodGhpcywgZGF0YSlcbn1cblxuVmlkZW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlKVxuXG5WaWRlby5wcm90b3R5cGUuYXR0ciA9IHtcbiAgcGxheVN0YXR1czogZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICh2YWwgIT09ICdwbGF5JyAmJiB2YWwgIT09ICdzdG9wJyAmJiB2YWwgIT09ICdwYXVzZScpIHtcbiAgICAgIHZhbCA9ICdwYXVzZSdcbiAgICB9XG4gICAgaWYgKHRoaXMucGxheVN0YXR1cyA9PT0gdmFsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5wbGF5U3RhdHVzID0gdmFsXG4gICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgncGxheS1zdGF0dXMnLCB2YWwpXG4gICAgdGhpc1t0aGlzLnBsYXlTdGF0dXNdKClcbiAgfSxcbiAgYXV0b1BsYXk6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBETyBOT1RISU5HXG4gIH1cbn1cblxuVmlkZW8ucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC12aWRlbycsICd3ZWV4LWVsZW1lbnQnKVxuICBub2RlLmNvbnRyb2xzID0gdHJ1ZVxuICBub2RlLmF1dG9wbGF5ID0gdGhpcy5hdXRvUGxheVxuICBub2RlLnNldEF0dHJpYnV0ZSgncGxheS1zdGF0dXMnLCB0aGlzLnBsYXlTdGF0dXMpXG4gIHRoaXMubm9kZSA9IG5vZGVcbiAgaWYgKHRoaXMuYXV0b1BsYXkgJiYgdGhpcy5wbGF5U3RhdHVzID09PSAncGxheScpIHtcbiAgICB0aGlzLnBsYXkoKVxuICB9XG4gIHJldHVybiBub2RlXG59XG5cblZpZGVvLnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKGV2dHMpIHtcbiAgQXRvbWljLnByb3RvdHlwZS5iaW5kRXZlbnRzLmNhbGwodGhpcywgZXZ0cylcblxuICAvLyBjb252ZXJ0IHczYy12aWRlbyBldmVudHMgdG8gd2VleC12aWRlbyBldmVudHMuXG4gIHZhciBldnRzTWFwID0ge1xuICAgIHN0YXJ0OiAncGxheScsXG4gICAgZmluaXNoOiAnZW5kZWQnLFxuICAgIGZhaWw6ICdlcnJvcidcbiAgfVxuICBmb3IgKHZhciBldnROYW1lIGluIGV2dHNNYXApIHtcbiAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRzTWFwW2V2dE5hbWVdLCBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHR5cGUsIGUuZGF0YSlcbiAgICB9LmJpbmQodGhpcywgZXZ0TmFtZSkpXG4gIH1cbn1cblxuVmlkZW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzcmMgPSB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICBpZiAoIXNyYykge1xuICAgIHNyYyA9IHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJylcbiAgICBzcmMgJiYgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnc3JjJywgc3JjKVxuICB9XG4gIHRoaXMubm9kZS5wbGF5KClcbn1cblxuVmlkZW8ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5vZGUucGF1c2UoKVxufVxuXG5WaWRlby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ub2RlLnBhdXNlKClcbiAgdGhpcy5ub2RlLmF1dG9wbGF5ID0gZmFsc2VcbiAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1zcmMnLCB0aGlzLm5vZGUuc3JjKVxuICB0aGlzLm5vZGUuc3JjID0gJydcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWaWRlb1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy92aWRlby5qc1xuICoqIG1vZHVsZSBpZCA9IDc0XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi92aWRlby5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3ZpZGVvLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdmlkZW8uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvdmlkZW8uY3NzXG4gKiogbW9kdWxlIGlkID0gNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi53ZWV4LXZpZGVvIHtcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvdmlkZW8uY3NzXG4gKiogbW9kdWxlIGlkID0gNzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBBdG9taWMgPSByZXF1aXJlKCcuL2F0b21pYycpXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG5yZXF1aXJlKCcuLi9zdHlsZXMvc3dpdGNoLmNzcycpXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgY29sb3I6ICcjNjRiZDYzJ1xuICAsIHNlY29uZGFyeUNvbG9yOiAnI2RmZGZkZidcbiAgLCBqYWNrQ29sb3I6ICcjZmZmJ1xuICAsIGphY2tTZWNvbmRhcnlDb2xvcjogbnVsbFxuICAsIGNsYXNzTmFtZTogJ3dlZXgtc3dpdGNoJ1xuICAsIGRpc2FibGVkT3BhY2l0eTogMC41XG4gICwgc3BlZWQ6ICcwLjRzJ1xuICAsIHdpZHRoOiAxMDBcbiAgLCBoZWlnaHQ6IDYwXG4gIC8vIGlzIHdpZHRoIGFuZCBoZWlnaHQgc2NhbGFibGUgP1xuICAsIHNjYWxhYmxlOiBmYWxzZVxufVxuXG4vLyBhdHRyczpcbi8vICAgLSBjaGVja2VkOiBpZiBpcyBjaGVja2VkLlxuLy8gICAtIGRpc2FibGVkOiBpZiB0cnVlLCB0aGlzIGNvbXBvbmVudCBpcyBub3QgYXZhaWxhYmxlIGZvciBpbnRlcmFjdGlvbi5cbmZ1bmN0aW9uIFN3aXRjaCAoZGF0YSkge1xuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5leHRlbmQoe30sIGRlZmF1bHRzKVxuICB0aGlzLmNoZWNrZWQgPSBkYXRhLmF0dHIuY2hlY2tlZFxuICAgICAgJiYgZGF0YS5hdHRyLmNoZWNrZWQgIT09ICdmYWxzZScgPyB0cnVlIDogZmFsc2VcbiAgdGhpcy5kYXRhID0gZGF0YVxuICB0aGlzLndpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoICogZGF0YS5zY2FsZVxuICB0aGlzLmhlaWdodCA9IHRoaXMub3B0aW9ucy5oZWlnaHQgKiBkYXRhLnNjYWxlXG4gIEF0b21pYy5jYWxsKHRoaXMsIGRhdGEpXG59XG5cblN3aXRjaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEF0b21pYy5wcm90b3R5cGUpXG5cblN3aXRjaC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICB0aGlzLmphY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzbWFsbCcpXG4gIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5qYWNrKVxuICBub2RlLmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5jbGFzc05hbWVcbiAgdGhpcy5ub2RlID0gbm9kZVxuICB0aGlzLmF0dHIuZGlzYWJsZWQuY2FsbCh0aGlzLCB0aGlzLmRhdGEuYXR0ci5kaXNhYmxlZClcbiAgcmV0dXJuIG5vZGVcbn1cblxuU3dpdGNoLnByb3RvdHlwZS5vbkFwcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXRTaXplKClcbiAgdGhpcy5zZXRQb3NpdGlvbigpXG59XG5cblN3aXRjaC5wcm90b3R5cGUuYXR0ciA9IHtcbiAgZGlzYWJsZWQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmRpc2FibGVkID0gdmFsICYmIHZhbCAhPT0gJ2ZhbHNlJ1xuICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgOiBmYWxzZVxuICAgIHRoaXMuZGlzYWJsZWQgPyB0aGlzLmRpc2FibGUoKSA6IHRoaXMuZW5hYmxlKClcbiAgfVxufVxuXG5Td2l0Y2gucHJvdG90eXBlLnNldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtaW4gPSBNYXRoLm1pbih0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgdmFyIG1heCA9IE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICB0aGlzLm5vZGUuc3R5bGUud2lkdGggPSBtYXggKyAncHgnXG4gIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSBtaW4gKyAncHgnXG4gIHRoaXMubm9kZS5zdHlsZS5ib3JkZXJSYWRpdXMgPSBtaW4gLyAyICsgJ3B4J1xuICB0aGlzLmphY2suc3R5bGUud2lkdGhcbiAgICAgID0gdGhpcy5qYWNrLnN0eWxlLmhlaWdodFxuICAgICAgPSBtaW4gKyAncHgnXG59XG5cblN3aXRjaC5wcm90b3R5cGUuc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoY2xpY2tlZCkge1xuICB2YXIgY2hlY2tlZCA9IHRoaXMuY2hlY2tlZFxuICB2YXIgbm9kZSA9IHRoaXMubm9kZVxuICB2YXIgamFjayA9IHRoaXMuamFja1xuXG4gIGlmIChjbGlja2VkICYmIGNoZWNrZWQpIHtcbiAgICBjaGVja2VkID0gZmFsc2VcbiAgfSBlbHNlIGlmIChjbGlja2VkICYmICFjaGVja2VkKSB7XG4gICAgY2hlY2tlZCA9IHRydWVcbiAgfVxuXG4gIGlmIChjaGVja2VkID09PSB0cnVlKSB7XG4gICAgdGhpcy5jaGVja2VkID0gdHJ1ZVxuXG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICBqYWNrLnN0eWxlLmxlZnQgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS53aWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoamFjaykud2lkdGgpICsgJ3B4J1xuICAgIH0gZWxzZSB7XG4gICAgICBqYWNrLnN0eWxlLmxlZnQgPSBwYXJzZUludChub2RlLmN1cnJlbnRTdHlsZVsnd2lkdGgnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gcGFyc2VJbnQoamFjay5jdXJyZW50U3R5bGVbJ3dpZHRoJ10pICsgJ3B4J1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5jb2xvciAmJiB0aGlzLmNvbG9yaXplKClcbiAgICB0aGlzLnNldFNwZWVkKClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNoZWNrZWQgPSBmYWxzZVxuICAgIGphY2suc3R5bGUubGVmdCA9IDBcbiAgICBub2RlLnN0eWxlLmJveFNoYWRvdyA9ICdpbnNldCAwIDAgMCAwICcgKyB0aGlzLm9wdGlvbnMuc2Vjb25kYXJ5Q29sb3JcbiAgICBub2RlLnN0eWxlLmJvcmRlckNvbG9yID0gdGhpcy5vcHRpb25zLnNlY29uZGFyeUNvbG9yXG4gICAgbm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgPSAodGhpcy5vcHRpb25zLnNlY29uZGFyeUNvbG9yICE9PSBkZWZhdWx0cy5zZWNvbmRhcnlDb2xvcilcbiAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zZWNvbmRhcnlDb2xvclxuICAgICAgICAgIDogJyNmZmYnXG4gICAgamFjay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3JcbiAgICAgICAgPSAodGhpcy5vcHRpb25zLmphY2tTZWNvbmRhcnlDb2xvciAhPT0gdGhpcy5vcHRpb25zLmphY2tDb2xvcilcbiAgICAgICAgICA/IHRoaXMub3B0aW9ucy5qYWNrU2Vjb25kYXJ5Q29sb3JcbiAgICAgICAgICA6IHRoaXMub3B0aW9ucy5qYWNrQ29sb3JcbiAgICB0aGlzLnNldFNwZWVkKClcbiAgfVxufVxuXG5Td2l0Y2gucHJvdG90eXBlLmNvbG9yaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZUhlaWdodCA9IHRoaXMubm9kZS5vZmZzZXRIZWlnaHQgLyAyXG5cbiAgdGhpcy5ub2RlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvclxuICB0aGlzLm5vZGUuc3R5bGUuYm9yZGVyQ29sb3IgPSB0aGlzLm9wdGlvbnMuY29sb3JcbiAgdGhpcy5ub2RlLnN0eWxlLmJveFNoYWRvdyA9ICdpbnNldCAwIDAgMCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIG5vZGVIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJ3B4ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgdGhpcy5vcHRpb25zLmNvbG9yXG4gIHRoaXMuamFjay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLm9wdGlvbnMuamFja0NvbG9yXG59XG5cblN3aXRjaC5wcm90b3R5cGUuc2V0U3BlZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzd2l0Y2hlclByb3AgPSB7fVxuICB2YXIgamFja1Byb3AgPSB7XG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMub3B0aW9ucy5zcGVlZFxuICAgICAgLCBsZWZ0OiB0aGlzLm9wdGlvbnMuc3BlZWQucmVwbGFjZSgvW2Etel0vLCAnJykgLyAyICsgJ3MnXG4gICAgfVxuXG4gIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICBzd2l0Y2hlclByb3AgPSB7XG4gICAgICBib3JkZXI6IHRoaXMub3B0aW9ucy5zcGVlZFxuICAgICAgLCAnYm94LXNoYWRvdyc6IHRoaXMub3B0aW9ucy5zcGVlZFxuICAgICAgLCAnYmFja2dyb3VuZC1jb2xvcic6IHRoaXMub3B0aW9ucy5zcGVlZC5yZXBsYWNlKC9bYS16XS8sICcnKSAqIDMgKyAncydcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoZXJQcm9wID0ge1xuICAgICAgYm9yZGVyOiB0aGlzLm9wdGlvbnMuc3BlZWRcbiAgICAgICwgJ2JveC1zaGFkb3cnOiB0aGlzLm9wdGlvbnMuc3BlZWRcbiAgICB9XG4gIH1cblxuICB1dGlscy50cmFuc2l0aW9uaXplKHRoaXMubm9kZSwgc3dpdGNoZXJQcm9wKVxuICB1dGlscy50cmFuc2l0aW9uaXplKHRoaXMuamFjaywgamFja1Byb3ApXG59XG5cblN3aXRjaC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgIXRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuZGlzYWJsZWQgPSB0cnVlKVxuICB0aGlzLm5vZGUuc3R5bGUub3BhY2l0eSA9IGRlZmF1bHRzLmRpc2FibGVkT3BhY2l0eVxuICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmdldENsaWNrSGFuZGxlcigpKVxufVxuXG5Td2l0Y2gucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kaXNhYmxlZCAmJiAodGhpcy5kaXNhYmxlZCA9IGZhbHNlKVxuICB0aGlzLm5vZGUuc3R5bGUub3BhY2l0eSA9IDFcbiAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5nZXRDbGlja0hhbmRsZXIoKSlcbn1cblxuU3dpdGNoLnByb3RvdHlwZS5nZXRDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fY2xpY2tIYW5kbGVyKSB7XG4gICAgdGhpcy5fY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gdmFyIHBhcmVudCA9IHRoaXMubm9kZS5wYXJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgLy8gdmFyIGxhYmVsUGFyZW50ID0gKHBhcmVudCA9PT0gJ2xhYmVsJykgPyBmYWxzZSA6IHRydWVcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24odHJ1ZSlcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnY2hhbmdlJywge1xuICAgICAgICBjaGVja2VkOiB0aGlzLmNoZWNrZWRcbiAgICAgIH0pXG4gICAgfS5iaW5kKHRoaXMpXG4gIH1cbiAgcmV0dXJuIHRoaXMuX2NsaWNrSGFuZGxlclxufVxuXG5Td2l0Y2gucHJvdG90eXBlLnN0eWxlXG4gICAgPSB1dGlscy5leHRlbmQoT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlLnN0eWxlKSwge1xuXG4gICAgICB3aWR0aDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zY2FsYWJsZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhbCA9IHBhcnNlRmxvYXQodmFsKVxuICAgICAgICBpZiAodmFsICE9PSB2YWwgfHwgdmFsIDwgMCkgeyAvLyBOYU5cbiAgICAgICAgICB2YWwgPSB0aGlzLm9wdGlvbnMud2lkdGhcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgICAgIHRoaXMuc2V0U2l6ZSgpXG4gICAgICB9LFxuXG4gICAgICBoZWlnaHQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2NhbGFibGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbClcbiAgICAgICAgaWYgKHZhbCAhPT0gdmFsIHx8IHZhbCA8IDApIHsgLy8gTmFOXG4gICAgICAgICAgdmFsID0gdGhpcy5vcHRpb25zLmhlaWdodFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdmFsICogdGhpcy5kYXRhLnNjYWxlXG4gICAgICAgIHRoaXMuc2V0U2l6ZSgpXG4gICAgICB9XG5cbiAgICB9KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN3aXRjaFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9zd2l0Y2guanNcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3dpdGNoLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3dpdGNoLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3dpdGNoLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3N3aXRjaC5jc3NcbiAqKiBtb2R1bGUgaWQgPSA3OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogc3dpdGNoIGRlZmF1bHRzLiAqL1xcbi53ZWV4LXN3aXRjaCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2RmZGZkZjtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLWtodG1sLXVzZXItc2VsZWN0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICBiYWNrZ3JvdW5kLWNsaXA6IGNvbnRlbnQtYm94O1xcbn1cXG5cXG4ud2VleC1zd2l0Y2ggPiBzbWFsbCB7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsIDAsIDAsIDAuNCk7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDA7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3dlZXgtaHRtbDUvc3JjL3N0eWxlcy9zd2l0Y2guY3NzXG4gKiogbW9kdWxlIGlkID0gNzlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBsb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50JylcblxuLy8gYXR0cnM6XG4vLyAgIC0gaHJlZlxuZnVuY3Rpb24gQSAoZGF0YSkge1xuICBDb21wb25lbnQuY2FsbCh0aGlzLCBkYXRhKVxufVxuXG5BLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSlcblxuQS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJylcbiAgbm9kZS5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9ICdub25lJ1xuICByZXR1cm4gbm9kZVxufVxuXG5BLnByb3RvdHlwZS5hdHRyID0ge1xuICBocmVmOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKCF2YWwpIHtcbiAgICAgIHJldHVybiBsb2dnZXIud2FybignaHJlZiBvZiA8YT4gc2hvdWxkIG5vdCBiZSBhIG51bGwgdmFsdWUuJylcbiAgICB9XG4gICAgdGhpcy5ocmVmID0gdmFsXG4gICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJywgdmFsKVxuICB9XG59XG5cbkEucHJvdG90eXBlLmJpbmRFdmVudHMgPSBmdW5jdGlvbiAoZXZ0cykge1xuICAvLyBldmVudCBoYW5kbGVyIGZvciBjbGljayBldmVudCB3aWxsIGJlIHByb2Nlc3NlZFxuICAvLyBiZWZvcmUgdGhlIHVybCByZWRpcmVjdGlvbi5cbiAgQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kRXZlbnRzLmNhbGwodGhpcywgZXZ0cylcbiAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmIChldnQuX2FscmVhZHlGaXJlZCAmJiBldnQudGFyZ2V0ICE9PSB0aGlzLm5vZGUpIHtcbiAgICAgIC8vIGlmIHRoZSBldmVudCB0YXJnZXQgaXMgdGhpcy5ub2RlLCB0aGVuIHRoaXMgaXNcbiAgICAgIC8vIGp1c3QgYW5vdGhlciBjbGljayBldmVudCBoYW5kbGVyIGZvciB0aGUgc2FtZVxuICAgICAgLy8gdGFyZ2V0LCBub3QgYSBoYW5kbGVyIGZvciBhIGJ1YmJsaW5nIHVwIGV2ZW50LFxuICAgICAgLy8gb3RoZXJ3aXNlIGl0IGlzIGEgYnViYmxpbmcgdXAgZXZlbnQsIGFuZCBpdFxuICAgICAgLy8gc2hvdWxkIGJlIGRpc3JlZ2FyZGVkLlxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGV2dC5fYWxyZWFkeUZpcmVkID0gdHJ1ZVxuICAgIGxvY2F0aW9uLmhyZWYgPSB0aGlzLmhyZWZcbiAgfS5iaW5kKHRoaXMpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvYS5qc1xuICoqIG1vZHVsZSBpZCA9IDgwXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnQnKVxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKVxuXG52YXIgSURfUFJFRklYID0gJ3dlZXhfZW1iZWRfJ1xuXG5mdW5jdGlvbiBfZ2VuZXJhdGVJZCgpIHtcbiAgcmV0dXJuIElEX1BSRUZJWCArIHV0aWxzLmdldFJhbmRvbSgxMClcbn1cblxuZnVuY3Rpb24gRW1iZWQgKGRhdGEsIG5vZGVUeXBlKSB7XG4gIHZhciBhdHRyID0gZGF0YS5hdHRyXG4gIGlmIChhdHRyKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBhdHRyLnNyY1xuICAgIHRoaXMubG9hZGVyID0gYXR0ci5sb2FkZXIgfHwgJ3hocidcbiAgICB0aGlzLmpzb25wQ2FsbGJhY2sgPSBhdHRyLmpzb25wQ2FsbGJhY2tcbiAgfVxuICBDb21wb25lbnQuY2FsbCh0aGlzLCBkYXRhLCBub2RlVHlwZSlcbn1cblxuRW1iZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuXG5FbWJlZC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG5vZGUuaWQgPSB0aGlzLmlkXG4gIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJ1xuICByZXR1cm4gbm9kZVxufVxuXG5FbWJlZC5wcm90b3R5cGUuaW5pdFdlZXggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaWQgPSBfZ2VuZXJhdGVJZCgpXG4gIHRoaXMubm9kZS5pZCA9IHRoaXMuaWRcbiAgdmFyIGNvbmZpZyA9IHtcbiAgICBhcHBJZDogdGhpcy5pZCxcbiAgICBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgIGJ1bmRsZVVybDogdGhpcy5zb3VyY2UsXG4gICAgbG9hZGVyOiB0aGlzLmxvYWRlcixcbiAgICBqc29ucENhbGxiYWNrOiB0aGlzLmpzb25wQ2FsbGJhY2ssXG4gICAgd2lkdGg6IHRoaXMubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICByb290SWQ6IHRoaXMuaWQsXG4gICAgZW1iZWQ6IHRydWVcbiAgfVxuICB3aW5kb3cud2VleC5pbml0KGNvbmZpZylcbn1cblxuRW1iZWQucHJvdG90eXBlLmRlc3Ryb3lXZWV4ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlkICYmIHdpbmRvdy5kZXN0cm95SW5zdGFuY2UodGhpcy5pZClcbiAgLy8gVE9ETzogdW5iaW5kIGV2ZW50cyBhbmQgY2xlYXIgZG9tcy5cbiAgdGhpcy5ub2RlLmlubmVySFRNTCA9ICcnXG59XG5cbkVtYmVkLnByb3RvdHlwZS5yZWxvYWRXZWV4ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pZCkge1xuICAgIHRoaXMuZGVzdHJveVdlZXgoKVxuICAgIHRoaXMuaWQgPSBudWxsXG4gICAgdGhpcy5ub2RlLmlkID0gbnVsbFxuICAgIHRoaXMubm9kZS5pbm5lckhUTUwgPSAnJ1xuICB9XG4gIHRoaXMuaW5pdFdlZXgoKVxufVxuXG4vLyBub3QgcmVjb21tZW5kZWQsIGJlY2F1c2Ugb2YgdGhlIGxlYWsgb2YgbWVtb3J5LlxuRW1iZWQucHJvdG90eXBlLmF0dHIgPSB7XG4gIHNyYzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSB2YWx1ZVxuICAgIHRoaXMucmVsb2FkV2VleCgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbWJlZFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvY29tcG9uZW50cy9lbWJlZC5qc1xuICoqIG1vZHVsZSBpZCA9IDgxXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9jb21wb25lbnQnKVxuXG5yZXF1aXJlKCcuLi9zdHlsZXMvcmVmcmVzaC5jc3MnKVxuXG52YXIgcGFyZW50cyA9IFsnc2Nyb2xsZXInLCAnbGlzdCddXG5cbi8vIE9ubHkgaWYgcHVsbGRvd24gb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoaXMgdmFsdWUgY2FuIHRoaXNcbi8vIGNvbXBvbmVudCB0cmlnZ2VyIHRoZSAncmVmcmVzaCcgZXZlbnQsIG90aGVyd2lzZSBqdXN0IHJlY292ZXJcbi8vIHRvIHRoZSBzdGFydCBwb2ludC5cbnZhciBDTEFNUCA9IDEzMFxuXG52YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudFxudmFyIEZpcmVmb3ggPSAhIXVhLm1hdGNoKC9GaXJlZm94L2kpXG52YXIgSUVNb2JpbGUgPSAhIXVhLm1hdGNoKC9JRU1vYmlsZS9pKVxudmFyIGNzc1ByZWZpeCA9IEZpcmVmb3ggPyAnLW1vei0nIDogSUVNb2JpbGUgPyAnLW1zLScgOiAnLXdlYmtpdC0nXG5cbmZ1bmN0aW9uIFJlZnJlc2ggKGRhdGEpIHtcbiAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSlcbn1cblxuUmVmcmVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUpXG5cblJlZnJlc2gucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtY29udGFpbmVyJywgJ3dlZXgtcmVmcmVzaCcpXG4gIHJldHVybiBub2RlXG59XG5cblJlZnJlc2gucHJvdG90eXBlLm9uQXBwZW5kID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHBhcmVudHMuaW5kZXhPZihwYXJlbnQuZGF0YS50eXBlKSA9PT0gLTEpIHtcbiAgICByZXR1cm5cbiAgfVxuICBwYXJlbnQuc2Nyb2xsZXIuYWRkRXZlbnRMaXN0ZW5lcigncHVsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYuYWRqdXN0SGVpZ2h0KE1hdGguYWJzKGUuc2Nyb2xsT2JqLmdldFNjcm9sbFRvcCgpKSlcbiAgICBpZiAoIXRoaXMuZGlzcGxheSkge1xuICAgICAgc2VsZi5zaG93KClcbiAgICB9XG4gIH0pXG4gIHBhcmVudC5zY3JvbGxlci5hZGRFdmVudExpc3RlbmVyKCdwdWxsZG93bmVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHRvcCA9IE1hdGguYWJzKGUuc2Nyb2xsT2JqLmdldFNjcm9sbFRvcCgpKVxuICAgIGlmICh0b3AgPiBDTEFNUCkge1xuICAgICAgc2VsZi5oYW5kbGVSZWZyZXNoKGUpXG4gICAgfVxuICB9KVxufVxuXG5SZWZyZXNoLnByb3RvdHlwZS5hZGp1c3RIZWlnaHQgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSB2YWwgKyAncHgnXG4gIHRoaXMubm9kZS5zdHlsZS50b3AgPSAtdmFsICsgJ3B4J1xufVxuXG5SZWZyZXNoLnByb3RvdHlwZS5oYW5kbGVSZWZyZXNoID0gZnVuY3Rpb24gKGUpIHtcbiAgdmFyIHNjcm9sbE9iaiA9IGUuc2Nyb2xsT2JqXG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gcGFyZW50LnNjcm9sbEVsZW1lbnQgfHwgcGFyZW50Lmxpc3RFbGVtZW50XG4gIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSBDTEFNUCArICdweCdcbiAgdGhpcy5ub2RlLnN0eWxlLnRvcCA9IC1DTEFNUCArICdweCdcbiAgdmFyIHRyYW5zbGF0ZVN0ciA9ICd0cmFuc2xhdGUzZCgwcHgsJyArIENMQU1QICsgJ3B4LDBweCknXG4gIHNjcm9sbEVsZW1lbnQuc3R5bGVbY3NzUHJlZml4ICsgJ3RyYW5zZm9ybSddXG4gICAgPSBjc3NQcmVmaXggKyB0cmFuc2xhdGVTdHJcbiAgc2Nyb2xsRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGVTdHJcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCdyZWZyZXNoJylcbn1cblxuUmVmcmVzaC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kaXNwbGF5ID0gdHJ1ZVxuICB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9ICctd2Via2l0LWJveCdcbiAgdGhpcy5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnLXdlYmtpdC1mbGV4J1xuICB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xufVxuXG5SZWZyZXNoLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRpc3BsYXkgPSBmYWxzZVxuICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICBpZiAocGFyZW50KSB7XG4gICAgdmFyIHNjcm9sbEVsZW1lbnQgPSBwYXJlbnQuc2Nyb2xsRWxlbWVudCB8fCBwYXJlbnQubGlzdEVsZW1lbnRcbiAgICB2YXIgdHJhbnNsYXRlU3RyID0gJ3RyYW5zbGF0ZTNkKDBweCwwcHgsMHB4KSdcbiAgICBzY3JvbGxFbGVtZW50LnN0eWxlW2Nzc1ByZWZpeCArICd0cmFuc2Zvcm0nXVxuICAgICAgPSBjc3NQcmVmaXggKyB0cmFuc2xhdGVTdHJcbiAgICBzY3JvbGxFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zbGF0ZVN0clxuICB9XG4gIHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG59XG5cblJlZnJlc2gucHJvdG90eXBlLmF0dHIgPSB7XG4gIGRpc3BsYXk6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsID09PSAnc2hvdycpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNob3coKVxuICAgICAgfS5iaW5kKHRoaXMpLCAwKVxuICAgIH0gZWxzZSBpZiAodmFsID09PSAnaGlkZScpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgfS5iaW5kKHRoaXMpLCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPXG4gICAgICBjb25zb2xlLmVycm9yKCdoNXJlbmRlcjphdHRyaWJ1dGUgdmFsdWUgb2YgcmVmcmVzaCBcXCdkaXNwbGF5XFwnICdcbiAgICAgICAgICArIHZhbFxuICAgICAgICAgICsgJyBpcyBpbnZhbGlkLiBTaG91bGQgYmUgXFwnc2hvd1xcJyBvciBcXCdoaWRlXFwnJylcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWZyZXNoXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3JlZnJlc2guanNcbiAqKiBtb2R1bGUgaWQgPSA4MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vcmVmcmVzaC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3JlZnJlc2guY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9yZWZyZXNoLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3JlZnJlc2guY3NzXG4gKiogbW9kdWxlIGlkID0gODNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi53ZWV4LXJlZnJlc2gge1xcbiAgLy8gLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gIC8vIC13ZWJraXQtYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIC8vIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAvLyAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XFxuICAvLyAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgLy8ganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAwO1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvcmVmcmVzaC5jc3NcbiAqKiBtb2R1bGUgaWQgPSA4NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4vY29tcG9uZW50JylcblxucmVxdWlyZSgnLi4vc3R5bGVzL2xvYWRpbmcuY3NzJylcblxudmFyIHBhcmVudHMgPSBbJ3Njcm9sbGVyJywgJ2xpc3QnXVxuXG52YXIgREVGQVVMVF9IRUlHSFQgPSAxMzBcblxudmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnRcbnZhciBGaXJlZm94ID0gISF1YS5tYXRjaCgvRmlyZWZveC9pKVxudmFyIElFTW9iaWxlID0gISF1YS5tYXRjaCgvSUVNb2JpbGUvaSlcbnZhciBjc3NQcmVmaXggPSBGaXJlZm94ID8gJy1tb3otJyA6IElFTW9iaWxlID8gJy1tcy0nIDogJy13ZWJraXQtJ1xuXG5mdW5jdGlvbiBMb2FkaW5nIChkYXRhKSB7XG4gIENvbXBvbmVudC5jYWxsKHRoaXMsIGRhdGEpXG59XG5cbkxvYWRpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQucHJvdG90eXBlKVxuXG5Mb2FkaW5nLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgbm9kZS5jbGFzc0xpc3QuYWRkKCd3ZWV4LWNvbnRhaW5lcicsICd3ZWV4LWxvYWRpbmcnKVxuICByZXR1cm4gbm9kZVxufVxuXG5Mb2FkaW5nLnByb3RvdHlwZS5vbkFwcGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBzY3JvbGxXcmFwSGVpZ2h0ID0gcGFyZW50Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gIGlmIChwYXJlbnRzLmluZGV4T2YocGFyZW50LmRhdGEudHlwZSkgPT09IC0xKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgcGFyZW50LnNjcm9sbGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3B1bGx1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG9iaiA9IGUuc2Nyb2xsT2JqXG4gICAgc2VsZi5hZGp1c3RIZWlnaHQoTWF0aC5hYnMoXG4gICAgICBvYmouZ2V0U2Nyb2xsSGVpZ2h0KCkgLSBvYmouZ2V0U2Nyb2xsVG9wKCkgLSBzY3JvbGxXcmFwSGVpZ2h0KSlcbiAgICBpZiAoIXNlbGYuZGlzcGxheSkge1xuICAgICAgc2VsZi5zaG93KClcbiAgICB9XG4gIH0pXG4gIHBhcmVudC5zY3JvbGxlci5hZGRFdmVudExpc3RlbmVyKCdwdWxsdXBlbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgIHNlbGYuaGFuZGxlTG9hZGluZyhlKVxuICB9KVxufVxuXG5Mb2FkaW5nLnByb3RvdHlwZS5hZGp1c3RIZWlnaHQgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSB2YWwgKyAncHgnXG4gIHRoaXMubm9kZS5zdHlsZS5ib3R0b20gPSAtdmFsICsgJ3B4J1xufVxuXG5Mb2FkaW5nLnByb3RvdHlwZS5oYW5kbGVMb2FkaW5nID0gZnVuY3Rpb24gKGUpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KClcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBwYXJlbnQuc2Nyb2xsRWxlbWVudCB8fCBwYXJlbnQubGlzdEVsZW1lbnRcbiAgdmFyIG9mZnNldCA9IHNjcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICAgICAgICAtIHBhcmVudC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgICAgICAgKyBERUZBVUxUX0hFSUdIVFxuICB0aGlzLm5vZGUuc3R5bGUuaGVpZ2h0ID0gREVGQVVMVF9IRUlHSFQgKyAncHgnXG4gIHRoaXMubm9kZS5zdHlsZS5ib3R0b20gPSAtREVGQVVMVF9IRUlHSFQgKyAncHgnXG4gIHZhciB0cmFuc2xhdGVTdHIgPSAndHJhbnNsYXRlM2QoMHB4LC0nICsgb2Zmc2V0ICsgJ3B4LDBweCknXG4gIHNjcm9sbEVsZW1lbnQuc3R5bGVbY3NzUHJlZml4ICsgJ3RyYW5zZm9ybSddXG4gICAgPSBjc3NQcmVmaXggKyB0cmFuc2xhdGVTdHJcbiAgc2Nyb2xsRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGVTdHJcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCdsb2FkaW5nJylcbn1cblxuTG9hZGluZy5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kaXNwbGF5ID0gdHJ1ZVxuICB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9ICctd2Via2l0LWJveCdcbiAgdGhpcy5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnLXdlYmtpdC1mbGV4J1xuICB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xufVxuXG5Mb2FkaW5nLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmRpc3BsYXkgPSBmYWxzZVxuICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKVxuICBpZiAocGFyZW50KSB7XG4gICAgdmFyIHNjcm9sbEVsZW1lbnQgPSBwYXJlbnQuc2Nyb2xsRWxlbWVudCB8fCBwYXJlbnQubGlzdEVsZW1lbnRcbiAgICB2YXIgc2Nyb2xsRWxlbWVudEhlaWdodCA9IHNjcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgdmFyIHNjcm9sbFdyYXBIZWlnaHQgPSBwYXJlbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICB2YXIgbGVmdCA9IHNjcm9sbEVsZW1lbnRIZWlnaHRcbiAgICAgIC0gcGFyZW50LnNjcm9sbGVyLmdldFNjcm9sbFRvcCgpXG4gICAgICAtIHNjcm9sbFdyYXBIZWlnaHRcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHZhciBvZmZzZXQgPSBzY3JvbGxFbGVtZW50SGVpZ2h0XG4gICAgICAgICAgICAgIC0gcGFyZW50Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICB2YXIgdHJhbnNsYXRlU3RyID0gJ3RyYW5zbGF0ZTNkKDBweCwtJyArIG9mZnNldCArICdweCwwcHgpJ1xuICAgICAgc2Nyb2xsRWxlbWVudC5zdHlsZVtjc3NQcmVmaXggKyAndHJhbnNmb3JtJ11cbiAgICAgICAgPSBjc3NQcmVmaXggKyB0cmFuc2xhdGVTdHJcbiAgICAgIHNjcm9sbEVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNsYXRlU3RyXG4gICAgfVxuICB9XG4gIHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG59XG5cbkxvYWRpbmcucHJvdG90eXBlLmF0dHIgPSB7XG4gIGRpc3BsYXk6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAodmFsID09PSAnc2hvdycpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNob3coKVxuICAgICAgfS5iaW5kKHRoaXMpLCAwKVxuICAgIH0gZWxzZSBpZiAodmFsID09PSAnaGlkZScpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgfS5iaW5kKHRoaXMpLCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPXG4gICAgICBjb25zb2xlLmVycm9yKCdoNXJlbmRlcjphdHRyaWJ1dGUgdmFsdWUgb2YgcmVmcmVzaCBcXCdkaXNwbGF5XFwnICdcbiAgICAgICAgICArIHZhbFxuICAgICAgICAgICsgJyBpcyBpbnZhbGlkLiBTaG91bGQgYmUgXFwnc2hvd1xcJyBvciBcXCdoaWRlXFwnJylcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMb2FkaW5nXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL2xvYWRpbmcuanNcbiAqKiBtb2R1bGUgaWQgPSA4NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbG9hZGluZy5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2xvYWRpbmcuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9sb2FkaW5nLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL2xvYWRpbmcuY3NzXG4gKiogbW9kdWxlIGlkID0gODZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi53ZWV4LWxvYWRpbmcge1xcbiAgLy8gLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gIC8vIC13ZWJraXQtYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIC8vIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAvLyAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XFxuICAvLyAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgLy8ganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAwO1xcbn1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvbG9hZGluZy5jc3NcbiAqKiBtb2R1bGUgaWQgPSA4N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIEF0b21pYyA9IHJlcXVpcmUoJy4vYXRvbWljJylcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJylcblxucmVxdWlyZSgnLi4vc3R5bGVzL3NwaW5uZXIuY3NzJylcblxuZnVuY3Rpb24gU3Bpbm5lciAoZGF0YSkge1xuICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxufVxuXG5TcGlubmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXRvbWljLnByb3RvdHlwZSlcblxuU3Bpbm5lci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInLCAnd2VleC1zcGlubmVyLXdyYXAnKVxuICB0aGlzLnNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICB0aGlzLnNwaW5uZXIuY2xhc3NMaXN0LmFkZCgnd2VleC1lbGVtZW50JywgJ3dlZXgtc3Bpbm5lcicpXG4gIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zcGlubmVyKVxuICByZXR1cm4gbm9kZVxufVxuXG5TcGlubmVyLnByb3RvdHlwZS51cGRhdGVTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBBdG9taWMucHJvdG90eXBlLnVwZGF0ZVN0eWxlLmNhbGwodGhpcywgc3R5bGUpXG4gIGlmIChzdHlsZSAmJiBzdHlsZS5jb2xvcikge1xuICAgIHRoaXMuc2V0S2V5ZnJhbWVDb2xvcih1dGlscy5nZXRSZ2IodGhpcy5ub2RlLnN0eWxlLmNvbG9yKSlcbiAgfVxufVxuXG5TcGlubmVyLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zdHlsZVNoZWV0KSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHN0eWxlcyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzXG4gIG91dGVyOiBmb3IgKHZhciBpID0gMCwgbCA9IHN0eWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcnVsZXMgPSBzdHlsZXNbaV0ucnVsZXNcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHJ1bGVzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgdmFyIGl0ZW0gPSBydWxlcy5pdGVtKGopXG4gICAgICBpZiAoXG4gICAgICAgIChpdGVtLnR5cGUgPT09IENTU1J1bGUuS0VZRlJBTUVTX1JVTEVcbiAgICAgICAgICB8fCBpdGVtLnR5cGUgPT09IENTU1J1bGUuV0VCS0lUX0tFWUZSQU1FU19SVUxFKVxuICAgICAgICAmJiBpdGVtLm5hbWUgPT09ICdzcGlubmVyJykge1xuICAgICAgICBicmVhayBvdXRlclxuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnN0eWxlU2hlZXQgPSBzdHlsZXNbaV1cbn1cblxuU3Bpbm5lci5wcm90b3R5cGUuc2V0S2V5ZnJhbWVDb2xvciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdGhpcy5nZXRTdHlsZVNoZWV0KClcbiAgdmFyIGtleWZyYW1lUnVsZXMgPSB0aGlzLmNvbXB1dGVLZXlGcmFtZVJ1bGVzKHZhbClcbiAgdmFyIHJ1bGVzLCBpdGVtLCBjc3NSdWxlcywga2V5ZnJhbWVcbiAgcnVsZXMgPSB0aGlzLnN0eWxlU2hlZXQucnVsZXNcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBydWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpdGVtID0gcnVsZXMuaXRlbShpKVxuICAgIGlmICgoaXRlbS50eXBlID09PSBDU1NSdWxlLktFWUZSQU1FU19SVUxFXG4gICAgICAgICAgfHwgaXRlbS50eXBlID09PSBDU1NSdWxlLldFQktJVF9LRVlGUkFNRVNfUlVMRSlcbiAgICAgICAgJiYgaXRlbS5uYW1lID09PSAnc3Bpbm5lcicpIHtcbiAgICAgIGNzc1J1bGVzID0gaXRlbS5jc3NSdWxlc1xuICAgICAgZm9yICh2YXIgaiA9IDAsIG0gPSBjc3NSdWxlcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgICAga2V5ZnJhbWUgPSBjc3NSdWxlc1tqXVxuICAgICAgICBpZiAoa2V5ZnJhbWUudHlwZSA9PT0gQ1NTUnVsZS5LRVlGUkFNRV9SVUxFXG4gICAgICAgICAgfHwga2V5ZnJhbWUudHlwZSA9PT0gQ1NTUnVsZS5XRUJLSVRfS0VZRlJBTUVfUlVMRSkge1xuICAgICAgICAgIGtleWZyYW1lLnN0eWxlLmJveFNoYWRvdyA9IGtleWZyYW1lUnVsZXNbal1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5TcGlubmVyLnByb3RvdHlwZS5jb21wdXRlS2V5RnJhbWVSdWxlcyA9IGZ1bmN0aW9uIChyZ2IpIHtcbiAgaWYgKCFyZ2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2NhbGVBcnIgPSBbXG4gICAgJzBlbSAtMi42ZW0gMGVtIDBlbScsXG4gICAgJzEuOGVtIC0xLjhlbSAwIDBlbScsXG4gICAgJzIuNWVtIDBlbSAwIDBlbScsXG4gICAgJzEuNzVlbSAxLjc1ZW0gMCAwZW0nLFxuICAgICcwZW0gMi41ZW0gMCAwZW0nLFxuICAgICctMS44ZW0gMS44ZW0gMCAwZW0nLFxuICAgICctMi42ZW0gMGVtIDAgMGVtJyxcbiAgICAnLTEuOGVtIC0xLjhlbSAwIDBlbSddXG4gIHZhciBjb2xvckFyciA9IFtcbiAgICAnMScsXG4gICAgJzAuMicsXG4gICAgJzAuMicsXG4gICAgJzAuMicsXG4gICAgJzAuMicsXG4gICAgJzAuMicsXG4gICAgJzAuNScsXG4gICAgJzAuNyddLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnLCcgKyBlICsgJyknXG4gICAgfSlcbiAgdmFyIHJ1bGVzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY2FsZUFyci5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0bXBDb2xvckFyciA9IHV0aWxzLmxvb3BBcnJheShjb2xvckFyciwgaSwgJ3InKVxuICAgIHJ1bGVzLnB1c2goc2NhbGVBcnIubWFwKGZ1bmN0aW9uIChzY2FsZVN0ciwgaSkge1xuICAgICAgcmV0dXJuIHNjYWxlU3RyICsgJyAnICsgdG1wQ29sb3JBcnJbaV1cbiAgICB9KS5qb2luKCcsICcpKVxuICB9XG4gIHJldHVybiBydWxlc1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNwaW5uZXJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2NvbXBvbmVudHMvc3Bpbm5lci5qc1xuICoqIG1vZHVsZSBpZCA9IDg4XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zcGlubmVyLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vc3Bpbm5lci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3NwaW5uZXIuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9zdHlsZXMvc3Bpbm5lci5jc3NcbiAqKiBtb2R1bGUgaWQgPSA4OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLndlZXgtc3Bpbm5lci13cmFwIHtcXG4gIHdpZHRoOiAxLjAxMzMzM3JlbTsgLyogNzZweCAqL1xcbiAgaGVpZ2h0OiAxLjAxMzMzM3JlbTtcXG4gIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XFxuICAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcbiAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcblxcbi53ZWV4LXNwaW5uZXIge1xcbiAgZm9udC1zaXplOiAwLjE2cmVtOyAvKiAxMnB4ICovXFxuICB3aWR0aDogMWVtO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0ZXh0LWluZGVudDogLTk5OTllbTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBzcGlubmVyIDEuMXMgaW5maW5pdGUgZWFzZTtcXG4gIGFuaW1hdGlvbjogc3Bpbm5lciAxLjFzIGluZmluaXRlIGVhc2U7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcXG4gIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBzcGlubmVyIHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSAjZmZmZmZmLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcbiAgfVxcbiAgMTIuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAxLjhlbSAtMS44ZW0gMCAwZW0gI2ZmZmZmZiwgMi41ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS43NWVtIDEuNzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG4gIH1cXG4gIDI1JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDIuNWVtIDBlbSAwIDBlbSAjZmZmZmZmLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgMzcuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAxLjc1ZW0gMS43NWVtIDAgMGVtICNmZmZmZmYsIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAwZW0gMi41ZW0gMCAwZW0gI2ZmZmZmZiwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgNjIuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgLTEuOGVtIDEuOGVtIDAgMGVtICNmZmZmZmYsIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAtMi42ZW0gMGVtIDAgMGVtICNmZmZmZmYsIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgODcuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIC0xLjhlbSAtMS44ZW0gMCAwZW0gI2ZmZmZmZjtcXG4gIH1cXG59XFxuQGtleWZyYW1lcyBzcGlubmVyIHtcXG4gIDAlLFxcbiAgMTAwJSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSAjZmZmZmZmLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpO1xcbiAgfVxcbiAgMTIuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAxLjhlbSAtMS44ZW0gMCAwZW0gI2ZmZmZmZiwgMi41ZW0gMGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMS43NWVtIDEuNzVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KTtcXG4gIH1cXG4gIDI1JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIDIuNWVtIDBlbSAwIDBlbSAjZmZmZmZmLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgMzcuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAxLjc1ZW0gMS43NWVtIDAgMGVtICNmZmZmZmYsIDBlbSAyLjVlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAxLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gIH1cXG4gIDUwJSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAwZW0gMi41ZW0gMCAwZW0gI2ZmZmZmZiwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgNjIuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSwgLTEuOGVtIDEuOGVtIDAgMGVtICNmZmZmZmYsIC0yLjZlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAtMS44ZW0gLTEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKTtcXG4gIH1cXG4gIDc1JSB7XFxuICAgIGJveC1zaGFkb3c6IDBlbSAtMi42ZW0gMGVtIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuOGVtIC0xLjhlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDIuNWVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiksIDEuNzVlbSAxLjc1ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAwZW0gMi41ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpLCAtMS44ZW0gMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpLCAtMi42ZW0gMGVtIDAgMGVtICNmZmZmZmYsIC0xLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpO1xcbiAgfVxcbiAgODcuNSUge1xcbiAgICBib3gtc2hhZG93OiAwZW0gLTIuNmVtIDBlbSAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjhlbSAtMS44ZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAyLjVlbSAwZW0gMCAwZW0gcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjIpLCAxLjc1ZW0gMS43NWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgMGVtIDIuNWVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKSwgLTEuOGVtIDEuOGVtIDAgMGVtIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41KSwgLTIuNmVtIDBlbSAwIDBlbSByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyksIC0xLjhlbSAtMS44ZW0gMCAwZW0gI2ZmZmZmZjtcXG4gIH1cXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vd2VleC1odG1sNS9zcmMvc3R5bGVzL3NwaW5uZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gOTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBBdG9taWMgPSByZXF1aXJlKCcuL2F0b21pYycpXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpXG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJylcblxuLy8gQSBjb21wb25lbnQgdG8gaW1wb3J0IHdlYiBwYWdlcywgd2hpY2ggd29ya3MgbGlrZVxuLy8gYSBpZnJhbWUgZWxlbWVudCBvciBhIHdlYnZpZXcuXG4vLyBhdHRyczpcbi8vICAgLSBzcmNcbi8vIGV2ZW50czpcbi8vICAgLSBwYWdlc3RhcnRcbi8vICAgLSBwYWdlZmluaXNoXG4vLyAgIC0gZXJyb3JcbmZ1bmN0aW9uIFdlYiAoZGF0YSkge1xuICBBdG9taWMuY2FsbCh0aGlzLCBkYXRhKVxufVxuXG5XZWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBdG9taWMucHJvdG90eXBlKVxuXG5XZWIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gSWZyYW1lJ3MgZGVmZWN0OiBjYW4ndCB1c2UgcG9zaXRpb246YWJzb2x1dGUgYW5kIHRvcCwgbGVmdCwgcmlnaHQsXG4gIC8vIGJvdHRvbSBhbGwgc2V0dGluZyB0byB6ZXJvIGFuZCB1c2UgbWFyZ2luIHRvIGxlYXZlIHNwZWNpZmllZFxuICAvLyBoZWlnaHQgZm9yIGEgYmxhbmsgYXJlYSwgYW5kIGhhdmUgdG8gdXNlIDEwMCUgdG8gZmlsbCB0aGUgcGFyZW50XG4gIC8vIGNvbnRhaW5lciwgb3RoZXJ3aXNlIGl0IHdpbGwgdXNlIGEgdW53YW50ZWQgZGVmYXVsdCBzaXplIGluc3RlYWQuXG4gIC8vIFRoZXJlZm9yZSBhIGRpdiBhcyBhIGlmcmFtZSB3cmFwcGVyIGlzIG5lZWRlZCBoZXJlLlxuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIG5vZGUuY2xhc3NMaXN0LmFkZCgnd2VleC1jb250YWluZXInKVxuICB0aGlzLndlYiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXG4gIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy53ZWIpXG4gIHRoaXMud2ViLmNsYXNzTGlzdC5hZGQoJ3dlZXgtZWxlbWVudCcpXG4gIHRoaXMud2ViLnN0eWxlLndpZHRoID0gJzEwMCUnXG4gIHRoaXMud2ViLnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICB0aGlzLndlYi5zdHlsZS5ib3JkZXIgPSAnbm9uZSdcbiAgcmV0dXJuIG5vZGVcbn1cblxuV2ViLnByb3RvdHlwZS5iaW5kRXZlbnRzID0gZnVuY3Rpb24gKGV2dHMpIHtcbiAgQXRvbWljLnByb3RvdHlwZS5iaW5kRXZlbnRzLmNhbGwodGhpcywgZXZ0cylcbiAgdmFyIHRoYXQgPSB0aGlzXG4gIHRoaXMud2ViLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoZSkge1xuICAgIHRoYXQuZGlzcGF0Y2hFdmVudCgncGFnZWZpbmlzaCcsIHV0aWxzLmV4dGVuZCh7XG4gICAgICB1cmw6IHRoYXQud2ViLnNyY1xuICAgIH0pKVxuICB9KVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMubXNnSGFuZGxlci5iaW5kKHRoaXMpKVxufVxuXG5XZWIucHJvdG90eXBlLm1zZ0hhbmRsZXIgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gIHZhciBtc2cgPSBldnQuZGF0YVxuICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbXNnID0gSlNPTi5wYXJzZShtc2cpXG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICBpZiAoIW1zZykge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChtc2cudHlwZSA9PT0gJ3dlZXgnKSB7XG4gICAgaWYgKCF1dGlscy5pc0FycmF5KG1zZy5jb250ZW50KSkge1xuICAgICAgcmV0dXJuIGxvZ2dlci5lcnJvcignd2VleCBtc2cgcmVjZWl2ZWQgYnkgd2ViIGNvbXBvbmVudC4gbXNnLmNvbnRlbnQnXG4gICAgICAgICsgJyBzaG91bGQgYmUgYSBhcnJheTonLCBtc2cuY29udGVudClcbiAgICB9XG4gICAgY2FsbE5hdGl2ZSh0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5pbnN0YW5jZUlkLCBtc2cuY29udGVudClcbiAgfVxufVxuXG5XZWIucHJvdG90eXBlLmF0dHIgPSB7XG4gIHNyYzogZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMud2ViLnNyYyA9IHZhbFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdwYWdlc3RhcnQnLCB7IHVybDogdmFsIH0pXG4gICAgfS5iaW5kKHRoaXMpLCAwKVxuICB9XG59XG5cbldlYi5wcm90b3R5cGUuZ29CYWNrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndlYi5jb250ZW50V2luZG93Lmhpc3RvcnkuYmFjaygpXG59XG5cbldlYi5wcm90b3R5cGUuZ29Gb3J3YXJkID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndlYi5jb250ZW50V2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpXG59XG5cbldlYi5wcm90b3R5cGUucmVsb2FkID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLndlYi5jb250ZW50V2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9jb21wb25lbnRzL3dlYi5qc1xuICoqIG1vZHVsZSBpZCA9IDkxXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsInZhciBkb20gPSByZXF1aXJlKCcuL2RvbScpXG52YXIgZXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbnZhciBwYWdlSW5mbyA9IHJlcXVpcmUoJy4vcGFnZUluZm8nKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJy4vc3RyZWFtJylcbnZhciBtb2RhbCA9IHJlcXVpcmUoJy4vbW9kYWwnKVxudmFyIGFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vYW5pbWF0aW9uJylcbnZhciB3ZWJ2aWV3ID0gcmVxdWlyZSgnLi93ZWJ2aWV3JylcbnZhciB0aW1lciA9IHJlcXVpcmUoJy4vdGltZXInKVxudmFyIG5hdmlnYXRvciA9IHJlcXVpcmUoJy4vbmF2aWdhdG9yJylcblxudmFyIGFwaSA9IHtcbiAgaW5pdDogZnVuY3Rpb24gKFdlZXgpIHtcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdkb20nLCBkb20sIGRvbS5fbWV0YSlcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdldmVudCcsIGV2ZW50LCBldmVudC5fbWV0YSlcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdwYWdlSW5mbycsIHBhZ2VJbmZvLCBwYWdlSW5mby5fbWV0YSlcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdzdHJlYW0nLCBzdHJlYW0sIHN0cmVhbS5fbWV0YSlcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdtb2RhbCcsIG1vZGFsLCBtb2RhbC5fbWV0YSlcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCdhbmltYXRpb24nLCBhbmltYXRpb24sIGFuaW1hdGlvbi5fbWV0YSlcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCd3ZWJ2aWV3Jywgd2Vidmlldywgd2Vidmlldy5fbWV0YSlcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCd0aW1lcicsIHRpbWVyLCB0aW1lci5fbWV0YSlcbiAgICBXZWV4LnJlZ2lzdGVyQXBpTW9kdWxlKCduYXZpZ2F0b3InLCBuYXZpZ2F0b3IsIG5hdmlnYXRvci5fbWV0YSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwaVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2FwaS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDkyXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbWVzc2FnZVF1ZXVlID0gcmVxdWlyZSgnLi4vbWVzc2FnZVF1ZXVlJylcbnZhciBGcmFtZVVwZGF0ZXIgPSByZXF1aXJlKCcuLi9mcmFtZVVwZGF0ZXInKVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvY29tcG9uZW50JylcbnZhciBzY3JvbGwgPSByZXF1aXJlKCdzY3JvbGwtdG8nKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NvbmZpZycpXG52YXIgbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJylcblxudmFyIGRvbSA9IHtcblxuICAvKipcbiAgICogY3JlYXRlQm9keTogY3JlYXRlIHJvb3QgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge29iamVjdH0gZWxlbWVudFxuICAgKiAgICBjb250YWluZXJ8bGlzdHZpZXd8c2Nyb2xsdmlld1xuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgY3JlYXRlQm9keTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gICAgZWxlbWVudC5zY2FsZSA9IHRoaXMuc2NhbGVcbiAgICBlbGVtZW50Lmluc3RhbmNlSWQgPSBjb21wb25lbnRNYW5hZ2VyLmluc3RhbmNlSWRcbiAgICByZXR1cm4gY29tcG9uZW50TWFuYWdlci5jcmVhdGVCb2R5KGVsZW1lbnQpXG4gIH0sXG5cbiAgYWRkRWxlbWVudDogZnVuY3Rpb24gKHBhcmVudFJlZiwgZWxlbWVudCwgaW5kZXgpIHtcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gICAgZWxlbWVudC5zY2FsZSA9IHRoaXMuc2NhbGVcbiAgICBlbGVtZW50Lmluc3RhbmNlSWQgPSBjb21wb25lbnRNYW5hZ2VyLmluc3RhbmNlSWRcbiAgICByZXR1cm4gY29tcG9uZW50TWFuYWdlci5hZGRFbGVtZW50KHBhcmVudFJlZiwgZWxlbWVudCwgaW5kZXgpXG4gIH0sXG5cbiAgcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgICByZXR1cm4gY29tcG9uZW50TWFuYWdlci5yZW1vdmVFbGVtZW50KHJlZilcbiAgfSxcblxuICBtb3ZlRWxlbWVudDogZnVuY3Rpb24gKHJlZiwgcGFyZW50UmVmLCBpbmRleCkge1xuICAgIHZhciBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgICByZXR1cm4gY29tcG9uZW50TWFuYWdlci5tb3ZlRWxlbWVudChyZWYsIHBhcmVudFJlZiwgaW5kZXgpXG4gIH0sXG5cbiAgYWRkRXZlbnQ6IGZ1bmN0aW9uIChyZWYsIHR5cGUpIHtcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gICAgcmV0dXJuIGNvbXBvbmVudE1hbmFnZXIuYWRkRXZlbnQocmVmLCB0eXBlKVxuICB9LFxuXG4gIHJlbW92ZUV2ZW50OiBmdW5jdGlvbiAocmVmLCB0eXBlKSB7XG4gICAgdmFyIGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuICAgIHJldHVybiBjb21wb25lbnRNYW5hZ2VyLnJlbW92ZUV2ZW50KHJlZiwgdHlwZSlcbiAgfSxcblxuICAvKipcbiAgICogdXBkYXRlQXR0cnM6IHVwZGF0ZSBhdHRyaWJ1dGVzIG9mIGNvbXBvbmVudFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJlZlxuICAgKiBAcGFyYW0gIHtvYmp9IGF0dHJcbiAgICovXG4gIHVwZGF0ZUF0dHJzOiBmdW5jdGlvbiAocmVmLCBhdHRyKSB7XG4gICAgdmFyIGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuICAgIHJldHVybiBjb21wb25lbnRNYW5hZ2VyLnVwZGF0ZUF0dHJzKHJlZiwgYXR0cilcbiAgfSxcblxuICAvKipcbiAgICogdXBkYXRlU3R5bGU6IHVkcGF0ZSBzdHlsZSBvZiBjb21wb25lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZlxuICAgKiBAcGFyYW0ge29ian0gc3R5bGVcbiAgICovXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiAocmVmLCBzdHlsZSkge1xuICAgIHZhciBjb21wb25lbnRNYW5hZ2VyID0gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKClcbiAgICByZXR1cm4gY29tcG9uZW50TWFuYWdlci51cGRhdGVTdHlsZShyZWYsIHN0eWxlKVxuICB9LFxuXG4gIGNyZWF0ZUZpbmlzaDogZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE9cbiAgICAvLyBGcmFtZVVwZGF0ZXIucGF1c2UoKVxuICB9LFxuXG4gIHJlZnJlc2hGaW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPXG4gIH0sXG5cbiAgLyoqXG4gICAqIHNjcm9sbFRvRWxlbWVudFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJlZlxuICAgKiBAcGFyYW0gIHtvYmp9IG9wdGlvbnMge29mZnNldDpOdW1iZXJ9XG4gICAqICAgcHM6IHNjcm9sbC10byBoYXMgJ2Vhc2UnIGFuZCAnZHVyYXRpb24nKG1zKSBhcyBvcHRpb25zLlxuICAgKi9cbiAgc2Nyb2xsVG9FbGVtZW50OiBmdW5jdGlvbiAocmVmLCBvcHRpb25zKSB7XG4gICAgIW9wdGlvbnMgJiYgKG9wdGlvbnMgPSB7fSlcbiAgICB2YXIgY29tcG9uZW50TWFuYWdlciA9IHRoaXMuZ2V0Q29tcG9uZW50TWFuYWdlcigpXG4gICAgdmFyIGVsZW0gPSBjb21wb25lbnRNYW5hZ2VyLmdldEVsZW1lbnRCeVJlZihyZWYpXG4gICAgaWYgKCFlbGVtKSB7XG4gICAgICByZXR1cm4gbG9nZ2VyLmVycm9yKCdjb21wb25lbnQgb2YgcmVmICcgKyByZWYgKyAnIGRvZXNuXFwndCBleGlzdC4nKVxuICAgIH1cbiAgICB2YXIgcGFyZW50U2Nyb2xsZXIgPSBlbGVtLmdldFBhcmVudFNjcm9sbGVyKClcbiAgICBpZiAocGFyZW50U2Nyb2xsZXIpIHtcbiAgICAgIHBhcmVudFNjcm9sbGVyLnNjcm9sbGVyLnNjcm9sbFRvRWxlbWVudChlbGVtLm5vZGUsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvZmZzZXRUb3AgPSBlbGVtLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgICAgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcFxuICAgICAgdmFyIG9mZnNldCA9IChOdW1iZXIob3B0aW9ucy5vZmZzZXQpIHx8IDApICogdGhpcy5zY2FsZVxuICAgICAgdmFyIHR3ZWVuID0gc2Nyb2xsKDAsIG9mZnNldFRvcCArIG9mZnNldCwgb3B0aW9ucylcbiAgICAgIHR3ZWVuLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ3Njcm9sbCBlbmQuJylcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbn1cblxuZG9tLl9tZXRhID0ge1xuICBkb206IFt7XG4gICAgbmFtZTogJ2NyZWF0ZUJvZHknLFxuICAgIGFyZ3M6IFsnb2JqZWN0J11cbiAgfSwge1xuICAgIG5hbWU6ICdhZGRFbGVtZW50JyxcbiAgICBhcmdzOiBbJ3N0cmluZycsICdvYmplY3QnLCAnbnVtYmVyJ11cbiAgfSwge1xuICAgIG5hbWU6ICdyZW1vdmVFbGVtZW50JyxcbiAgICBhcmdzOiBbJ3N0cmluZyddXG4gIH0sIHtcbiAgICBuYW1lOiAnbW92ZUVsZW1lbnQnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJywgJ3N0cmluZycsICdudW1iZXInXVxuICB9LCB7XG4gICAgbmFtZTogJ2FkZEV2ZW50JyxcbiAgICBhcmdzOiBbJ3N0cmluZycsICdzdHJpbmcnXVxuICB9LCB7XG4gICAgbmFtZTogJ3JlbW92ZUV2ZW50JyxcbiAgICBhcmdzOiBbJ3N0cmluZycsICdzdHJpbmcnXVxuICB9LCB7XG4gICAgbmFtZTogJ3VwZGF0ZUF0dHJzJyxcbiAgICBhcmdzOiBbJ3N0cmluZycsICdvYmplY3QnXVxuICB9LCB7XG4gICAgbmFtZTogJ3VwZGF0ZVN0eWxlJyxcbiAgICBhcmdzOiBbJ3N0cmluZycsICdvYmplY3QnXVxuICB9LCB7XG4gICAgbmFtZTogJ2NyZWF0ZUZpbmlzaCcsXG4gICAgYXJnczogW11cbiAgfSwge1xuICAgIG5hbWU6ICdyZWZyZXNoRmluaXNoJyxcbiAgICBhcmdzOiBbXVxuICB9LCB7XG4gICAgbmFtZTogJ3Njcm9sbFRvRWxlbWVudCcsXG4gICAgYXJnczogWydzdHJpbmcnLCAnb2JqZWN0J11cbiAgfV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkb21cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2FwaS9kb20uanNcbiAqKiBtb2R1bGUgaWQgPSA5M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFR3ZWVuID0gcmVxdWlyZSgndHdlZW4nKTtcbnZhciByYWYgPSByZXF1aXJlKCdyYWYnKTtcblxuLyoqXG4gKiBFeHBvc2UgYHNjcm9sbFRvYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNjcm9sbFRvO1xuXG4vKipcbiAqIFNjcm9sbCB0byBgKHgsIHkpYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gc2Nyb2xsVG8oeCwgeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBzdGFydCBwb3NpdGlvblxuICB2YXIgc3RhcnQgPSBzY3JvbGwoKTtcblxuICAvLyBzZXR1cCB0d2VlblxuICB2YXIgdHdlZW4gPSBUd2VlbihzdGFydClcbiAgICAuZWFzZShvcHRpb25zLmVhc2UgfHwgJ291dC1jaXJjJylcbiAgICAudG8oeyB0b3A6IHksIGxlZnQ6IHggfSlcbiAgICAuZHVyYXRpb24ob3B0aW9ucy5kdXJhdGlvbiB8fCAxMDAwKTtcblxuICAvLyBzY3JvbGxcbiAgdHdlZW4udXBkYXRlKGZ1bmN0aW9uKG8pe1xuICAgIHdpbmRvdy5zY3JvbGxUbyhvLmxlZnQgfCAwLCBvLnRvcCB8IDApO1xuICB9KTtcblxuICAvLyBoYW5kbGUgZW5kXG4gIHR3ZWVuLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgIGFuaW1hdGUgPSBmdW5jdGlvbigpe307XG4gIH0pO1xuXG4gIC8vIGFuaW1hdGVcbiAgZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICByYWYoYW5pbWF0ZSk7XG4gICAgdHdlZW4udXBkYXRlKCk7XG4gIH1cblxuICBhbmltYXRlKCk7XG4gIFxuICByZXR1cm4gdHdlZW47XG59XG5cbi8qKlxuICogUmV0dXJuIHNjcm9sbCBwb3NpdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzY3JvbGwoKSB7XG4gIHZhciB5ID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gIHZhciB4ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICByZXR1cm4geyB0b3A6IHksIGxlZnQ6IHggfTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Njcm9sbC10by9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnZW1pdHRlcicpO1xudmFyIGNsb25lID0gcmVxdWlyZSgnY2xvbmUnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZScpO1xudmFyIGVhc2UgPSByZXF1aXJlKCdlYXNlJyk7XG5cbi8qKlxuICogRXhwb3NlIGBUd2VlbmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUd2VlbjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBUd2VlbmAgd2l0aCBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFR3ZWVuKG9iaikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHdlZW4pKSByZXR1cm4gbmV3IFR3ZWVuKG9iaik7XG4gIHRoaXMuX2Zyb20gPSBvYmo7XG4gIHRoaXMuZWFzZSgnbGluZWFyJyk7XG4gIHRoaXMuZHVyYXRpb24oNTAwKTtcbn1cblxuLyoqXG4gKiBNaXhpbiBlbWl0dGVyLlxuICovXG5cbkVtaXR0ZXIoVHdlZW4ucHJvdG90eXBlKTtcblxuLyoqXG4gKiBSZXNldCB0aGUgdHdlZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Ud2Vlbi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmlzQXJyYXkgPSAnYXJyYXknID09PSB0eXBlKHRoaXMuX2Zyb20pO1xuICB0aGlzLl9jdXJyID0gY2xvbmUodGhpcy5fZnJvbSk7XG4gIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgdGhpcy5fc3RhcnQgPSBEYXRlLm5vdygpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVHdlZW4gdG8gYG9iamAgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlLlxuICpcbiAqICAgIHR3ZWVuLnRvKHsgeDogNTAsIHk6IDEwMCB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAqIEByZXR1cm4ge1R3ZWVufSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblR3ZWVuLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uKG9iail7XG4gIHRoaXMucmVzZXQoKTtcbiAgdGhpcy5fdG8gPSBvYmo7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgZHVyYXRpb24gdG8gYG1zYCBbNTAwXS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1R3ZWVufSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblR3ZWVuLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKG1zKXtcbiAgdGhpcy5fZHVyYXRpb24gPSBtcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBlYXNpbmcgZnVuY3Rpb24gdG8gYGZuYC5cbiAqXG4gKiAgICB0d2Vlbi5lYXNlKCdpbi1vdXQtc2luZScpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtUd2Vlbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHdlZW4ucHJvdG90eXBlLmVhc2UgPSBmdW5jdGlvbihmbil7XG4gIGZuID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZm4gPyBmbiA6IGVhc2VbZm5dO1xuICBpZiAoIWZuKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGVhc2luZyBmdW5jdGlvbicpO1xuICB0aGlzLl9lYXNlID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdG9wIHRoZSB0d2VlbiBhbmQgaW1tZWRpYXRlbHkgZW1pdCBcInN0b3BcIiBhbmQgXCJlbmRcIi5cbiAqXG4gKiBAcmV0dXJuIHtUd2Vlbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHdlZW4ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdzdG9wJyk7XG4gIHRoaXMuZW1pdCgnZW5kJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgc3RlcC5cbiAqXG4gKiBAcmV0dXJuIHtUd2Vlbn0gc2VsZlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHdlZW4ucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5fZG9uZSkgcmV0dXJuO1xuXG4gIC8vIGR1cmF0aW9uXG4gIHZhciBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgdmFyIGRlbHRhID0gbm93IC0gdGhpcy5fc3RhcnQ7XG4gIHZhciBkb25lID0gZGVsdGEgPj0gZHVyYXRpb247XG5cbiAgLy8gY29tcGxldGVcbiAgaWYgKGRvbmUpIHtcbiAgICB0aGlzLl9mcm9tID0gdGhpcy5fdG87XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX3RvKTtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHdlZW5cbiAgdmFyIGZyb20gPSB0aGlzLl9mcm9tO1xuICB2YXIgdG8gPSB0aGlzLl90bztcbiAgdmFyIGN1cnIgPSB0aGlzLl9jdXJyO1xuICB2YXIgZm4gPSB0aGlzLl9lYXNlO1xuICB2YXIgcCA9IChub3cgLSB0aGlzLl9zdGFydCkgLyBkdXJhdGlvbjtcbiAgdmFyIG4gPSBmbihwKTtcblxuICAvLyBhcnJheVxuICBpZiAodGhpcy5pc0FycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcm9tLmxlbmd0aDsgKytpKSB7XG4gICAgICBjdXJyW2ldID0gZnJvbVtpXSArICh0b1tpXSAtIGZyb21baV0pICogbjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGUoY3Vycik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBvYmplY2hcbiAgZm9yICh2YXIgayBpbiBmcm9tKSB7XG4gICAgY3VycltrXSA9IGZyb21ba10gKyAodG9ba10gLSBmcm9tW2tdKSAqIG47XG4gIH1cblxuICB0aGlzLl91cGRhdGUoY3Vycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdXBkYXRlIGZ1bmN0aW9uIHRvIGBmbmAgb3JcbiAqIHdoZW4gbm8gYXJndW1lbnQgaXMgZ2l2ZW4gdGhpcyBwZXJmb3Jtc1xuICogYSBcInN0ZXBcIi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7VHdlZW59IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHdlZW4ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGZuKXtcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuc3RlcCgpO1xuICB0aGlzLl91cGRhdGUgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDk1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9+L2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0eXBlO1xudHJ5IHtcbiAgdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudC10eXBlJyk7XG59IGNhdGNoIChfKSB7XG4gIHR5cGUgPSByZXF1aXJlKCd0eXBlJyk7XG59XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuLyoqXG4gKiBDbG9uZXMgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBhbnkgb2JqZWN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGNsb25lKG9iail7XG4gIHN3aXRjaCAodHlwZShvYmopKSB7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHZhciBjb3B5ID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvcHlba2V5XSA9IGNsb25lKG9ialtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvcHk7XG5cbiAgICBjYXNlICdhcnJheSc6XG4gICAgICB2YXIgY29weSA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb3B5W2ldID0gY2xvbmUob2JqW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3B5O1xuXG4gICAgY2FzZSAncmVnZXhwJzpcbiAgICAgIC8vIGZyb20gbWlsbGVybWVkZWlyb3MvYW1kLXV0aWxzIC0gTUlUXG4gICAgICB2YXIgZmxhZ3MgPSAnJztcbiAgICAgIGZsYWdzICs9IG9iai5tdWx0aWxpbmUgPyAnbScgOiAnJztcbiAgICAgIGZsYWdzICs9IG9iai5nbG9iYWwgPyAnZycgOiAnJztcbiAgICAgIGZsYWdzICs9IG9iai5pZ25vcmVDYXNlID8gJ2knIDogJyc7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChvYmouc291cmNlLCBmbGFncyk7XG5cbiAgICBjYXNlICdkYXRlJzpcbiAgICAgIHJldHVybiBuZXcgRGF0ZShvYmouZ2V0VGltZSgpKTtcblxuICAgIGRlZmF1bHQ6IC8vIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCDigKZcbiAgICAgIHJldHVybiBvYmo7XG4gIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9+L2NvbXBvbmVudC1jbG9uZS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDk3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8qKlxuICogdG9TdHJpbmcgcmVmLlxuICovXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSB0eXBlIG9mIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCl7XG4gIHN3aXRjaCAodG9TdHJpbmcuY2FsbCh2YWwpKSB7XG4gICAgY2FzZSAnW29iamVjdCBEYXRlXSc6IHJldHVybiAnZGF0ZSc7XG4gICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzogcmV0dXJuICdyZWdleHAnO1xuICAgIGNhc2UgJ1tvYmplY3QgQXJndW1lbnRzXSc6IHJldHVybiAnYXJndW1lbnRzJztcbiAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6IHJldHVybiAnYXJyYXknO1xuICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzogcmV0dXJuICdlcnJvcic7XG4gIH1cblxuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKHZhbCAhPT0gdmFsKSByZXR1cm4gJ25hbic7XG4gIGlmICh2YWwgJiYgdmFsLm5vZGVUeXBlID09PSAxKSByZXR1cm4gJ2VsZW1lbnQnO1xuXG4gIHZhbCA9IHZhbC52YWx1ZU9mXG4gICAgPyB2YWwudmFsdWVPZigpXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YuYXBwbHkodmFsKVxuXG4gIHJldHVybiB0eXBlb2YgdmFsO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC10d2Vlbi9+L2NvbXBvbmVudC10eXBlL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiXG4vLyBlYXNpbmcgZnVuY3Rpb25zIGZyb20gXCJUd2Vlbi5qc1wiXG5cbmV4cG9ydHMubGluZWFyID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuO1xufTtcblxuZXhwb3J0cy5pblF1YWQgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIG4gKiBuO1xufTtcblxuZXhwb3J0cy5vdXRRdWFkID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICogKDIgLSBuKTtcbn07XG5cbmV4cG9ydHMuaW5PdXRRdWFkID0gZnVuY3Rpb24obil7XG4gIG4gKj0gMjtcbiAgaWYgKG4gPCAxKSByZXR1cm4gMC41ICogbiAqIG47XG4gIHJldHVybiAtIDAuNSAqICgtLW4gKiAobiAtIDIpIC0gMSk7XG59O1xuXG5leHBvcnRzLmluQ3ViZSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gbiAqIG4gKiBuO1xufTtcblxuZXhwb3J0cy5vdXRDdWJlID0gZnVuY3Rpb24obil7XG4gIHJldHVybiAtLW4gKiBuICogbiArIDE7XG59O1xuXG5leHBvcnRzLmluT3V0Q3ViZSA9IGZ1bmN0aW9uKG4pe1xuICBuICo9IDI7XG4gIGlmIChuIDwgMSkgcmV0dXJuIDAuNSAqIG4gKiBuICogbjtcbiAgcmV0dXJuIDAuNSAqICgobiAtPSAyICkgKiBuICogbiArIDIpO1xufTtcblxuZXhwb3J0cy5pblF1YXJ0ID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICogbiAqIG4gKiBuO1xufTtcblxuZXhwb3J0cy5vdXRRdWFydCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMSAtICgtLW4gKiBuICogbiAqIG4pO1xufTtcblxuZXhwb3J0cy5pbk91dFF1YXJ0ID0gZnVuY3Rpb24obil7XG4gIG4gKj0gMjtcbiAgaWYgKG4gPCAxKSByZXR1cm4gMC41ICogbiAqIG4gKiBuICogbjtcbiAgcmV0dXJuIC0wLjUgKiAoKG4gLT0gMikgKiBuICogbiAqIG4gLSAyKTtcbn07XG5cbmV4cG9ydHMuaW5RdWludCA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gbiAqIG4gKiBuICogbiAqIG47XG59XG5cbmV4cG9ydHMub3V0UXVpbnQgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIC0tbiAqIG4gKiBuICogbiAqIG4gKyAxO1xufVxuXG5leHBvcnRzLmluT3V0UXVpbnQgPSBmdW5jdGlvbihuKXtcbiAgbiAqPSAyO1xuICBpZiAobiA8IDEpIHJldHVybiAwLjUgKiBuICogbiAqIG4gKiBuICogbjtcbiAgcmV0dXJuIDAuNSAqICgobiAtPSAyKSAqIG4gKiBuICogbiAqIG4gKyAyKTtcbn07XG5cbmV4cG9ydHMuaW5TaW5lID0gZnVuY3Rpb24obil7XG4gIHJldHVybiAxIC0gTWF0aC5jb3MobiAqIE1hdGguUEkgLyAyICk7XG59O1xuXG5leHBvcnRzLm91dFNpbmUgPSBmdW5jdGlvbihuKXtcbiAgcmV0dXJuIE1hdGguc2luKG4gKiBNYXRoLlBJIC8gMik7XG59O1xuXG5leHBvcnRzLmluT3V0U2luZSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBuKSk7XG59O1xuXG5leHBvcnRzLmluRXhwbyA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMCA9PSBuID8gMCA6IE1hdGgucG93KDEwMjQsIG4gLSAxKTtcbn07XG5cbmV4cG9ydHMub3V0RXhwbyA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMSA9PSBuID8gbiA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBuKTtcbn07XG5cbmV4cG9ydHMuaW5PdXRFeHBvID0gZnVuY3Rpb24obil7XG4gIGlmICgwID09IG4pIHJldHVybiAwO1xuICBpZiAoMSA9PSBuKSByZXR1cm4gMTtcbiAgaWYgKChuICo9IDIpIDwgMSkgcmV0dXJuIC41ICogTWF0aC5wb3coMTAyNCwgbiAtIDEpO1xuICByZXR1cm4gLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqIChuIC0gMSkpICsgMik7XG59O1xuXG5leHBvcnRzLmluQ2lyYyA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gbiAqIG4pO1xufTtcblxuZXhwb3J0cy5vdXRDaXJjID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBNYXRoLnNxcnQoMSAtICgtLW4gKiBuKSk7XG59O1xuXG5leHBvcnRzLmluT3V0Q2lyYyA9IGZ1bmN0aW9uKG4pe1xuICBuICo9IDJcbiAgaWYgKG4gPCAxKSByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIG4gKiBuKSAtIDEpO1xuICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gKG4gLT0gMikgKiBuKSArIDEpO1xufTtcblxuZXhwb3J0cy5pbkJhY2sgPSBmdW5jdGlvbihuKXtcbiAgdmFyIHMgPSAxLjcwMTU4O1xuICByZXR1cm4gbiAqIG4gKiAoKCBzICsgMSApICogbiAtIHMpO1xufTtcblxuZXhwb3J0cy5vdXRCYWNrID0gZnVuY3Rpb24obil7XG4gIHZhciBzID0gMS43MDE1ODtcbiAgcmV0dXJuIC0tbiAqIG4gKiAoKHMgKyAxKSAqIG4gKyBzKSArIDE7XG59O1xuXG5leHBvcnRzLmluT3V0QmFjayA9IGZ1bmN0aW9uKG4pe1xuICB2YXIgcyA9IDEuNzAxNTggKiAxLjUyNTtcbiAgaWYgKCAoIG4gKj0gMiApIDwgMSApIHJldHVybiAwLjUgKiAoIG4gKiBuICogKCAoIHMgKyAxICkgKiBuIC0gcyApICk7XG4gIHJldHVybiAwLjUgKiAoICggbiAtPSAyICkgKiBuICogKCAoIHMgKyAxICkgKiBuICsgcyApICsgMiApO1xufTtcblxuZXhwb3J0cy5pbkJvdW5jZSA9IGZ1bmN0aW9uKG4pe1xuICByZXR1cm4gMSAtIGV4cG9ydHMub3V0Qm91bmNlKDEgLSBuKTtcbn07XG5cbmV4cG9ydHMub3V0Qm91bmNlID0gZnVuY3Rpb24obil7XG4gIGlmICggbiA8ICggMSAvIDIuNzUgKSApIHtcbiAgICByZXR1cm4gNy41NjI1ICogbiAqIG47XG4gIH0gZWxzZSBpZiAoIG4gPCAoIDIgLyAyLjc1ICkgKSB7XG4gICAgcmV0dXJuIDcuNTYyNSAqICggbiAtPSAoIDEuNSAvIDIuNzUgKSApICogbiArIDAuNzU7XG4gIH0gZWxzZSBpZiAoIG4gPCAoIDIuNSAvIDIuNzUgKSApIHtcbiAgICByZXR1cm4gNy41NjI1ICogKCBuIC09ICggMi4yNSAvIDIuNzUgKSApICogbiArIDAuOTM3NTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gNy41NjI1ICogKCBuIC09ICggMi42MjUgLyAyLjc1ICkgKSAqIG4gKyAwLjk4NDM3NTtcbiAgfVxufTtcblxuZXhwb3J0cy5pbk91dEJvdW5jZSA9IGZ1bmN0aW9uKG4pe1xuICBpZiAobiA8IC41KSByZXR1cm4gZXhwb3J0cy5pbkJvdW5jZShuICogMikgKiAuNTtcbiAgcmV0dXJuIGV4cG9ydHMub3V0Qm91bmNlKG4gKiAyIC0gMSkgKiAuNSArIC41O1xufTtcblxuLy8gYWxpYXNlc1xuXG5leHBvcnRzWydpbi1xdWFkJ10gPSBleHBvcnRzLmluUXVhZDtcbmV4cG9ydHNbJ291dC1xdWFkJ10gPSBleHBvcnRzLm91dFF1YWQ7XG5leHBvcnRzWydpbi1vdXQtcXVhZCddID0gZXhwb3J0cy5pbk91dFF1YWQ7XG5leHBvcnRzWydpbi1jdWJlJ10gPSBleHBvcnRzLmluQ3ViZTtcbmV4cG9ydHNbJ291dC1jdWJlJ10gPSBleHBvcnRzLm91dEN1YmU7XG5leHBvcnRzWydpbi1vdXQtY3ViZSddID0gZXhwb3J0cy5pbk91dEN1YmU7XG5leHBvcnRzWydpbi1xdWFydCddID0gZXhwb3J0cy5pblF1YXJ0O1xuZXhwb3J0c1snb3V0LXF1YXJ0J10gPSBleHBvcnRzLm91dFF1YXJ0O1xuZXhwb3J0c1snaW4tb3V0LXF1YXJ0J10gPSBleHBvcnRzLmluT3V0UXVhcnQ7XG5leHBvcnRzWydpbi1xdWludCddID0gZXhwb3J0cy5pblF1aW50O1xuZXhwb3J0c1snb3V0LXF1aW50J10gPSBleHBvcnRzLm91dFF1aW50O1xuZXhwb3J0c1snaW4tb3V0LXF1aW50J10gPSBleHBvcnRzLmluT3V0UXVpbnQ7XG5leHBvcnRzWydpbi1zaW5lJ10gPSBleHBvcnRzLmluU2luZTtcbmV4cG9ydHNbJ291dC1zaW5lJ10gPSBleHBvcnRzLm91dFNpbmU7XG5leHBvcnRzWydpbi1vdXQtc2luZSddID0gZXhwb3J0cy5pbk91dFNpbmU7XG5leHBvcnRzWydpbi1leHBvJ10gPSBleHBvcnRzLmluRXhwbztcbmV4cG9ydHNbJ291dC1leHBvJ10gPSBleHBvcnRzLm91dEV4cG87XG5leHBvcnRzWydpbi1vdXQtZXhwbyddID0gZXhwb3J0cy5pbk91dEV4cG87XG5leHBvcnRzWydpbi1jaXJjJ10gPSBleHBvcnRzLmluQ2lyYztcbmV4cG9ydHNbJ291dC1jaXJjJ10gPSBleHBvcnRzLm91dENpcmM7XG5leHBvcnRzWydpbi1vdXQtY2lyYyddID0gZXhwb3J0cy5pbk91dENpcmM7XG5leHBvcnRzWydpbi1iYWNrJ10gPSBleHBvcnRzLmluQmFjaztcbmV4cG9ydHNbJ291dC1iYWNrJ10gPSBleHBvcnRzLm91dEJhY2s7XG5leHBvcnRzWydpbi1vdXQtYmFjayddID0gZXhwb3J0cy5pbk91dEJhY2s7XG5leHBvcnRzWydpbi1ib3VuY2UnXSA9IGV4cG9ydHMuaW5Cb3VuY2U7XG5leHBvcnRzWydvdXQtYm91bmNlJ10gPSBleHBvcnRzLm91dEJvdW5jZTtcbmV4cG9ydHNbJ2luLW91dC1ib3VuY2UnXSA9IGV4cG9ydHMuaW5PdXRCb3VuY2U7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JvbGwtdG8vfi9jb21wb25lbnQtdHdlZW4vfi9lYXNlLWNvbXBvbmVudC9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDk5XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8qKlxuICogRXhwb3NlIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKWAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgfHwgZmFsbGJhY2s7XG5cbi8qKlxuICogRmFsbGJhY2sgaW1wbGVtZW50YXRpb24uXG4gKi9cblxudmFyIHByZXYgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbmZ1bmN0aW9uIGZhbGxiYWNrKGZuKSB7XG4gIHZhciBjdXJyID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIHZhciBtcyA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnIgLSBwcmV2KSk7XG4gIHZhciByZXEgPSBzZXRUaW1lb3V0KGZuLCBtcyk7XG4gIHByZXYgPSBjdXJyO1xuICByZXR1cm4gcmVxO1xufVxuXG4vKipcbiAqIENhbmNlbC5cbiAqL1xuXG52YXIgY2FuY2VsID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gIHx8IHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZVxuICB8fCB3aW5kb3cubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWVcbiAgfHwgd2luZG93LmNsZWFyVGltZW91dDtcblxuZXhwb3J0cy5jYW5jZWwgPSBmdW5jdGlvbihpZCl7XG4gIGNhbmNlbC5jYWxsKHdpbmRvdywgaWQpO1xufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3Njcm9sbC10by9+L2NvbXBvbmVudC1yYWYvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMDBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBldmVudCA9IHtcbiAgLyoqXG4gICAqIG9wZW5VcmxcbiAgICogQHBhcmFtICB7c3RyaW5nfSB1cmxcbiAgICovXG4gIG9wZW5VUkw6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBsb2NhdGlvbi5ocmVmID0gdXJsXG4gIH1cblxufVxuXG5ldmVudC5fbWV0YSA9IHtcbiAgZXZlbnQ6IFt7XG4gICAgbmFtZTogJ29wZW5VUkwnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJ11cbiAgfV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBldmVudFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2FwaS9ldmVudC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIHBhZ2VJbmZvID0ge1xuXG4gIHNldFRpdGxlOiBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICB0aXRsZSA9IHRpdGxlIHx8ICdXZWV4IEhUTUw1J1xuICAgIHRyeSB7XG4gICAgICB0aXRsZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0aXRsZSlcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGVcbiAgfVxufVxuXG5wYWdlSW5mby5fbWV0YSA9IHtcbiAgcGFnZUluZm86IFt7XG4gICAgbmFtZTogJ3NldFRpdGxlJyxcbiAgICBhcmdzOiBbJ3N0cmluZyddXG4gIH1dXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFnZUluZm9cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9hcGkvcGFnZUluZm8uanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJylcbnZhciBsb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKVxuXG5yZXF1aXJlKCdodHRwdXJsJylcblxudmFyIGpzb25wQ250ID0gMFxudmFyIEVSUk9SX1NUQVRFID0gLTFcblxuZnVuY3Rpb24gX2pzb25wKGNvbmZpZywgY2FsbGJhY2ssIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgdmFyIGNiTmFtZSA9ICdqc29ucF8nICsgKCsranNvbnBDbnQpXG4gIHZhciBzY3JpcHQsIHVybCwgaGVhZFxuXG4gIGlmICghY29uZmlnLnVybCkge1xuICAgIGxvZ2dlci5lcnJvcignY29uZmlnLnVybCBzaG91bGQgYmUgc2V0IGluIF9qc29ucCBmb3IgXFwnZmV0Y2hcXCcgQVBJLicpXG4gIH1cblxuICBnbG9iYWxbY2JOYW1lXSA9IChmdW5jdGlvbiAoY2IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBjYWxsYmFjayhyZXNwb25zZSlcbiAgICAgIGRlbGV0ZSBnbG9iYWxbY2JdXG4gICAgfVxuICB9KShjYk5hbWUpXG5cbiAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgdHJ5IHtcbiAgICB1cmwgPSBsaWIuaHR0cHVybChjb25maWcudXJsKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ2ludmFsaWQgY29uZmlnLnVybCBpbiBfanNvbnAgZm9yIFxcJ2ZldGNoXFwnIEFQSTogJ1xuICAgICAgKyBjb25maWcudXJsKVxuICB9XG4gIHVybC5wYXJhbXMuY2FsbGJhY2sgPSBjYk5hbWVcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICBzY3JpcHQuc3JjID0gdXJsLnRvU3RyaW5nKClcbiAgLy8gc2NyaXB0Lm9uZXJyb3IgaXMgbm90IHdvcmtpbmcgb24gSUUgb3Igc2FmYXJpLlxuICAvLyBidXQgdGhleSBhcmUgbm90IGNvbnNpZGVyZWQgaGVyZS5cbiAgc2NyaXB0Lm9uZXJyb3IgPSAoZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGxvZ2dlci5lcnJvcigndW5leHBlY3RlZCBlcnJvciBpbiBfanNvbnAgZm9yIFxcJ2ZldGNoXFwnIEFQSScsIGVycilcbiAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgIGRlbGV0ZSBnbG9iYWxbY2JdXG4gICAgfVxuICB9KShjYk5hbWUpXG4gIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgbnVsbClcbn1cblxuZnVuY3Rpb24gX3hocihjb25maWcsIGNhbGxiYWNrLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICB4aHIucmVzcG9uc2VUeXBlID0gY29uZmlnLnR5cGVcbiAgeGhyLm9wZW4oY29uZmlnLm1ldGhvZCwgY29uZmlnLnVybCwgdHJ1ZSlcblxuICB4aHIub25sb2FkID0gZnVuY3Rpb24gKHJlcykge1xuICAgIGNhbGxiYWNrKHtcbiAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgIG9rOiB4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwLFxuICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICBkYXRhOiB4aHIucmVzcG9uc2UsXG4gICAgICBoZWFkZXJzOiB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaGVhZGVyU3RyKSB7XG4gICAgICAgICAgdmFyIGhlYWRlckFyciA9IGhlYWRlclN0ci5tYXRjaCgvKC4rKTogKC4rKS8pXG4gICAgICAgICAgaWYgKGhlYWRlckFycikge1xuICAgICAgICAgICAgb2JqW2hlYWRlckFyclsxXV0gPSBoZWFkZXJBcnJbMl1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICB9LCB7fSlcbiAgICB9KVxuICB9XG5cbiAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBwcm9ncmVzc0NhbGxiYWNrKHtcbiAgICAgICAgcmVhZHlTdGF0ZTogeGhyLnJlYWR5U3RhdGUsXG4gICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgbGVuZ3RoOiBlLmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGUudG90YWwsXG4gICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiB4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkuc3BsaXQoJ1xcbicpXG4gICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAob2JqLCBoZWFkZXJTdHIpIHtcbiAgICAgICAgICAgIHZhciBoZWFkZXJBcnIgPSBoZWFkZXJTdHIubWF0Y2goLyguKyk6ICguKykvKVxuICAgICAgICAgICAgaWYgKGhlYWRlckFycikge1xuICAgICAgICAgICAgICBvYmpbaGVhZGVyQXJyWzFdXSA9IGhlYWRlckFyclsyXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgIH0sIHt9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBsb2dnZXIuZXJyb3IoJ3VuZXhwZWN0ZWQgZXJyb3IgaW4gX3hociBmb3IgXFwnZmV0Y2hcXCcgQVBJJywgZXJyKVxuICAgIGNhbGxiYWNrKHtcbiAgICAgIHN0YXR1czogRVJST1JfU1RBVEUsXG4gICAgICBvazogZmFsc2UsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGRhdGE6ICcnLFxuICAgICAgaGVhZGVyczoge31cbiAgICB9KVxuICB9XG5cbiAgeGhyLnNlbmQoY29uZmlnLmJvZHkpXG59XG5cbnZhciBzdHJlYW0gPSB7XG5cbiAgLyoqXG4gICAqIHNlbmRIdHRwXG4gICAqIE5vdGU6IFRoaXMgQVBJIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2Ugc3RyZWFtLmZldGNoIGluc3RlYWQuXG4gICAqIHNlbmQgYSBodHRwIHJlcXVlc3QgdGhyb3VnaCBYSFIuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSAge29ian0gcGFyYW1zXG4gICAqICAtIG1ldGhvZDogJ0dFVCcgfCAnUE9TVCcsXG4gICAqICAtIHVybDogdXJsIHJlcXVlc3RlZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNhbGxiYWNrSWRcbiAgICovXG4gIHNlbmRIdHRwOiBmdW5jdGlvbiAocGFyYW0sIGNhbGxiYWNrSWQpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyYW0gPSBKU09OLnBhcnNlKHBhcmFtKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJhbSAhPT0gJ29iamVjdCcgfHwgIXBhcmFtLnVybCkge1xuICAgICAgcmV0dXJuIGxvZ2dlci5lcnJvcihcbiAgICAgICAgJ2ludmFsaWQgY29uZmlnIG9yIGludmFsaWQgY29uZmlnLnVybCBmb3Igc2VuZEh0dHAgQVBJJylcbiAgICB9XG5cbiAgICB2YXIgc2VuZGVyID0gdGhpcy5zZW5kZXJcbiAgICB2YXIgbWV0aG9kID0gcGFyYW0ubWV0aG9kIHx8ICdHRVQnXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgeGhyLm9wZW4obWV0aG9kLCBwYXJhbS51cmwsIHRydWUpXG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwgdGhpcy5yZXNwb25zZVRleHQpXG4gICAgfVxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gbG9nZ2VyLmVycm9yKCd1bmV4cGVjdGVkIGVycm9yIGluIHNlbmRIdHRwIEFQSScsIGVycm9yKVxuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhcbiAgICAgICAgY2FsbGJhY2tJZCxcbiAgICAgICAgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGVycm9yIGluIHNlbmRIdHRwIEFQSScpXG4gICAgICApXG4gICAgfVxuICAgIHhoci5zZW5kKClcbiAgfSxcblxuICAvKipcbiAgICogZmV0Y2hcbiAgICogdXNlIHN0cmVhbS5mZXRjaCB0byByZXF1ZXN0IGZvciBhIGpzb24gZmlsZSwgYSBwbGFpbiB0ZXh0IGZpbGUgb3JcbiAgICogYSBhcnJheWJ1ZmZlciBmb3IgYSBmaWxlIHN0cmVhbS4gKFlvdSBjYW4gdXNlIEJsb2IgYW5kIEZpbGVSZWFkZXJcbiAgICogQVBJIGltcGxlbWVudGVkIGJ5IG1vc3QgbW9kZXJuIGJyb3dzZXJzIHRvIHJlYWQgYSBhcnJheWJ1ZmZlci4pXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBjb25maWcgb3B0aW9uc1xuICAgKiAgIC0gbWV0aG9kIHtzdHJpbmd9ICdHRVQnIHwgJ1BPU1QnXG4gICAqICAgLSBoZWFkZXJzIHtvYmp9XG4gICAqICAgLSB1cmwge3N0cmluZ31cbiAgICogICAtIG1vZGUge3N0cmluZ30gJ2NvcnMnIHwgJ25vLWNvcnMnIHwgJ3NhbWUtb3JpZ2luJyB8ICduYXZpZ2F0ZSdcbiAgICogICAtIGJvZHlcbiAgICogICAtIHR5cGUge3N0cmluZ30gJ2pzb24nIHwgJ2pzb25wJyB8ICd0ZXh0J1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNhbGxiYWNrSWRcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwcm9ncmVzc0NhbGxiYWNrSWRcbiAgICovXG4gIGZldGNoOiBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2tJZCwgcHJvZ3Jlc3NDYWxsYmFja0lkKSB7XG5cbiAgICB2YXIgREVGQVVMVF9NRVRIT0QgPSAnR0VUJ1xuICAgIHZhciBERUZBVUxUX01PREUgPSAnY29ycydcbiAgICB2YXIgREVGQVVMVF9UWVBFID0gJ3RleHQnXG5cbiAgICB2YXIgbWV0aG9kT3B0aW9ucyA9IFsnR0VUJywgJ1BPU1QnXVxuICAgIHZhciBtb2RlT3B0aW9ucyA9IFsnY29ycycsICduby1jb3JzJywgJ3NhbWUtb3JpZ2luJywgJ25hdmlnYXRlJ11cbiAgICB2YXIgdHlwZU9wdGlvbnMgPSBbJ3RleHQnLCAnanNvbicsICdqc29ucCcsICdhcnJheWJ1ZmZlciddXG5cbiAgICB2YXIgZmFsbGJhY2sgPSBmYWxzZSAgLy8gZmFsbGJhY2sgZnJvbSAnZmV0Y2gnIEFQSSB0byBYSFIuXG4gICAgdmFyIHNlbmRlciA9IHRoaXMuc2VuZGVyXG5cbiAgICB2YXIgY29uZmlnID0gdXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zKVxuXG4gICAgLy8gdmFsaWRhdGUgb3B0aW9ucy5tZXRob2RcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5tZXRob2QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWcubWV0aG9kID0gREVGQVVMVF9NRVRIT0RcbiAgICAgIGxvZ2dlci53YXJuKCdvcHRpb25zLm1ldGhvZCBmb3IgXFwnZmV0Y2hcXCcgQVBJIGhhcyBiZWVuIHNldCB0byAnXG4gICAgICAgICsgJ2RlZmF1bHQgdmFsdWUgXFwnJyArIGNvbmZpZy5tZXRob2QgKyAnXFwnJylcbiAgICB9IGVsc2UgaWYgKG1ldGhvZE9wdGlvbnMuaW5kZXhPZigoY29uZmlnLm1ldGhvZCArICcnKVxuICAgICAgICAudG9VcHBlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICByZXR1cm4gbG9nZ2VyLmVycm9yKCdvcHRpb25zLm1ldGhvZCBcXCcnXG4gICAgICAgICsgY29uZmlnLm1ldGhvZFxuICAgICAgICArICdcXCcgZm9yIFxcJ2ZldGNoXFwnIEFQSSBzaG91bGQgYmUgb25lIG9mICdcbiAgICAgICAgKyBtZXRob2RPcHRpb25zICsgJy4nKVxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnMudXJsXG4gICAgaWYgKCFjb25maWcudXJsKSB7XG4gICAgICByZXR1cm4gbG9nZ2VyLmVycm9yKCdvcHRpb25zLnVybCBzaG91bGQgYmUgc2V0IGZvciBcXCdmZXRjaFxcJyBBUEkuJylcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zLm1vZGVcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5tb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uZmlnLm1vZGUgPSBERUZBVUxUX01PREVcbiAgICB9IGVsc2UgaWYgKG1vZGVPcHRpb25zLmluZGV4T2YoKGNvbmZpZy5tb2RlICsgJycpLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGxvZ2dlci5lcnJvcignb3B0aW9ucy5tb2RlIFxcJydcbiAgICAgICAgKyBjb25maWcubW9kZVxuICAgICAgICArICdcXCcgZm9yIFxcJ2ZldGNoXFwnIEFQSSBzaG91bGQgYmUgb25lIG9mICdcbiAgICAgICAgKyBtb2RlT3B0aW9ucyArICcuJylcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zLnR5cGVcbiAgICBpZiAodHlwZW9mIGNvbmZpZy50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uZmlnLnR5cGUgPSBERUZBVUxUX1RZUEVcbiAgICAgIGxvZ2dlci53YXJuKCdvcHRpb25zLnR5cGUgZm9yIFxcJ2ZldGNoXFwnIEFQSSBoYXMgYmVlbiBzZXQgdG8gJ1xuICAgICAgICArICdkZWZhdWx0IHZhbHVlIFxcJycgKyBjb25maWcudHlwZSArICdcXCcuJylcbiAgICB9IGVsc2UgaWYgKHR5cGVPcHRpb25zLmluZGV4T2YoKGNvbmZpZy50eXBlICsgJycpLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGxvZ2dlci5lcnJvcignb3B0aW9ucy50eXBlIFxcJydcbiAgICAgICAgICArIGNvbmZpZy50eXBlXG4gICAgICAgICAgKyAnXFwnIGZvciBcXCdmZXRjaFxcJyBBUEkgc2hvdWxkIGJlIG9uZSBvZiAnXG4gICAgICAgICAgKyB0eXBlT3B0aW9ucyArICcuJylcbiAgICB9XG5cbiAgICB2YXIgX2NhbGxBcmdzID0gW2NvbmZpZywgZnVuY3Rpb24gKHJlcykge1xuICAgICAgc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCByZXMpXG4gICAgfV1cbiAgICBpZiAocHJvZ3Jlc3NDYWxsYmFja0lkKSB7XG4gICAgICBfY2FsbEFyZ3MucHVzaChmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIC8vIFNldCAna2VlcEFsaXZlJyB0byB0cnVlIGZvciBzZW5kaW5nIGNvbnRpbnVvdXMgY2FsbGJhY2tzXG4gICAgICAgIHNlbmRlci5wZXJmb3JtQ2FsbGJhY2socHJvZ3Jlc3NDYWxsYmFja0lkLCByZXMsIHRydWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChjb25maWcudHlwZSA9PT0gJ2pzb25wJykge1xuICAgICAgX2pzb25wLmFwcGx5KHRoaXMsIF9jYWxsQXJncylcbiAgICB9IGVsc2Uge1xuICAgICAgX3hoci5hcHBseSh0aGlzLCBfY2FsbEFyZ3MpXG4gICAgfVxuICB9XG5cbn1cblxuc3RyZWFtLl9tZXRhID0ge1xuICBzdHJlYW06IFt7XG4gICAgbmFtZTogJ3NlbmRIdHRwJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAnZmV0Y2gnLFxuICAgIGFyZ3M6IFsnb2JqZWN0JywgJ2Z1bmN0aW9uJywgJ2Z1bmN0aW9uJ11cbiAgfV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJlYW1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9hcGkvc3RyZWFtLmpzXG4gKiogbW9kdWxlIGlkID0gMTAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgJiYgKHdpbmRvdyA9IHtjdHJsOiB7fSwgbGliOiB7fX0pOyF3aW5kb3cuY3RybCAmJiAod2luZG93LmN0cmwgPSB7fSk7IXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSk7IWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXt2YXIgYj17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInBhcmFtc1wiLHtzZXQ6ZnVuY3Rpb24oYSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEpe2Zvcih2YXIgYyBpbiBiKWRlbGV0ZSBiW2NdO2Zvcih2YXIgYyBpbiBhKWJbY109YVtjXX19LGdldDpmdW5jdGlvbigpe3JldHVybiBifSxlbnVtZXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJzZWFyY2hcIix7c2V0OmZ1bmN0aW9uKGEpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXswPT09YS5pbmRleE9mKFwiP1wiKSYmKGE9YS5zdWJzdHIoMSkpO3ZhciBjPWEuc3BsaXQoXCImXCIpO2Zvcih2YXIgZCBpbiBiKWRlbGV0ZSBiW2RdO2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKXt2YXIgZj1jW2VdLnNwbGl0KFwiPVwiKTtpZih2b2lkIDAhPT1mWzFdJiYoZlsxXT1mWzFdLnRvU3RyaW5nKCkpLGZbMF0pdHJ5e2JbZGVjb2RlVVJJQ29tcG9uZW50KGZbMF0pXT1kZWNvZGVVUklDb21wb25lbnQoZlsxXSl9Y2F0Y2goZyl7YltmWzBdXT1mWzFdfX19fSxnZXQ6ZnVuY3Rpb24oKXt2YXIgYT1bXTtmb3IodmFyIGMgaW4gYilpZih2b2lkIDAhPT1iW2NdKWlmKFwiXCIhPT1iW2NdKXRyeXthLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGMpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChiW2NdKSl9Y2F0Y2goZCl7YS5wdXNoKGMrXCI9XCIrYltjXSl9ZWxzZSB0cnl7YS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjKSl9Y2F0Y2goZCl7YS5wdXNoKGMpfXJldHVybiBhLmxlbmd0aD9cIj9cIithLmpvaW4oXCImXCIpOlwiXCJ9LGVudW1lcmFibGU6ITB9KTt2YXIgYztPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImhhc2hcIix7c2V0OmZ1bmN0aW9uKGEpe1wic3RyaW5nXCI9PXR5cGVvZiBhJiYoYSYmYS5pbmRleE9mKFwiI1wiKTwwJiYoYT1cIiNcIithKSxjPWF8fFwiXCIpfSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY30sZW51bWVyYWJsZTohMH0pLHRoaXMuc2V0PWZ1bmN0aW9uKGEpe2E9YXx8XCJcIjt2YXIgYjtpZighKGI9YS5tYXRjaChuZXcgUmVnRXhwKFwiXihbYS16MC05LV0rOik/Wy9dezJ9KD86KFteQC86P10rKSg/OjooW15ALzpdKykpP0ApPyhbXjovPyNdKykoPzpbOl0oWzAtOV0rKSk/KFsvXVtePyM7XSopPyg/Ols/XShbXiNdKikpPyhbI11bXj9dKik/JFwiLFwiaVwiKSkpKXRocm93IG5ldyBFcnJvcihcIldyb25nIHVyaSBzY2hlbWUuXCIpO3RoaXMucHJvdG9jb2w9YlsxXXx8KFwib2JqZWN0XCI9PXR5cGVvZiBsb2NhdGlvbj9sb2NhdGlvbi5wcm90b2NvbDpcIlwiKSx0aGlzLnVzZXJuYW1lPWJbMl18fFwiXCIsdGhpcy5wYXNzd29yZD1iWzNdfHxcIlwiLHRoaXMuaG9zdG5hbWU9dGhpcy5ob3N0PWJbNF0sdGhpcy5wb3J0PWJbNV18fFwiXCIsdGhpcy5wYXRobmFtZT1iWzZdfHxcIi9cIix0aGlzLnNlYXJjaD1iWzddfHxcIlwiLHRoaXMuaGFzaD1iWzhdfHxcIlwiLHRoaXMub3JpZ2luPXRoaXMucHJvdG9jb2wrXCIvL1wiK3RoaXMuaG9zdG5hbWV9LHRoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnByb3RvY29sK1wiLy9cIjtyZXR1cm4gdGhpcy51c2VybmFtZSYmKGErPXRoaXMudXNlcm5hbWUsdGhpcy5wYXNzd29yZCYmKGErPVwiOlwiK3RoaXMucGFzc3dvcmQpLGErPVwiQFwiKSxhKz10aGlzLmhvc3QsdGhpcy5wb3J0JiZcIjgwXCIhPT10aGlzLnBvcnQmJihhKz1cIjpcIit0aGlzLnBvcnQpLHRoaXMucGF0aG5hbWUmJihhKz10aGlzLnBhdGhuYW1lKSx0aGlzLnNlYXJjaCYmKGErPXRoaXMuc2VhcmNoKSx0aGlzLmhhc2gmJihhKz10aGlzLmhhc2gpLGF9LGEmJnRoaXMuc2V0KGEudG9TdHJpbmcoKSl9Yi5odHRwdXJsPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhKX19KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpOzttb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5saWJbJ2h0dHB1cmwnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L34vaHR0cHVybC9idWlsZC9odHRwdXJsLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIG1vZGFsID0gcmVxdWlyZSgnbW9kYWxzJylcblxudmFyIG1zZyA9IHtcblxuICAvLyBkdXJhdGlvbjogZGVmYXVsdCBpcyAwLjggc2Vjb25kcy5cbiAgdG9hc3Q6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBtb2RhbC50b2FzdChjb25maWcubWVzc2FnZSwgY29uZmlnLmR1cmF0aW9uKVxuICB9LFxuXG4gIC8vIGNvbmZpZzpcbiAgLy8gIC0gbWVzc2FnZTogc3RyaW5nXG4gIC8vICAtIG9rVGl0bGU6IHRpdGxlIG9mIG9rIGJ1dHRvblxuICAvLyAgLSBjYWxsYmFja1xuICBhbGVydDogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2tJZCkge1xuICAgIHZhciBzZW5kZXIgPSAgdGhpcy5zZW5kZXJcbiAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQpXG4gICAgfVxuICAgIG1vZGFsLmFsZXJ0KGNvbmZpZylcbiAgfSxcblxuICAvLyBjb25maWc6XG4gIC8vICAtIG1lc3NhZ2U6IHN0cmluZ1xuICAvLyAgLSBva1RpdGxlOiB0aXRsZSBvZiBvayBidXR0b25cbiAgLy8gIC0gY2FuY2VsVGl0bGU6IHRpdGxlIG9mIGNhbmNlbCBidXR0b25cbiAgLy8gIC0gY2FsbGJhY2tcbiAgY29uZmlybTogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2tJZCkge1xuICAgIHZhciBzZW5kZXIgPSAgdGhpcy5zZW5kZXJcbiAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHZhbClcbiAgICB9XG4gICAgbW9kYWwuY29uZmlybShjb25maWcpXG4gIH0sXG5cbiAgLy8gY29uZmlnOlxuICAvLyAgLSBtZXNzYWdlOiBzdHJpbmdcbiAgLy8gIC0gb2tUaXRsZTogdGl0bGUgb2Ygb2sgYnV0dG9uXG4gIC8vICAtIGNhbmNlbFRpdGxlOiB0aXRsZSBvZiBjYW5jZWwgYnV0dG9uXG4gIC8vICAtIGNhbGxiYWNrXG4gIHByb21wdDogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2tJZCkge1xuICAgIHZhciBzZW5kZXIgPSAgdGhpcy5zZW5kZXJcbiAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHZhbClcbiAgICB9XG4gICAgbW9kYWwucHJvbXB0KGNvbmZpZylcbiAgfVxuXG59XG5cbm1zZy5fbWV0YSA9IHtcbiAgbW9kYWw6IFt7XG4gICAgbmFtZTogJ3RvYXN0JyxcbiAgICBhcmdzOiBbJ29iamVjdCddXG4gIH0sIHtcbiAgICBuYW1lOiAnYWxlcnQnLFxuICAgIGFyZ3M6IFsnb2JqZWN0JywgJ3N0cmluZyddXG4gIH0sIHtcbiAgICBuYW1lOiAnY29uZmlybScsXG4gICAgYXJnczogWydvYmplY3QnLCAnc3RyaW5nJ11cbiAgfSwge1xuICAgIG5hbWU6ICdwcm9tcHQnLFxuICAgIGFyZ3M6IFsnb2JqZWN0JywgJ3N0cmluZyddXG4gIH1dXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbXNnXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9hcGkvbW9kYWwuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBBbGVydCA9IHJlcXVpcmUoJy4vYWxlcnQnKVxudmFyIENvbmZpcm0gPSByZXF1aXJlKCcuL2NvbmZpcm0nKVxudmFyIFByb21wdCA9IHJlcXVpcmUoJy4vcHJvbXB0JylcbnZhciB0b2FzdCA9IHJlcXVpcmUoJy4vdG9hc3QnKVxuXG52YXIgbW9kYWwgPSB7XG5cbiAgdG9hc3Q6IGZ1bmN0aW9uIChtc2csIGR1cmF0aW9uKSB7XG4gICAgdG9hc3QucHVzaChtc2csIGR1cmF0aW9uKVxuICB9LFxuXG4gIGFsZXJ0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgbmV3IEFsZXJ0KGNvbmZpZykuc2hvdygpXG4gIH0sXG5cbiAgcHJvbXB0OiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgbmV3IFByb21wdChjb25maWcpLnNob3coKVxuICB9LFxuXG4gIGNvbmZpcm06IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICBuZXcgQ29uZmlybShjb25maWcpLnNob3coKVxuICB9XG5cbn1cblxuIXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSlcbndpbmRvdy5saWIubW9kYWwgPSBtb2RhbFxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vZGFsXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9+L21vZGFscy9zcmMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBNb2RhbCA9IHJlcXVpcmUoJy4vbW9kYWwnKVxucmVxdWlyZSgnLi4vc3R5bGVzL2FsZXJ0LmNzcycpXG5cbnZhciBDT05URU5UX0NMQVNTID0gJ2NvbnRlbnQnXG52YXIgTVNHX0NMQVNTID0gJ2NvbnRlbnQtbXNnJ1xudmFyIEJVVFRPTl9HUk9VUF9DTEFTUyA9ICdidG4tZ3JvdXAnXG52YXIgQlVUVE9OX0NMQVNTID0gJ2J0bidcblxuZnVuY3Rpb24gQWxlcnQoY29uZmlnKSB7XG4gIHRoaXMubXNnID0gY29uZmlnLm1lc3NhZ2UgfHwgJydcbiAgdGhpcy5jYWxsYmFjayA9IGNvbmZpZy5jYWxsYmFja1xuICB0aGlzLm9rVGl0bGUgPSBjb25maWcub2tUaXRsZSB8fCAnT0snXG4gIE1vZGFsLmNhbGwodGhpcylcbiAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FtZmUtYWxlcnQnKVxufVxuXG5BbGVydC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZGFsLnByb3RvdHlwZSlcblxuQWxlcnQucHJvdG90eXBlLmNyZWF0ZU5vZGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChDT05URU5UX0NMQVNTKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY29udGVudClcblxuICB2YXIgbXNnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgbXNnLmNsYXNzTGlzdC5hZGQoTVNHX0NMQVNTKVxuICBtc2cuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5tc2cpKVxuICBjb250ZW50LmFwcGVuZENoaWxkKG1zZylcblxuICB2YXIgYnV0dG9uR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b25Hcm91cC5jbGFzc0xpc3QuYWRkKEJVVFRPTl9HUk9VUF9DTEFTUylcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGJ1dHRvbkdyb3VwKVxuICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoQlVUVE9OX0NMQVNTLCAnYWxlcnQtb2snKVxuICBidXR0b24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5va1RpdGxlKSlcbiAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQoYnV0dG9uKVxufVxuXG5BbGVydC5wcm90b3R5cGUuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgTW9kYWwucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbCh0aGlzKVxuICB2YXIgYnV0dG9uID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTKVxuICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2soKVxuICB9LmJpbmQodGhpcykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQWxlcnRcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3JjL2FsZXJ0LmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuLi9zdHlsZXMvbW9kYWwuY3NzJylcblxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBpbnN0YW5jZSBvZiBtb2RhbC5cbnZhciBNT0RBTF9XUkFQX0NMQVNTID0gJ2FtZmUtbW9kYWwtd3JhcCdcbnZhciBNT0RBTF9OT0RFX0NMQVNTID0gJ2FtZmUtbW9kYWwtbm9kZSdcblxuZnVuY3Rpb24gTW9kYWwoKSB7XG4gIHRoaXMud3JhcCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoTU9EQUxfV1JBUF9DTEFTUylcbiAgdGhpcy5ub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihNT0RBTF9OT0RFX0NMQVNTKVxuICBpZiAoIXRoaXMud3JhcCkge1xuICAgIHRoaXMuY3JlYXRlV3JhcCgpXG4gIH1cbiAgaWYgKCF0aGlzLm5vZGUpIHtcbiAgICB0aGlzLmNyZWF0ZU5vZGUoKVxuICB9XG4gIHRoaXMuY2xlYXJOb2RlKClcbiAgdGhpcy5jcmVhdGVOb2RlQ29udGVudCgpXG4gIHRoaXMuYmluZEV2ZW50cygpXG59XG5cbk1vZGFsLnByb3RvdHlwZSA9IHtcblxuICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy53cmFwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUnKVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMud3JhcClcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubm9kZSlcbiAgICB0aGlzLndyYXAgPSBudWxsXG4gICAgdGhpcy5ub2RlID0gbnVsbFxuICB9LFxuXG4gIGNyZWF0ZVdyYXA6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLndyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMud3JhcC5jbGFzc05hbWUgPSBNT0RBTF9XUkFQX0NMQVNTXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLndyYXApXG4gIH0sXG5cbiAgY3JlYXRlTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoTU9EQUxfTk9ERV9DTEFTUywgJ2hpZGUnKVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKVxuICB9LFxuXG4gIGNsZWFyTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubm9kZS5pbm5lckhUTUwgPSAnJ1xuICB9LFxuXG4gIGNyZWF0ZU5vZGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBkbyBub3RoaW5nLlxuICAgIC8vIGNoaWxkIGNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICB9LFxuXG4gIGJpbmRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLndyYXAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGFsXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3NyYy9tb2RhbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vbW9kYWwuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2RhbC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL21vZGFsLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9+L21vZGFscy9zdHlsZXMvbW9kYWwuY3NzXG4gKiogbW9kdWxlIGlkID0gMTA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYW1mZS1tb2RhbC13cmFwIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xcbiAgb3BhY2l0eTogMC41O1xcbn1cXG5cXG4uYW1mZS1tb2RhbC1ub2RlIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHdpZHRoOiA2LjY2NjY2N3JlbTtcXG4gIG1pbi1oZWlnaHQ6IDIuNjY2NjY3cmVtO1xcbiAgYm9yZGVyLXJhZGl1czogMC4wNjY2NjdyZW07XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbn1cXG4uYW1mZS1tb2RhbC1ub2RlLmhpZGUge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmFtZmUtbW9kYWwtbm9kZSAuY29udGVudCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1pbi1oZWlnaHQ6IDEuODY2NjY3cmVtO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGZvbnQtc2l6ZTogMC4zMnJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjQyNjY2N3JlbTtcXG4gIHBhZGRpbmc6IDAuMjEzMzMzcmVtO1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxufVxcbi5hbWZlLW1vZGFsLW5vZGUgLmJ0bi1ncm91cCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMC44cmVtO1xcbiAgZm9udC1zaXplOiAwLjM3MzMzM3JlbTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuLmFtZmUtbW9kYWwtbm9kZSAuYnRuLWdyb3VwIC5idG4ge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGhlaWdodDogMC44cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDAuOHJlbTtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vd2VleC1odG1sNS9+L21vZGFscy9zdHlsZXMvbW9kYWwuY3NzXG4gKiogbW9kdWxlIGlkID0gMTEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9hbGVydC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2FsZXJ0LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYWxlcnQuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3N0eWxlcy9hbGVydC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hbWZlLWFsZXJ0IC5hbWZlLWFsZXJ0LW9rIHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3N0eWxlcy9hbGVydC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBNb2RhbCA9IHJlcXVpcmUoJy4vbW9kYWwnKVxucmVxdWlyZSgnLi4vc3R5bGVzL2NvbmZpcm0uY3NzJylcblxudmFyIENPTlRFTlRfQ0xBU1MgPSAnY29udGVudCdcbnZhciBNU0dfQ0xBU1MgPSAnY29udGVudC1tc2cnXG52YXIgQlVUVE9OX0dST1VQX0NMQVNTID0gJ2J0bi1ncm91cCdcbnZhciBCVVRUT05fQ0xBU1MgPSAnYnRuJ1xuXG5mdW5jdGlvbiBDb25maXJtKGNvbmZpZykge1xuICB0aGlzLm1zZyA9IGNvbmZpZy5tZXNzYWdlIHx8ICcnXG4gIHRoaXMuY2FsbGJhY2sgPSBjb25maWcuY2FsbGJhY2tcbiAgdGhpcy5va1RpdGxlID0gY29uZmlnLm9rVGl0bGUgfHwgJ09LJ1xuICB0aGlzLmNhbmNlbFRpdGxlID0gY29uZmlnLmNhbmNlbFRpdGxlIHx8ICdDYW5jZWwnXG4gIE1vZGFsLmNhbGwodGhpcylcbiAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FtZmUtY29uZmlybScpXG59XG5cbkNvbmZpcm0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2RhbC5wcm90b3R5cGUpXG5cbkNvbmZpcm0ucHJvdG90eXBlLmNyZWF0ZU5vZGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChDT05URU5UX0NMQVNTKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY29udGVudClcblxuICB2YXIgbXNnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgbXNnLmNsYXNzTGlzdC5hZGQoTVNHX0NMQVNTKVxuICBtc2cuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5tc2cpKVxuICBjb250ZW50LmFwcGVuZENoaWxkKG1zZylcblxuICB2YXIgYnV0dG9uR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidXR0b25Hcm91cC5jbGFzc0xpc3QuYWRkKEJVVFRPTl9HUk9VUF9DTEFTUylcbiAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGJ1dHRvbkdyb3VwKVxuICB2YXIgYnRuT2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidG5Pay5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm9rVGl0bGUpKVxuICBidG5Pay5jbGFzc0xpc3QuYWRkKCdidG4tb2snLCBCVVRUT05fQ0xBU1MpXG4gIHZhciBidG5DYW5jZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidG5DYW5jZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jYW5jZWxUaXRsZSkpXG4gIGJ0bkNhbmNlbC5jbGFzc0xpc3QuYWRkKCdidG4tY2FuY2VsJywgQlVUVE9OX0NMQVNTKVxuICBidXR0b25Hcm91cC5hcHBlbmRDaGlsZChidG5PaylcbiAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQoYnRuQ2FuY2VsKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoYnV0dG9uR3JvdXApXG59XG5cbkNvbmZpcm0ucHJvdG90eXBlLmJpbmRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIE1vZGFsLnByb3RvdHlwZS5iaW5kRXZlbnRzLmNhbGwodGhpcylcbiAgdmFyIGJ0bk9rID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTICsgJy5idG4tb2snKVxuICB2YXIgYnRuQ2FuY2VsID0gdGhpcy5ub2RlLnF1ZXJ5U2VsZWN0b3IoJy4nICsgQlVUVE9OX0NMQVNTICsgJy5idG4tY2FuY2VsJylcbiAgYnRuT2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2sodGhpcy5va1RpdGxlKVxuICB9LmJpbmQodGhpcykpXG4gIGJ0bkNhbmNlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3Ryb3koKVxuICAgIHRoaXMuY2FsbGJhY2sgJiYgdGhpcy5jYWxsYmFjayh0aGlzLmNhbmNlbFRpdGxlKVxuICB9LmJpbmQodGhpcykpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29uZmlybVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9+L21vZGFscy9zcmMvY29uZmlybS5qc1xuICoqIG1vZHVsZSBpZCA9IDExM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY29uZmlybS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2NvbmZpcm0uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jb25maXJtLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9+L21vZGFscy9zdHlsZXMvY29uZmlybS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hbWZlLWNvbmZpcm0gLmJ0bi1ncm91cCAuYnRuIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgd2lkdGg6IDUwJTtcXG59XFxuLmFtZmUtY29uZmlybSAuYnRuLWdyb3VwIC5idG4uYnRuLW9rIHtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3R5bGVzL2NvbmZpcm0uY3NzXG4gKiogbW9kdWxlIGlkID0gMTE1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgTW9kYWwgPSByZXF1aXJlKCcuL21vZGFsJylcbnJlcXVpcmUoJy4uL3N0eWxlcy9wcm9tcHQuY3NzJylcblxudmFyIENPTlRFTlRfQ0xBU1MgPSAnY29udGVudCdcbnZhciBNU0dfQ0xBU1MgPSAnY29udGVudC1tc2cnXG52YXIgQlVUVE9OX0dST1VQX0NMQVNTID0gJ2J0bi1ncm91cCdcbnZhciBCVVRUT05fQ0xBU1MgPSAnYnRuJ1xudmFyIElOUFVUX1dSQVBfQ0xBU1MgPSAnaW5wdXQtd3JhcCdcbnZhciBJTlBVVF9DTEFTUyA9ICdpbnB1dCdcblxuZnVuY3Rpb24gUHJvbXB0KGNvbmZpZykge1xuICB0aGlzLm1zZyA9IGNvbmZpZy5tZXNzYWdlIHx8ICcnXG4gIHRoaXMuZGVmYXVsdE1zZyA9IGNvbmZpZy5kZWZhdWx0IHx8ICcnXG4gIHRoaXMuY2FsbGJhY2sgPSBjb25maWcuY2FsbGJhY2tcbiAgdGhpcy5va1RpdGxlID0gY29uZmlnLm9rVGl0bGUgfHwgJ09LJ1xuICB0aGlzLmNhbmNlbFRpdGxlID0gY29uZmlnLmNhbmNlbFRpdGxlIHx8ICdDYW5jZWwnXG4gIE1vZGFsLmNhbGwodGhpcylcbiAgdGhpcy5ub2RlLmNsYXNzTGlzdC5hZGQoJ2FtZmUtcHJvbXB0Jylcbn1cblxuUHJvbXB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kYWwucHJvdG90eXBlKVxuXG5Qcm9tcHQucHJvdG90eXBlLmNyZWF0ZU5vZGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgY29udGVudC5jbGFzc0xpc3QuYWRkKENPTlRFTlRfQ0xBU1MpXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChjb250ZW50KVxuXG4gIHZhciBtc2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBtc2cuY2xhc3NMaXN0LmFkZChNU0dfQ0xBU1MpXG4gIG1zZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm1zZykpXG4gIGNvbnRlbnQuYXBwZW5kQ2hpbGQobXNnKVxuXG4gIHZhciBpbnB1dFdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBpbnB1dFdyYXAuY2xhc3NMaXN0LmFkZChJTlBVVF9XUkFQX0NMQVNTKVxuICBjb250ZW50LmFwcGVuZENoaWxkKGlucHV0V3JhcClcbiAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICBpbnB1dC5jbGFzc0xpc3QuYWRkKElOUFVUX0NMQVNTKVxuICBpbnB1dC50eXBlID0gJ3RleHQnXG4gIGlucHV0LmF1dG9mb2N1cyA9IHRydWVcbiAgaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLmRlZmF1bHRNc2dcbiAgaW5wdXRXcmFwLmFwcGVuZENoaWxkKGlucHV0KVxuXG4gIHZhciBidXR0b25Hcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGJ1dHRvbkdyb3VwLmNsYXNzTGlzdC5hZGQoQlVUVE9OX0dST1VQX0NMQVNTKVxuICB2YXIgYnRuT2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidG5Pay5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm9rVGl0bGUpKVxuICBidG5Pay5jbGFzc0xpc3QuYWRkKCdidG4tb2snLCBCVVRUT05fQ0xBU1MpXG4gIHZhciBidG5DYW5jZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBidG5DYW5jZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5jYW5jZWxUaXRsZSkpXG4gIGJ0bkNhbmNlbC5jbGFzc0xpc3QuYWRkKCdidG4tY2FuY2VsJywgQlVUVE9OX0NMQVNTKVxuICBidXR0b25Hcm91cC5hcHBlbmRDaGlsZChidG5PaylcbiAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQoYnRuQ2FuY2VsKVxuICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoYnV0dG9uR3JvdXApXG59XG5cblByb21wdC5wcm90b3R5cGUuYmluZEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgTW9kYWwucHJvdG90eXBlLmJpbmRFdmVudHMuY2FsbCh0aGlzKVxuICB2YXIgYnRuT2sgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignLicgKyBCVVRUT05fQ0xBU1MgKyAnLmJ0bi1vaycpXG4gIHZhciBidG5DYW5jZWwgPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignLicgKyBCVVRUT05fQ0xBU1MgKyAnLmJ0bi1jYW5jZWwnKVxuICB2YXIgdGhhdCA9IHRoaXNcbiAgYnRuT2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykudmFsdWVcbiAgICB0aGlzLmRlc3Ryb3koKVxuICAgIHRoaXMuY2FsbGJhY2sgJiYgdGhpcy5jYWxsYmFjayh7XG4gICAgICByZXN1bHQ6IHRoYXQub2tUaXRsZSxcbiAgICAgIGRhdGE6IHZhbFxuICAgIH0pXG4gIH0uYmluZCh0aGlzKSlcbiAgYnRuQ2FuY2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnZhbHVlXG4gICAgdGhpcy5kZXN0cm95KClcbiAgICB0aGlzLmNhbGxiYWNrICYmIHRoaXMuY2FsbGJhY2soe1xuICAgICAgcmVzdWx0OiB0aGF0LmNhbmNlbFRpdGxlXG4gICAgfSlcbiAgfS5iaW5kKHRoaXMpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21wdFxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9+L21vZGFscy9zcmMvcHJvbXB0LmpzXG4gKiogbW9kdWxlIGlkID0gMTE2XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcm9tcHQuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uLy4uLy4uL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcm9tcHQuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9wcm9tcHQuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3N0eWxlcy9wcm9tcHQuY3NzXG4gKiogbW9kdWxlIGlkID0gMTE3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYW1mZS1wcm9tcHQgLmlucHV0LXdyYXAge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogMC4yNHJlbSAwLjIxMzMzM3JlbSAwLjIxMzMzM3JlbTtcXG4gIGhlaWdodDogMC45NnJlbTtcXG59XFxuLmFtZmUtcHJvbXB0IC5pbnB1dC13cmFwIC5pbnB1dCB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDAuNTZyZW07XFxuICBsaW5lLWhlaWdodDogMC41NnJlbTtcXG4gIGZvbnQtc2l6ZTogMC4zMnJlbTtcXG59XFxuLmFtZmUtcHJvbXB0IC5idG4tZ3JvdXAgLmJ0biB7XFxuICBmbG9hdDogbGVmdDtcXG4gIHdpZHRoOiA1MCU7XFxufVxcbi5hbWZlLXByb21wdCAuYnRuLWdyb3VwIC5idG4uYnRuLW9rIHtcXG4gIGJvcmRlci1yaWdodDogMXB4IHNvbGlkICNkZGQ7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3R5bGVzL3Byb21wdC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnJlcXVpcmUoJy4uL3N0eWxlcy90b2FzdC5jc3MnKVxuXG52YXIgcXVldWUgPSBbXVxudmFyIHRpbWVyXG52YXIgaXNQcm9jZXNzaW5nID0gZmFsc2VcbnZhciB0b2FzdFdpblxudmFyIFRPQVNUX1dJTl9DTEFTU19OQU1FID0gJ2FtZmUtdG9hc3QnXG5cbnZhciBERUZBVUxUX0RVUkFUSU9OID0gMC44XG5cbmZ1bmN0aW9uIHNob3dUb2FzdFdpbmRvdyhtc2csIGNhbGxiYWNrKSB7XG4gIHZhciBoYW5kbGVUcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRvYXN0V2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVUcmFuc2l0aW9uRW5kKVxuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgfVxuICBpZiAoIXRvYXN0V2luKSB7XG4gICAgdG9hc3RXaW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRvYXN0V2luLmNsYXNzTGlzdC5hZGQoVE9BU1RfV0lOX0NMQVNTX05BTUUsICdoaWRlJylcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvYXN0V2luKVxuICB9XG4gIHRvYXN0V2luLmlubmVySFRNTCA9IG1zZ1xuICB0b2FzdFdpbi5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlVHJhbnNpdGlvbkVuZClcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdG9hc3RXaW4uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpXG4gIH0sIDApXG59XG5cbmZ1bmN0aW9uIGhpZGVUb2FzdFdpbmRvdyhjYWxsYmFjaykge1xuICB2YXIgaGFuZGxlVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0b2FzdFdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlVHJhbnNpdGlvbkVuZClcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXG4gIH1cbiAgaWYgKCF0b2FzdFdpbikge1xuICAgIHJldHVyblxuICB9XG4gIHRvYXN0V2luLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVUcmFuc2l0aW9uRW5kKVxuICB0b2FzdFdpbi5jbGFzc0xpc3QuYWRkKCdoaWRlJylcbn1cblxudmFyIHRvYXN0ID0ge1xuXG4gIHB1c2g6IGZ1bmN0aW9uIChtc2csIGR1cmF0aW9uKSB7XG4gICAgcXVldWUucHVzaCh7XG4gICAgICBtc2c6IG1zZyxcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiB8fCBERUZBVUxUX0RVUkFUSU9OXG4gICAgfSlcbiAgICB0aGlzLnNob3coKVxuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcblxuICAgIC8vIEFsbCBtZXNzYWdlcyBoYWQgYmVlbiB0b2FzdGVkIGFscmVhZHksIHNvIHJlbW92ZSB0aGUgdG9hc3Qgd2luZG93LFxuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICB0b2FzdFdpbiAmJiB0b2FzdFdpbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvYXN0V2luKVxuICAgICAgdG9hc3RXaW4gPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB0aGUgcHJldmlvdXMgdG9hc3QgaXMgbm90IGVuZGVkIHlldC5cbiAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaXNQcm9jZXNzaW5nID0gdHJ1ZVxuXG4gICAgdmFyIHRvYXN0SW5mbyA9IHF1ZXVlLnNoaWZ0KClcbiAgICBzaG93VG9hc3RXaW5kb3codG9hc3RJbmZvLm1zZywgZnVuY3Rpb24gKCkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGltZXIgPSBudWxsXG4gICAgICAgIGhpZGVUb2FzdFdpbmRvdyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2VcbiAgICAgICAgICB0aGF0LnNob3coKVxuICAgICAgICB9KVxuICAgICAgfSwgdG9hc3RJbmZvLmR1cmF0aW9uICogMTAwMClcbiAgICB9KVxuICB9XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHB1c2g6IHRvYXN0LnB1c2guYmluZCh0b2FzdClcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvfi9tb2RhbHMvc3JjL3RvYXN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi90b2FzdC5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vLi4vLi4vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCB7fSk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3RvYXN0LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi8uLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vdG9hc3QuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3N0eWxlcy90b2FzdC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hbWZlLXRvYXN0IHtcXG4gIGZvbnQtc2l6ZTogMC4zMnJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAwLjQyNjY2N3JlbTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBtYXgtd2lkdGg6IDgwJTtcXG4gIGJvdHRvbTogMi42NjY2NjdyZW07XFxuICBsZWZ0OiA1MCU7XFxuICBwYWRkaW5nOiAwLjIxMzMzM3JlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XFxuICBjb2xvcjogI2ZmZjtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIG9wYWNpdHk6IDAuNjtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjRzIGVhc2UtaW4tb3V0O1xcbiAgYm9yZGVyLXJhZGl1czogMC4wNjY2NjdyZW07XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcXG59XFxuXFxuLmFtZmUtdG9hc3QuaGlkZSB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi93ZWV4LWh0bWw1L34vbW9kYWxzL3N0eWxlcy90b2FzdC5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxMjFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBTZW5kZXIgPSByZXF1aXJlKCcuLi9icmlkZ2Uvc2VuZGVyJylcblxudmFyIF9kYXRhID0ge31cblxudmFyIGFuaW1hdGlvbiA9IHtcblxuICAvKipcbiAgICogdHJhbnNpdGlvblxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHJlZiAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtvYmp9IGNvbmZpZyAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNhbGxiYWNrSWQgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdHJhbnNpdGlvbjogZnVuY3Rpb24gKHJlZiwgY29uZmlnLCBjYWxsYmFja0lkKSB7XG4gICAgdmFyIHJlZkRhdGEgPSBfZGF0YVtyZWZdXG4gICAgdmFyIHN0eWxlc0tleSA9IEpTT04uc3RyaW5naWZ5KGNvbmZpZy5zdHlsZXMpXG4gICAgdmFyIHdlZXhJbnN0YW5jZSA9IHRoaXNcbiAgICAvLyBJZiB0aGUgc2FtZSBjb21wb25lbnQgcGVyZm9ybSBhIGFuaW1hdGlvbiB3aXRoIGV4YWN0bHkgdGhlIHNhbWVcbiAgICAvLyBzdHlsZXMgaW4gYSBzZXF1ZW5jZSB3aXRoIHNvIHNob3J0IGludGVydmFsIHRoYXQgdGhlIHByZXYgYW5pbWF0aW9uXG4gICAgLy8gaXMgc3RpbGwgaW4gcGxheWluZywgdGhlbiB0aGUgbmV4dCBhbmltYXRpb24gc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgaWYgKHJlZkRhdGEgJiYgcmVmRGF0YVtzdHlsZXNLZXldKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFyZWZEYXRhKSB7XG4gICAgICByZWZEYXRhID0gX2RhdGFbcmVmXSA9IHt9XG4gICAgfVxuICAgIHJlZkRhdGFbc3R5bGVzS2V5XSA9IHRydWVcbiAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnRNYW5hZ2VyKCkudHJhbnNpdGlvbihyZWYsIGNvbmZpZywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzdHlsZXNLZXkgaW4gcmVmRGF0YSBzbyB0aGF0IHRoZSBzYW1lIGFuaW1hdGlvblxuICAgICAgLy8gY2FuIGJlIHBsYXllZCBhZ2FpbiBhZnRlciBjdXJyZW50IGFuaW1hdGlvbiBpcyBhbHJlYWR5IGZpbmlzaGVkLlxuICAgICAgZGVsZXRlIHJlZkRhdGFbc3R5bGVzS2V5XVxuICAgICAgd2VleEluc3RhbmNlLnNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZClcbiAgICB9KVxuICB9XG5cbn1cblxuYW5pbWF0aW9uLl9tZXRhID0ge1xuICBhbmltYXRpb246IFt7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICAgIGFyZ3M6IFsnc3RyaW5nJywgJ29iamVjdCcsICdzdHJpbmcnXVxuICB9XVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFuaW1hdGlvblxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vd2VleC1odG1sNS9zcmMvYXBpL2FuaW1hdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEyMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIHNlbmRlciA9IHJlcXVpcmUoJy4uL2JyaWRnZS9zZW5kZXInKVxuXG52YXIgd2VidmlldyA9IHtcblxuICAvLyByZWY6IHJlZiBvZiB0aGUgd2ViIGNvbXBvbmVudC5cbiAgZ29CYWNrOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHdlYkNvbXAgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5nZXRFbGVtZW50QnlSZWYocmVmKVxuICAgIGlmICghd2ViQ29tcC5nb0JhY2spIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiB0aGUgc3BlY2lmaWVkIGNvbXBvbmVudCBoYXMgbm8gbWV0aG9kIG9mJ1xuICAgICAgICAgICsgJyBnb0JhY2suIFBsZWFzZSBtYWtlIHN1cmUgaXQgaXMgYSB3ZWJ2aWV3IGNvbXBvbmVudC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHdlYkNvbXAuZ29CYWNrKClcbiAgfSxcblxuICAvLyByZWY6IHJlZiBvZiB0aGUgd2ViIGNvbXBvbmVudC5cbiAgZ29Gb3J3YXJkOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHdlYkNvbXAgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5nZXRFbGVtZW50QnlSZWYocmVmKVxuICAgIGlmICghd2ViQ29tcC5nb0ZvcndhcmQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiB0aGUgc3BlY2lmaWVkIGNvbXBvbmVudCBoYXMgbm8gbWV0aG9kIG9mJ1xuICAgICAgICAgICsgJyBnb0ZvcndhcmQuIFBsZWFzZSBtYWtlIHN1cmUgaXQgaXMgYSB3ZWJ2aWV3IGNvbXBvbmVudC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHdlYkNvbXAuZ29Gb3J3YXJkKClcbiAgfSxcblxuICAvLyByZWY6IHJlZiBvZiB0aGUgd2ViIGNvbXBvbmVudC5cbiAgcmVsb2FkOiBmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIHdlYkNvbXAgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKS5nZXRFbGVtZW50QnlSZWYocmVmKVxuICAgIGlmICghd2ViQ29tcC5yZWxvYWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yOiB0aGUgc3BlY2lmaWVkIGNvbXBvbmVudCBoYXMgbm8gbWV0aG9kIG9mJ1xuICAgICAgICAgICsgJyByZWxvYWQuIFBsZWFzZSBtYWtlIHN1cmUgaXQgaXMgYSB3ZWJ2aWV3IGNvbXBvbmVudC4nKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHdlYkNvbXAucmVsb2FkKClcbiAgfVxuXG59XG5cbndlYnZpZXcuX21ldGEgPSB7XG4gIHdlYnZpZXc6IFt7XG4gICAgbmFtZTogJ2dvQmFjaycsXG4gICAgYXJnczogWydzdHJpbmcnXVxuICB9LCB7XG4gICAgbmFtZTogJ2dvRm9yd2FyZCcsXG4gICAgYXJnczogWydzdHJpbmcnXVxuICB9LCB7XG4gICAgbmFtZTogJ3JlbG9hZCcsXG4gICAgYXJnczogWydzdHJpbmcnXVxuICB9XVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdlYnZpZXdcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3dlZXgtaHRtbDUvc3JjL2FwaS93ZWJ2aWV3LmpzXG4gKiogbW9kdWxlIGlkID0gMTIzXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgdGltZXIgPSB7XG5cbiAgc2V0VGltZW91dDogZnVuY3Rpb24gKHRpbWVvdXRDYWxsYmFja0lkLCBkZWxheSkge1xuICAgIHZhciBzZW5kZXIgPSB0aGlzLnNlbmRlclxuICAgIHZhciB0aW1lcklkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZW5kZXIucGVyZm9ybUNhbGxiYWNrKHRpbWVvdXRDYWxsYmFja0lkKVxuICAgIH0sIGRlbGF5KVxuICB9LFxuXG4gIGNsZWFyVGltZW91dDogZnVuY3Rpb24gKHRpbWVySWQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXJJZClcbiAgfVxuXG59XG5cbnRpbWVyLl9tZXRhID0ge1xuICB0aW1lcjogW3tcbiAgICBuYW1lOiAnc2V0VGltZW91dCcsXG4gICAgYXJnczogWydmdW5jdGlvbicsICdudW1iZXInXVxuICB9LCB7XG4gICAgbmFtZTogJ2NsZWFyVGltZW91dCcsXG4gICAgYXJnczogWydudW1iZXInXVxuICB9XVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbWVyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9hcGkvdGltZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBuYXZpZ2F0b3IgPSB7XG5cbiAgLy8gY29uZmlnXG4gIC8vICAtIHVybDogdGhlIHVybCB0byBwdXNoXG4gIC8vICAtIGFuaW1hdGVkOiB0aGlzIGNvbmZpZ3VyYXRpb24gaXRlbSBpcyBuYXRpdmUgb25seVxuICAvLyAgY2FsbGJhY2sgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWRcbiAgcHVzaDogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2tJZCkge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gY29uZmlnLnVybFxuICAgIHRoaXMuc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkKVxuICB9LFxuXG4gIC8vIGNvbmZpZ1xuICAvLyAgLSBhbmltYXRlZDogdGhpcyBjb25maWd1cmF0aW9uIGl0ZW0gaXMgbmF0aXZlIG9ubHlcbiAgLy8gIGNhbGxiYWNrIGlzIG5vdGUgY3VycmVudGx5IHN1cHBvcnRlZFxuICBwb3A6IGZ1bmN0aW9uIChjb25maWcsIGNhbGxiYWNrSWQpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgICB0aGlzLnNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZClcbiAgfVxuXG59XG5cbm5hdmlnYXRvci5fbWV0YSA9IHtcbiAgbmF2aWdhdG9yOiBbe1xuICAgIG5hbWU6ICdwdXNoJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAncG9wJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH1dXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF2aWdhdG9yXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L3NyYy9hcGkvbmF2aWdhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMTI1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgJiYgKHdpbmRvdyA9IHtjdHJsOiB7fSwgbGliOiB7fX0pOyF3aW5kb3cuY3RybCAmJiAod2luZG93LmN0cmwgPSB7fSk7IXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSk7IWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInZhbFwiLHt2YWx1ZTphLnRvU3RyaW5nKCksZW51bWVyYWJsZTohMH0pLHRoaXMuZ3Q9ZnVuY3Rpb24oYSl7cmV0dXJuIGMuY29tcGFyZSh0aGlzLGEpPjB9LHRoaXMuZ3RlPWZ1bmN0aW9uKGEpe3JldHVybiBjLmNvbXBhcmUodGhpcyxhKT49MH0sdGhpcy5sdD1mdW5jdGlvbihhKXtyZXR1cm4gYy5jb21wYXJlKHRoaXMsYSk8MH0sdGhpcy5sdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGMuY29tcGFyZSh0aGlzLGEpPD0wfSx0aGlzLmVxPWZ1bmN0aW9uKGEpe3JldHVybiAwPT09Yy5jb21wYXJlKHRoaXMsYSl9fWIuZW52PWIuZW52fHx7fSxjLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbH0sYy5wcm90b3R5cGUudmFsdWVPZj1mdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzLnZhbC5zcGxpdChcIi5cIiksYj1bXSxjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPXBhcnNlSW50KGFbY10sMTApO2lzTmFOKGQpJiYoZD0wKTt2YXIgZT1kLnRvU3RyaW5nKCk7ZS5sZW5ndGg8NSYmKGU9QXJyYXkoNi1lLmxlbmd0aCkuam9pbihcIjBcIikrZSksYi5wdXNoKGUpLDE9PT1iLmxlbmd0aCYmYi5wdXNoKFwiLlwiKX1yZXR1cm4gcGFyc2VGbG9hdChiLmpvaW4oXCJcIikpfSxjLmNvbXBhcmU9ZnVuY3Rpb24oYSxiKXthPWEudG9TdHJpbmcoKS5zcGxpdChcIi5cIiksYj1iLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGh8fGM8Yi5sZW5ndGg7YysrKXt2YXIgZD1wYXJzZUludChhW2NdLDEwKSxlPXBhcnNlSW50KGJbY10sMTApO2lmKHdpbmRvdy5pc05hTihkKSYmKGQ9MCksd2luZG93LmlzTmFOKGUpJiYoZT0wKSxlPmQpcmV0dXJuLTE7aWYoZD5lKXJldHVybiAxfXJldHVybiAwfSxiLnZlcnNpb249ZnVuY3Rpb24oYSl7cmV0dXJuIG5ldyBjKGEpfX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGM9YS5sb2NhdGlvbi5zZWFyY2gucmVwbGFjZSgvXlxcPy8sXCJcIik7aWYoYi5lbnYucGFyYW1zPXt9LGMpZm9yKHZhciBkPWMuc3BsaXQoXCImXCIpLGU9MDtlPGQubGVuZ3RoO2UrKyl7ZFtlXT1kW2VdLnNwbGl0KFwiPVwiKTt0cnl7Yi5lbnYucGFyYW1zW2RbZV1bMF1dPWRlY29kZVVSSUNvbXBvbmVudChkW2VdWzFdKX1jYXRjaChmKXtiLmVudi5wYXJhbXNbZFtlXVswXV09ZFtlXVsxXX19fSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKSxmdW5jdGlvbihhLGIpe2IuZW52PWIuZW52fHx7fTt2YXIgYyxkPWEubmF2aWdhdG9yLnVzZXJBZ2VudDtpZihjPWQubWF0Y2goL1dpbmRvd3NcXHNQaG9uZVxccyg/Ok9TXFxzKT8oW1xcZFxcLl0rKS8pKWIuZW52Lm9zPXtuYW1lOlwiV2luZG93cyBQaG9uZVwiLGlzV2luZG93c1Bob25lOiEwLHZlcnNpb246Y1sxXX07ZWxzZSBpZihkLm1hdGNoKC9TYWZhcmkvKSYmKGM9ZC5tYXRjaCgvQW5kcm9pZFtcXHNcXC9dKFtcXGRcXC5dKykvKSkpYi5lbnYub3M9e3ZlcnNpb246Y1sxXX0sZC5tYXRjaCgvTW9iaWxlXFxzK1NhZmFyaS8pPyhiLmVudi5vcy5uYW1lPVwiQW5kcm9pZFwiLGIuZW52Lm9zLmlzQW5kcm9pZD0hMCk6KGIuZW52Lm9zLm5hbWU9XCJBbmRyb2lkUGFkXCIsYi5lbnYub3MuaXNBbmRyb2lkUGFkPSEwKTtlbHNlIGlmKGM9ZC5tYXRjaCgvKGlQaG9uZXxpUGFkfGlQb2QpLykpe3ZhciBlPWNbMV07Yz1kLm1hdGNoKC9PUyAoW1xcZF9cXC5dKykgbGlrZSBNYWMgT1MgWC8pLGIuZW52Lm9zPXtuYW1lOmUsaXNJUGhvbmU6XCJpUGhvbmVcIj09PWV8fFwiaVBvZFwiPT09ZSxpc0lQYWQ6XCJpUGFkXCI9PT1lLGlzSU9TOiEwLHZlcnNpb246Y1sxXS5zcGxpdChcIl9cIikuam9pbihcIi5cIil9fWVsc2UgYi5lbnYub3M9e25hbWU6XCJ1bmtub3duXCIsdmVyc2lvbjpcIjAuMC4wXCJ9O2IudmVyc2lvbiYmKGIuZW52Lm9zLnZlcnNpb249Yi52ZXJzaW9uKGIuZW52Lm9zLnZlcnNpb24pKX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGMsZD1hLm5hdmlnYXRvci51c2VyQWdlbnQ7KGM9ZC5tYXRjaCgvKD86VUNXRUJ8VUNCcm93c2VyXFwvKShbXFxkXFwuXSspLykpP2IuZW52LmJyb3dzZXI9e25hbWU6XCJVQ1wiLGlzVUM6ITAsdmVyc2lvbjpjWzFdfTooYz1kLm1hdGNoKC9NUVFCcm93c2VyXFwvKFtcXGRcXC5dKykvKSk/Yi5lbnYuYnJvd3Nlcj17bmFtZTpcIlFRXCIsaXNRUTohMCx2ZXJzaW9uOmNbMV19OihjPWQubWF0Y2goL0ZpcmVmb3hcXC8oW1xcZFxcLl0rKS8pKT9iLmVudi5icm93c2VyPXtuYW1lOlwiRmlyZWZveFwiLGlzRmlyZWZveDohMCx2ZXJzaW9uOmNbMV19OihjPWQubWF0Y2goL01TSUVcXHMoW1xcZFxcLl0rKS8pKXx8KGM9ZC5tYXRjaCgvSUVNb2JpbGVcXC8oW1xcZFxcLl0rKS8pKT8oYi5lbnYuYnJvd3Nlcj17dmVyc2lvbjpjWzFdfSxkLm1hdGNoKC9JRU1vYmlsZS8pPyhiLmVudi5icm93c2VyLm5hbWU9XCJJRU1vYmlsZVwiLGIuZW52LmJyb3dzZXIuaXNJRU1vYmlsZT0hMCk6KGIuZW52LmJyb3dzZXIubmFtZT1cIklFXCIsYi5lbnYuYnJvd3Nlci5pc0lFPSEwKSxkLm1hdGNoKC9BbmRyb2lkfGlQaG9uZS8pJiYoYi5lbnYuYnJvd3Nlci5pc0lFTGlrZVdlYmtpdD0hMCkpOihjPWQubWF0Y2goLyg/OkNocm9tZXxDcmlPUylcXC8oW1xcZFxcLl0rKS8pKT8oYi5lbnYuYnJvd3Nlcj17bmFtZTpcIkNocm9tZVwiLGlzQ2hyb21lOiEwLHZlcnNpb246Y1sxXX0sZC5tYXRjaCgvVmVyc2lvblxcL1tcXGQrXFwuXStcXHMqQ2hyb21lLykmJihiLmVudi5icm93c2VyLm5hbWU9XCJDaHJvbWUgV2Vidmlld1wiLGIuZW52LmJyb3dzZXIuaXNXZWJ2aWV3PSEwKSk6ZC5tYXRjaCgvU2FmYXJpLykmJihjPWQubWF0Y2goL0FuZHJvaWRbXFxzXFwvXShbXFxkXFwuXSspLykpP2IuZW52LmJyb3dzZXI9e25hbWU6XCJBbmRyb2lkXCIsaXNBbmRyb2lkOiEwLHZlcnNpb246Y1sxXX06ZC5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC8pP2QubWF0Y2goL1NhZmFyaS8pPyhjPWQubWF0Y2goL1ZlcnNpb25cXC8oW1xcZFxcLl0rKS8pLGIuZW52LmJyb3dzZXI9e25hbWU6XCJTYWZhcmlcIixpc1NhZmFyaTohMCx2ZXJzaW9uOmNbMV19KTooYz1kLm1hdGNoKC9PUyAoW1xcZF9cXC5dKykgbGlrZSBNYWMgT1MgWC8pLGIuZW52LmJyb3dzZXI9e25hbWU6XCJpT1MgV2Vidmlld1wiLGlzV2VidmlldzohMCx2ZXJzaW9uOmNbMV0ucmVwbGFjZSgvXFxfL2csXCIuXCIpfSk6Yi5lbnYuYnJvd3Nlcj17bmFtZTpcInVua25vd25cIix2ZXJzaW9uOlwiMC4wLjBcIn0sYi52ZXJzaW9uJiYoYi5lbnYuYnJvd3Nlci52ZXJzaW9uPWIudmVyc2lvbihiLmVudi5icm93c2VyLnZlcnNpb24pKX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGM9YS5uYXZpZ2F0b3IudXNlckFnZW50O2MubWF0Y2goL1dlaWJvL2kpP2IuZW52LnRoaXJkYXBwPXthcHBuYW1lOlwiV2VpYm9cIixpc1dlaWJvOiEwfTpjLm1hdGNoKC9NaWNyb01lc3Nlbmdlci9pKT9iLmVudi50aGlyZGFwcD17YXBwbmFtZTpcIldlaXhpblwiLGlzV2VpeGluOiEwfTpiLmVudi50aGlyZGFwcD0hMX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGMsZCxlPWEubmF2aWdhdG9yLnVzZXJBZ2VudDsoZD1lLm1hdGNoKC9XaW5kVmFuZVtcXC9cXHNdKFtcXGRcXC5cXF9dKykvKSkmJihjPWRbMV0pO3ZhciBmPSExLGc9XCJcIixoPVwiXCIsaT1cIlwiOyhkPWUubWF0Y2goL0FsaUFwcFxcKChbQS1aXFwtXSspXFwvKFtcXGRcXC5dKylcXCkvaSkpJiYoZj0hMCxnPWRbMV0saT1kWzJdLGg9Zy5pbmRleE9mKFwiLVBEXCIpPjA/Yi5lbnYub3MuaXNJT1M/XCJpUGFkXCI6Yi5lbnYub3MuaXNBbmRyb2lkP1wiQW5kcm9pZFBhZFwiOmIuZW52Lm9zLm5hbWU6Yi5lbnYub3MubmFtZSksIWcmJmUuaW5kZXhPZihcIlRCSU9TXCIpPjAmJihnPVwiVEJcIiksZj9iLmVudi5hbGlhcHA9e3dpbmR2YW5lOmIudmVyc2lvbihjfHxcIjAuMC4wXCIpLGFwcG5hbWU6Z3x8XCJ1bmtvd25cIix2ZXJzaW9uOmIudmVyc2lvbihpfHxcIjAuMC4wXCIpLHBsYXRmb3JtOmh8fGIuZW52Lm9zLm5hbWV9OmIuZW52LmFsaWFwcD0hMSxiLmVudi50YW9iYW9BcHA9Yi5lbnYuYWxpYXBwfSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKTs7bW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cubGliWydlbnYnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi93ZWV4LWh0bWw1L34vZW52ZC9idWlsZC9lbnZkLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEyNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gbG9hZEJ5TXRvcChwYWdlSWQsIGNhbGxiYWNrKSB7XG4gIGxpYi5tdG9wLnJlcXVlc3Qoe1xuICAgIGFwaTogJ210b3AuZ2ViLndlYXBwcGx1cy52aWV3bG9hZGVyLnF1ZXJ5JyxcbiAgICB2OiAnMi4wJyxcbiAgICBkYXRhOiB7XG4gICAgICBwYWdlOiBwYWdlSWQsXG4gICAgICBjbGllbnRWZXJzaW9uOiAxMDAwMFxuICAgIH0sXG4gICAgZWNvZGU6IDBcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIGNvZGUgPSByZXN1bHQuZGF0YSAmJiByZXN1bHQuZGF0YS5qc1N0clxuICAgIGlmIChjb2RlKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBjb2RlKVxuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgY2FsbGJhY2sobmV3IEVycm9yKCdsb2FkJyksIGVycm9yKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9hZEJ5TXRvcDogbG9hZEJ5TXRvcFxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9sb2FkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwidmFyIGV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG52YXIgcGFnZUluZm8gPSByZXF1aXJlKCcuL3BhZ2VJbmZvJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCcuL3N0cmVhbScpXG52YXIgdXNlciA9IHJlcXVpcmUoJy4vdXNlcicpXG52YXIgdXNlclRyYWNrID0gcmVxdWlyZSgnLi91c2VyVHJhY2snKVxudmFyIHdpbmR2YW5lID0gcmVxdWlyZSgnLi93aW5kdmFuZScpXG5cbnZhciBhcGkgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgnZXZlbnQnLCBldmVudCwgZXZlbnQuX21ldGEpXG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgncGFnZUluZm8nLCBwYWdlSW5mbywgcGFnZUluZm8uX21ldGEpXG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgnc3RyZWFtJywgc3RyZWFtLCBzdHJlYW0uX21ldGEpXG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgndXNlcicsIHVzZXIsIHVzZXIuX21ldGEpXG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgndXNlclRyYWNrJywgdXNlclRyYWNrLCB1c2VyVHJhY2suX21ldGEpXG4gICAgV2VleC5yZWdpc3RlckFwaU1vZHVsZSgnd2luZHZhbmUnLCB3aW5kdmFuZSwgd2luZHZhbmUuX21ldGEpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcGlcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2FwaS9pbmRleC5qc1xuICoqIG1vZHVsZSBpZCA9IDEyOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxuLy8gcmVxdWlyZSgnZW52ZCcpXG4vLyByZXF1aXJlKCdodHRwdXJsJylcbnJlcXVpcmUoJ0BhbGkvbGliLWNhbGxhcHAnKVxucmVxdWlyZSgnQGFsaS9saWItd2luZHZhbmUnKVxuXG4vLyBpcyB1cmwgb2YgdGFva2U/XG52YXIgdXJsID0gbGliLmh0dHB1cmwobG9jYXRpb24uaHJlZilcbnZhciBpc0luVGFva2UgPSB1cmwucGFyYW1zWydhbGlfdHJhY2tpZCddXG4gICYmIHVybC5wYXJhbXNbJ2FsaV90cmFja2lkJ10uaW5kZXhPZignMjonKSA9PT0gMFxuXG4vLyBpcyB0aGlzIGFwcCBvZiBhbGliYWJhIGluYy4/XG52YXIgaXNBbGlBcHAgPSBsaWIuZW52LmFsaWFwcFxuXG4vKipcbiAqIENhbGwgdGFvYmFvIGFwcCBmcm9tIGEgbm9uLWFsaWJhYmEgbm9uLXRhb2tlIGFwcCBjbGllbnQuXG4gKiBXaWxsIGFkZCBzZWNvbmQgcGFyYW1ldGVyIGZvciB0ZWxsaW5nIHdoZXRoZXIgb3Igbm90IHRvIGNhbGwgdGFvYmFvIGFwcFxuICogaW4gZnV0dXJlLiAobm90IHN1cHBvcnRlZCBmb3Igbm93LilcbiAqL1xuZnVuY3Rpb24gY2FsbEFwcCh1cmwpIHtcbiAgaWYgKCFpc0FsaUFwcCAmJiAhaXNJblRhb2tlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxpYi5jYWxsYXBwLmdvdG9QYWdlKHVybClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcuXG4gICAgfVxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgbG9jYXRpb24uaHJlZiA9IHVybFxuICAgIH0sIDMwMClcbiAgfVxuICBlbHNlIHtcbiAgICBsb2NhdGlvbi5ocmVmID0gdXJsXG4gIH1cbn1cblxudmFyIGV2ZW50ID0ge1xuXG4gIC8qKlxuICAgKiBvcGVuVXJsXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdXJsXG4gICAqL1xuICBvcGVuVVJMOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgaWYgKGxpYi5lbnYuYWxpYXBwKSB7XG4gICAgICAvLyBUTSBhcHAgd2lsbCBjcmVhdGUgbm8gd2VidmlldyBpbnN0YW5jZSB3aGVuIG5vdCBpbnRlbnRpb25hbGx5XG4gICAgICAvLyB0ZWxsaW5nIGl0IHRvLlxuICAgICAgLy8gQWxpIHJlbGllcyBvbiBodHRwOi8vZy5hbGljZG4uY29tL2h5YnJpZC9hcGkvMy4wLjExL2h5YnJpZC5taW4uanNcbiAgICAgIGlmIChsaWIuZW52LmFsaWFwcC5hcHBuYW1lID09PSAnVE0nKSB7XG4gICAgICAgIEFsaS5wdXNoV2luZG93KHVybCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5lcnJvckNvZGUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKHVybClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICAvLyBUQiBpb3MgY2xpZW50IHdpbGwgZGVzdG9yeSBjdXJyZW50IHdlYnZpZXcgYmVjYXVzZSBvZiBjcHA9MS5cbiAgICAgIC8vIFRoZXJlZm9yIHRoZSBtZXRob2Qgb3BlbldpbmRvdyBvZiB3aW5kdmFuZSBpcyBuZWVkZWQuXG4gICAgICBlbHNlIGlmIChsaWIuZW52LmFsaWFwcC5hcHBuYW1lID09PSAnVEInICYmIGxpYi5lbnYub3MuaXNJT1MpIHtcbiAgICAgICAgbGliLndpbmR2YW5lLmNhbGwoJ0Jhc2UnLCAnb3BlbldpbmRvdycsIHtcbiAgICAgICAgICB1cmw6IHVybFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIGNhbGxBcHAodXJsKVxuICAgICAgICBsb2NhdGlvbi5ocmVmID0gdXJsXG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gY2FsbEFwcCh1cmwpXG4gICAgICBsb2NhdGlvbi5ocmVmID0gdXJsXG4gICAgfVxuICB9XG5cbn1cblxuZXZlbnQuX21ldGEgPSB7XG4gIG1ldGE6IFt7XG4gICAgbmFtZTogJ29wZW5VUkwnLFxuICAgIGFyZ3M6IFsnc3RyaW5nJ11cbiAgfV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBldmVudFxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXBpL2V2ZW50LmpzXG4gKiogbW9kdWxlIGlkID0gMTI5XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgJiYgKHdpbmRvdyA9IHtjdHJsOiB7fSwgbGliOiB7fX0pOyF3aW5kb3cuY3RybCAmJiAod2luZG93LmN0cmwgPSB7fSk7IXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSk7cmVxdWlyZSgnQGFsaS9saWItZW52Jyk7cmVxdWlyZSgnQGFsaS9saWItaHR0cHVybCcpOyFmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiKXt2YXIgYz1uZXcgaihsb2NhdGlvbi5ocmVmKSxkPWguZ2V0RWxlbWVudEJ5SWQoXCJidXJpZWRcIiksZT1jLnBhcmFtcy50dGlkLGY9Yy5wYXJhbXMuYWRfaWQsZz1jLnBhcmFtcy5zb3VyY2VfdHlwZSxpPWMucGFyYW1zLnJlZnBpZCxrPWMucGFyYW1zLmFjdHBhcmFtLGw9Yy5wYXJhbXMuYWN0bmFtZSxtPWMucGFyYW1zLmFsaV90cmFja2lkLG49Yy5wYXJhbXMucGlkLG89aC5jb29raWUubWF0Y2goLyg/Ol58XFxzKWNuYT0oW147XSspKD86O3wkKS8pO2Muc2VhcmNoPVwiXCIsYy5oYXNoPVwiXCI7dmFyIHA9e307aWYoZCYmKGU9ZC52YWx1ZSkscC5mcm9tPVwiaDVcIixlJiYocC50dGlkPWUpLGkmJihwLnJlZnBpZD1pKSxrJiYocC5hY3RwYXJhbT1rKSxsJiYocC5hY3RuYW1lPWwpLHAudXJsPWMudG9TdHJpbmcoKSxuJiYocC5waWQ9biksZiYmKHAuYWRfaWQ9ZiksZyYmKHAuc291cmNlX3R5cGU9ZyksbSYmKHAuYWxpX3RyYWNraWQ9bSksbyYmKHAuaDVfdWlkPW9bMV0pLFwib2JqZWN0XCI9PXR5cGVvZiBiKWZvcih2YXIgcSBpbiBiKXBbcV09YltxXTtyZXR1cm4gYS5wYXJhbXMucG9pbnQ9SlNPTi5zdHJpbmdpZnkocCksYX1mdW5jdGlvbiBkKGEsYil7dmFyIGM9bmV3IGoobG9jYXRpb24uaHJlZiksZD1oLmdldEVsZW1lbnRCeUlkKFwiYnVyaWVkXCIpO2Zvcih2YXIgZSBpbiBjLnBhcmFtcylhLnBhcmFtcy5oYXNPd25Qcm9wZXJ0eShlKXx8KGEucGFyYW1zW2VdPWMucGFyYW1zW2VdKTtpZihkJiYoYS5wYXJhbXMudHRpZD1kLnZhbHVlKSxcIm9iamVjdFwiPT10eXBlb2YgYilmb3IodmFyIGUgaW4gYilhLnBhcmFtc1tlXT1iW2VdO3JldHVybiBhfWZ1bmN0aW9uIGUoYSl7b3x8KG89aC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpLG8uaWQ9XCJjYWxsYXBwX2lmcmFtZV9cIitEYXRlLm5vdygpLG8uZnJhbWVib3JkZXI9XCIwXCIsby5zdHlsZS5jc3NUZXh0PVwiZGlzcGxheTpub25lO2JvcmRlcjowO3dpZHRoOjA7aGVpZ2h0OjA7XCIsaC5ib2R5LmFwcGVuZENoaWxkKG8pKSxvLnNyYz1hfWZ1bmN0aW9uIGYoYSxiKXtiLnJlcGxhY2U9PT0hMXx8IWwmJmIucmVwbGFjZSE9PSEwP2xvY2F0aW9uLmhyZWY9YTpsb2NhdGlvbi5yZXBsYWNlKGEpfWZ1bmN0aW9uIGcoYSl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7Yi5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsYSksYi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYik7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpO2MuaW5pdEV2ZW50KFwiY2xpY2tcIiwhMSwhMSksYi5kaXNwYXRjaEV2ZW50KGMpfXZhciBoPWEuZG9jdW1lbnQsaT1hLm5hdmlnYXRvci51c2VyQWdlbnQsaj1iLmh0dHB1cmwsaz1iLmVudi5vcyxsPShiLmVudi5wYXJhbXMsYi5lbnYuYWxpYXBwKSxtPWIuZW52LmJyb3dzZXIsbj17XCJ0YW9iYW86XCI6XCJjb20udGFvYmFvLnRhb2Jhb1wiLFwidGFvYmFvd2VidmlldzpcIjpcImNvbS50YW9iYW8udGFvYmFvXCIsXCJ0bWFsbDpcIjpcImNvbS50bWFsbC53aXJlbGVzc1wifTtiLmNhbGxhcHA9Yi5jYWxsYXBwfHx7fTt2YXIgbztiLmNhbGxhcHAuZ290b1BhZ2U9ZnVuY3Rpb24oYSxiKXtiPWJ8fHt9LFwidW5kZWZpbmVkXCI9PXR5cGVvZiBiLnBvaW50JiYoYi5wb2ludD0hMCksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGIucGFyYW1zJiYoYi5wYXJhbXM9ITApO3ZhciBoPW5ldyBqKGF8fGxvY2F0aW9uLmhyZWYpO2lmKGE9bmV3IGooYSksKFwiaHR0cDpcIj09PWEucHJvdG9jb2x8fFwiaHR0cHM6XCI9PT1hLnByb3RvY29sKSYmKGsuaXNBbmRyb2lkJiZsJiZcIlRCXCI9PT1sLmFwcG5hbWU/KGE9bmV3IGooXCJ0YW9iYW93ZWJ2aWV3Oi8vbS50YW9iYW8uY29tL1wiKSxhLnBhcmFtcy53ZWJ1cmw9aC50b1N0cmluZygpKTphLnByb3RvY29sPVwidGFvYmFvOlwiKSxcInRhb2JhbzpcIj09PWEucHJvdG9jb2wpYi5wb2ludCYmYyhhLGIucG9pbnQpLGIucGFyYW1zJiZkKGEsYi5wYXJhbXMpO2Vsc2UgaWYoXCJ0YW9iYW93ZWJ2aWV3OlwiPT09YS5wcm90b2NvbCl7Yi5wb2ludCYmYyhhLGIucG9pbnQpO3ZhciBvPW5ldyBqKGEucGFyYW1zLndlYnVybCk7Yi5wYXJhbXMmJmQobyxiLnBhcmFtcyksYi5wb2ludCYmYyhvLGIucG9pbnQpLGEucGFyYW1zLndlYnVybD1vLnRvU3RyaW5nKCl9ZWxzZVwidG1hbGw6XCIhPT1hLnByb3RvY29sLnRvTG93ZXJDYXNlKCkmJlwia2RkY3B1YmxpYzpcIiE9PWEucHJvdG9jb2wudG9Mb3dlckNhc2UoKSYmXCJtZGF0YWR3cGhvbmU6XCIhPT1hLnByb3RvY29sLnRvTG93ZXJDYXNlKCkmJmIucGFyYW1zJiZkKGEsYi5wYXJhbXMpO3ZhciBwPWsuaXNBbmRyb2lkJiZtLmlzQ2hyb21lJiYhbS5pc1dlYnZpZXcscT1rLmlzQW5kcm9pZCYmISFpLm1hdGNoKC9zYW1zdW5nL2kpJiZrLnZlcnNpb24uZ3RlKFwiNC4zXCIpJiZrLnZlcnNpb24ubHQoXCI0LjVcIikscj1rLmlzSVBob25lJiZrLnZlcnNpb24uZ3RlKFwiOS4wXCIpJiZtLmlzU2FmYXJpOyhwfHxxfHxiLmZvcmNlSW50ZW50KSYmKGEuaGFzaD1cIkludGVudDtzY2hlbWU9XCIrYS5wcm90b2NvbC5yZXBsYWNlKFwiOlwiLFwiXCIpK1wiO3BhY2thZ2U9XCIrKGJbXCJwYWNrYWdlXCJdfHxuW2EucHJvdG9jb2xdKStcIjtlbmRcIixhLnByb3RvY29sPVwiaW50ZW50OlwiKSxyP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtnKGEudG9TdHJpbmcoKSxiKX0sMTAwKTpsfHxcImludGVudDpcIj09PWEucHJvdG9jb2w/c2V0VGltZW91dChmdW5jdGlvbigpe2YoYS50b1N0cmluZygpLGIpfSwxMDApOmUoYS50b1N0cmluZygpKX0sYi5jYWxsYXBwLmRvd25sb2FkPWZ1bmN0aW9uKGEsYil7Yj1ifHx7fSxhfHwoYT1rLmlzSVBob25lP1wiaHR0cDovL2l0dW5lcy5hcHBsZS5jb20vY24vYXBwL2lkMzg3NjgyNzI2P210PThcIjprLmlzSVBhZD9cImh0dHBzOi8vaXR1bmVzLmFwcGxlLmNvbS9hcHAvaWQ0Mzg4NjUyNzhcIjprLmlzQW5kcm9pZD9cIi8vZG93bmxvYWQuYWxpY2RuLmNvbS93aXJlbGVzcy90YW9iYW80YW5kcm9pZC9sYXRlc3QvdGFvYmFvNGFuZHJvaWRfNzAzMjQ4LmFwa1wiOlwiXCIpLGE9bmV3IGooYSksay5pc0FuZHJvaWQmJmEucGF0aG5hbWUubWF0Y2goL1xcLmFwayQvKT8oYS5zZWFyY2g9XCJcIixhLmhhc2g9XCJcIik6Yi5wYXJhbXMmJmQoYSxiLnBhcmFtcyksYT1hLnRvU3RyaW5nKCksZihhLGIpfX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSk7O21vZHVsZS5leHBvcnRzID0gd2luZG93LmxpYi5jYWxsYXBwO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0BhbGkvbGliLWNhbGxhcHAvYnVpbGQvY2FsbGFwcC5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSAmJiAod2luZG93ID0ge2N0cmw6IHt9LCBsaWI6IHt9fSk7IXdpbmRvdy5jdHJsICYmICh3aW5kb3cuY3RybCA9IHt9KTshd2luZG93LmxpYiAmJiAod2luZG93LmxpYiA9IHt9KTshZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwidmFsXCIse3ZhbHVlOmEudG9TdHJpbmcoKSxlbnVtZXJhYmxlOiEwfSksdGhpcy5ndD1mdW5jdGlvbihhKXtyZXR1cm4gYy5jb21wYXJlKHRoaXMsYSk+MH0sdGhpcy5ndGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGMuY29tcGFyZSh0aGlzLGEpPj0wfSx0aGlzLmx0PWZ1bmN0aW9uKGEpe3JldHVybiBjLmNvbXBhcmUodGhpcyxhKTwwfSx0aGlzLmx0ZT1mdW5jdGlvbihhKXtyZXR1cm4gYy5jb21wYXJlKHRoaXMsYSk8PTB9LHRoaXMuZXE9ZnVuY3Rpb24oYSl7cmV0dXJuIDA9PT1jLmNvbXBhcmUodGhpcyxhKX19Yi5lbnY9Yi5lbnZ8fHt9LGMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsfSxjLnByb3RvdHlwZS52YWx1ZU9mPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPXRoaXMudmFsLnNwbGl0KFwiLlwiKSxiPVtdLGM9MDtjPGEubGVuZ3RoO2MrKyl7dmFyIGQ9cGFyc2VJbnQoYVtjXSwxMCk7aXNOYU4oZCkmJihkPTApO3ZhciBlPWQudG9TdHJpbmcoKTtlLmxlbmd0aDw1JiYoZT1BcnJheSg2LWUubGVuZ3RoKS5qb2luKFwiMFwiKStlKSxiLnB1c2goZSksMT09PWIubGVuZ3RoJiZiLnB1c2goXCIuXCIpfXJldHVybiBwYXJzZUZsb2F0KGIuam9pbihcIlwiKSl9LGMuY29tcGFyZT1mdW5jdGlvbihhLGIpe2E9YS50b1N0cmluZygpLnNwbGl0KFwiLlwiKSxiPWIudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aHx8YzxiLmxlbmd0aDtjKyspe3ZhciBkPXBhcnNlSW50KGFbY10sMTApLGU9cGFyc2VJbnQoYltjXSwxMCk7aWYod2luZG93LmlzTmFOKGQpJiYoZD0wKSx3aW5kb3cuaXNOYU4oZSkmJihlPTApLGU+ZClyZXR1cm4tMTtpZihkPmUpcmV0dXJuIDF9cmV0dXJuIDB9LGIudmVyc2lvbj1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSl9fSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKSxmdW5jdGlvbihhLGIpe2IuZW52PWIuZW52fHx7fTt2YXIgYz1hLmxvY2F0aW9uLnNlYXJjaC5yZXBsYWNlKC9eXFw/LyxcIlwiKTtpZihiLmVudi5wYXJhbXM9e30sYylmb3IodmFyIGQ9Yy5zcGxpdChcIiZcIiksZT0wO2U8ZC5sZW5ndGg7ZSsrKXtkW2VdPWRbZV0uc3BsaXQoXCI9XCIpO3RyeXtiLmVudi5wYXJhbXNbZFtlXVswXV09ZGVjb2RlVVJJQ29tcG9uZW50KGRbZV1bMV0pfWNhdGNoKGYpe2IuZW52LnBhcmFtc1tkW2VdWzBdXT1kW2VdWzFdfX19KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpLGZ1bmN0aW9uKGEsYil7Yi5lbnY9Yi5lbnZ8fHt9O3ZhciBjLGQ9YS5uYXZpZ2F0b3IudXNlckFnZW50O2lmKGM9ZC5tYXRjaCgvV2luZG93c1xcc1Bob25lXFxzKD86T1NcXHMpPyhbXFxkXFwuXSspLykpYi5lbnYub3M9e25hbWU6XCJXaW5kb3dzIFBob25lXCIsaXNXaW5kb3dzUGhvbmU6ITAsdmVyc2lvbjpjWzFdfTtlbHNlIGlmKGQubWF0Y2goL1NhZmFyaS8pJiYoYz1kLm1hdGNoKC9BbmRyb2lkW1xcc1xcL10oW1xcZFxcLl0rKS8pKSliLmVudi5vcz17dmVyc2lvbjpjWzFdfSxkLm1hdGNoKC9Nb2JpbGVcXHMrU2FmYXJpLyk/KGIuZW52Lm9zLm5hbWU9XCJBbmRyb2lkXCIsYi5lbnYub3MuaXNBbmRyb2lkPSEwKTooYi5lbnYub3MubmFtZT1cIkFuZHJvaWRQYWRcIixiLmVudi5vcy5pc0FuZHJvaWRQYWQ9ITApO2Vsc2UgaWYoYz1kLm1hdGNoKC8oaVBob25lfGlQYWR8aVBvZCkvKSl7dmFyIGU9Y1sxXTsoYz1kLm1hdGNoKC9PUyAoW1xcZF9cXC5dKykgbGlrZSBNYWMgT1MgWC8pKSYmKGIuZW52Lm9zPXtuYW1lOmUsaXNJUGhvbmU6XCJpUGhvbmVcIj09PWV8fFwiaVBvZFwiPT09ZSxpc0lQYWQ6XCJpUGFkXCI9PT1lLGlzSU9TOiEwLHZlcnNpb246Y1sxXS5zcGxpdChcIl9cIikuam9pbihcIi5cIil9KX1iLmVudi5vc3x8KGIuZW52Lm9zPXtuYW1lOlwidW5rbm93blwiLHZlcnNpb246XCIwLjAuMFwifSksYi52ZXJzaW9uJiYoYi5lbnYub3MudmVyc2lvbj1iLnZlcnNpb24oYi5lbnYub3MudmVyc2lvbikpfSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKSxmdW5jdGlvbihhLGIpe2IuZW52PWIuZW52fHx7fTt2YXIgYyxkPWEubmF2aWdhdG9yLnVzZXJBZ2VudDsoYz1kLm1hdGNoKC8oPzpVQ1dFQnxVQ0Jyb3dzZXJcXC8pKFtcXGRcXC5dKykvKSk/Yi5lbnYuYnJvd3Nlcj17bmFtZTpcIlVDXCIsaXNVQzohMCx2ZXJzaW9uOmNbMV19OihjPWQubWF0Y2goL01RUUJyb3dzZXJcXC8oW1xcZFxcLl0rKS8pKT9iLmVudi5icm93c2VyPXtuYW1lOlwiUVFcIixpc1FROiEwLHZlcnNpb246Y1sxXX06KGM9ZC5tYXRjaCgvKD86RmlyZWZveHxGeGlPUylcXC8oW1xcZFxcLl0rKS8pKT9iLmVudi5icm93c2VyPXtuYW1lOlwiRmlyZWZveFwiLGlzRmlyZWZveDohMCx2ZXJzaW9uOmNbMV19OihjPWQubWF0Y2goL01TSUVcXHMoW1xcZFxcLl0rKS8pKXx8KGM9ZC5tYXRjaCgvSUVNb2JpbGVcXC8oW1xcZFxcLl0rKS8pKT8oYi5lbnYuYnJvd3Nlcj17dmVyc2lvbjpjWzFdfSxkLm1hdGNoKC9JRU1vYmlsZS8pPyhiLmVudi5icm93c2VyLm5hbWU9XCJJRU1vYmlsZVwiLGIuZW52LmJyb3dzZXIuaXNJRU1vYmlsZT0hMCk6KGIuZW52LmJyb3dzZXIubmFtZT1cIklFXCIsYi5lbnYuYnJvd3Nlci5pc0lFPSEwKSxkLm1hdGNoKC9BbmRyb2lkfGlQaG9uZS8pJiYoYi5lbnYuYnJvd3Nlci5pc0lFTGlrZVdlYmtpdD0hMCkpOihjPWQubWF0Y2goLyg/OkNocm9tZXxDcmlPUylcXC8oW1xcZFxcLl0rKS8pKT8oYi5lbnYuYnJvd3Nlcj17bmFtZTpcIkNocm9tZVwiLGlzQ2hyb21lOiEwLHZlcnNpb246Y1sxXX0sZC5tYXRjaCgvVmVyc2lvblxcL1tcXGQrXFwuXStcXHMqQ2hyb21lLykmJihiLmVudi5icm93c2VyLm5hbWU9XCJDaHJvbWUgV2Vidmlld1wiLGIuZW52LmJyb3dzZXIuaXNXZWJ2aWV3PSEwKSk6ZC5tYXRjaCgvU2FmYXJpLykmJihjPWQubWF0Y2goL0FuZHJvaWRbXFxzXFwvXShbXFxkXFwuXSspLykpP2IuZW52LmJyb3dzZXI9e25hbWU6XCJBbmRyb2lkXCIsaXNBbmRyb2lkOiEwLHZlcnNpb246Y1sxXX06ZC5tYXRjaCgvaVBob25lfGlQYWR8aVBvZC8pJiYoZC5tYXRjaCgvU2FmYXJpLykmJihjPWQubWF0Y2goL1ZlcnNpb25cXC8oW1xcZFxcLl0rKS8pKT9iLmVudi5icm93c2VyPXtuYW1lOlwiU2FmYXJpXCIsaXNTYWZhcmk6ITAsdmVyc2lvbjpjWzFdfTooYz1kLm1hdGNoKC9PUyAoW1xcZF9cXC5dKykgbGlrZSBNYWMgT1MgWC8pKSYmKGIuZW52LmJyb3dzZXI9e25hbWU6XCJpT1MgV2Vidmlld1wiLGlzV2VidmlldzohMCx2ZXJzaW9uOmNbMV0ucmVwbGFjZSgvXFxfL2csXCIuXCIpfSkpLGIuZW52LmJyb3dzZXJ8fChiLmVudi5icm93c2VyPXtuYW1lOlwidW5rbm93blwiLHZlcnNpb246XCIwLjAuMFwifSksYi52ZXJzaW9uJiYoYi5lbnYuYnJvd3Nlci52ZXJzaW9uPWIudmVyc2lvbihiLmVudi5icm93c2VyLnZlcnNpb24pKX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGM9YS5uYXZpZ2F0b3IudXNlckFnZW50O2IuZW52LnRoaXJkYXBwPWMubWF0Y2goL1dlaWJvL2kpP3thcHBuYW1lOlwiV2VpYm9cIixpc1dlaWJvOiEwfTpjLm1hdGNoKC9NaWNyb01lc3Nlbmdlci9pKT97YXBwbmFtZTpcIldlaXhpblwiLGlzV2VpeGluOiEwfTohMX0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtiLmVudj1iLmVudnx8e307dmFyIGMsZCxlPWEubmF2aWdhdG9yLnVzZXJBZ2VudDsoZD1lLm1hdGNoKC9XaW5kVmFuZVtcXC9cXHNdKFtcXGRcXC5cXF9dKykvKSkmJihjPWRbMV0pO3ZhciBmPSExLGc9XCJcIixoPVwiXCIsaT1cIlwiLGo9YS5fdWFfcG9wTGF5ZXJ8fFwiXCIsaz0hMSxsPVwiXCI7KGQ9ZS5tYXRjaCgvQWxpQXBwXFwoKFtBLVpcXC1dKylcXC8oW1xcZFxcLl0rKVxcKS9pKSkmJihmPSEwLGc9ZFsxXSxpPWRbMl0saD1nLmluZGV4T2YoXCItUERcIik+MD9iLmVudi5vcy5pc0lPUz9cImlQYWRcIjpiLmVudi5vcy5pc0FuZHJvaWQ/XCJBbmRyb2lkUGFkXCI6Yi5lbnYub3MubmFtZTpiLmVudi5vcy5uYW1lKSwhZyYmZS5pbmRleE9mKFwiVEJJT1NcIik+MCYmKGc9XCJUQlwiKSxqJiYoZD1qLm1hdGNoKC9Qb3BMYXllclxcLyhbXFxkXFwuXSspL2kpKSYmKGs9ITAsbD1kWzFdKSxiLmVudi5hbGlhcHA9Zj97d2luZHZhbmU6Yi52ZXJzaW9uKGN8fFwiMC4wLjBcIiksYXBwbmFtZTpnfHxcInVua293blwiLHZlcnNpb246Yi52ZXJzaW9uKGl8fFwiMC4wLjBcIikscGxhdGZvcm06aHx8Yi5lbnYub3MubmFtZSxwb3BsYXllcjprfHwhMSxwb3BsYXllclZlcnNpb246Yi52ZXJzaW9uKGx8fFwiMC4wLjBcIil9OiExLGIuZW52LnRhb2Jhb0FwcD1iLmVudi5hbGlhcHB9KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpOzttb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5saWJbJ2VudiddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0BhbGkvbGliLWNhbGxhcHAvfi9AYWxpL2xpYi1lbnYvYnVpbGQvZW52LmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpICYmICh3aW5kb3cgPSB7Y3RybDoge30sIGxpYjoge319KTshd2luZG93LmN0cmwgJiYgKHdpbmRvdy5jdHJsID0ge30pOyF3aW5kb3cubGliICYmICh3aW5kb3cubGliID0ge30pOyFmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7dmFyIGI9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJwYXJhbXNcIix7c2V0OmZ1bmN0aW9uKGEpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBhKXtmb3IodmFyIGMgaW4gYilkZWxldGUgYltjXTtmb3IodmFyIGMgaW4gYSliW2NdPWFbY119fSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYn0sZW51bWVyYWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic2VhcmNoXCIse3NldDpmdW5jdGlvbihhKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYSl7MD09PWEuaW5kZXhPZihcIj9cIikmJihhPWEuc3Vic3RyKDEpKTt2YXIgYz1hLnNwbGl0KFwiJlwiKTtmb3IodmFyIGQgaW4gYilkZWxldGUgYltkXTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyl7dmFyIGY9Y1tlXS5zcGxpdChcIj1cIik7aWYodm9pZCAwIT09ZlsxXSYmKGZbMV09ZlsxXS50b1N0cmluZygpKSxmWzBdKXRyeXtiW2RlY29kZVVSSUNvbXBvbmVudChmWzBdKV09ZGVjb2RlVVJJQ29tcG9uZW50KGZbMV0pfWNhdGNoKGcpe2JbZlswXV09ZlsxXX19fX0sZ2V0OmZ1bmN0aW9uKCl7dmFyIGE9W107Zm9yKHZhciBjIGluIGIpaWYodm9pZCAwIT09YltjXSlpZihcIlwiIT09YltjXSl0cnl7YS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQoYltjXSkpfWNhdGNoKGQpe2EucHVzaChjK1wiPVwiK2JbY10pfWVsc2UgdHJ5e2EucHVzaChlbmNvZGVVUklDb21wb25lbnQoYykpfWNhdGNoKGQpe2EucHVzaChjKX1yZXR1cm4gYS5sZW5ndGg/XCI/XCIrYS5qb2luKFwiJlwiKTpcIlwifSxlbnVtZXJhYmxlOiEwfSk7dmFyIGM7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJoYXNoXCIse3NldDpmdW5jdGlvbihhKXtcInN0cmluZ1wiPT10eXBlb2YgYSYmKGEmJmEuaW5kZXhPZihcIiNcIik8MCYmKGE9XCIjXCIrYSksYz1hfHxcIlwiKX0sZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGN9LGVudW1lcmFibGU6ITB9KSx0aGlzLnNldD1mdW5jdGlvbihhKXthPWF8fFwiXCI7dmFyIGI7aWYoIShiPWEubWF0Y2gobmV3IFJlZ0V4cChcIl4oW2EtejAtOS1dKzopP1svXXsyfSg/OihbXkAvOj9dKykoPzo6KFteQC86XSspKT9AKT8oW146Lz8jXSspKD86WzpdKFswLTldKykpPyhbL11bXj8jO10qKT8oPzpbP10oW14jXSopKT8oWyNdW14/XSopPyRcIixcImlcIikpKSl0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyB1cmkgc2NoZW1lLlwiKTt0aGlzLnByb3RvY29sPWJbMV18fChcIm9iamVjdFwiPT10eXBlb2YgbG9jYXRpb24/bG9jYXRpb24ucHJvdG9jb2w6XCJcIiksdGhpcy51c2VybmFtZT1iWzJdfHxcIlwiLHRoaXMucGFzc3dvcmQ9YlszXXx8XCJcIix0aGlzLmhvc3RuYW1lPXRoaXMuaG9zdD1iWzRdLHRoaXMucG9ydD1iWzVdfHxcIlwiLHRoaXMucGF0aG5hbWU9Yls2XXx8XCIvXCIsdGhpcy5zZWFyY2g9Yls3XXx8XCJcIix0aGlzLmhhc2g9Yls4XXx8XCJcIix0aGlzLm9yaWdpbj10aGlzLnByb3RvY29sK1wiLy9cIit0aGlzLmhvc3RuYW1lfSx0aGlzLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wcm90b2NvbCtcIi8vXCI7cmV0dXJuIHRoaXMudXNlcm5hbWUmJihhKz10aGlzLnVzZXJuYW1lLHRoaXMucGFzc3dvcmQmJihhKz1cIjpcIit0aGlzLnBhc3N3b3JkKSxhKz1cIkBcIiksYSs9dGhpcy5ob3N0LHRoaXMucG9ydCYmXCI4MFwiIT09dGhpcy5wb3J0JiYoYSs9XCI6XCIrdGhpcy5wb3J0KSx0aGlzLnBhdGhuYW1lJiYoYSs9dGhpcy5wYXRobmFtZSksdGhpcy5zZWFyY2gmJihhKz10aGlzLnNlYXJjaCksdGhpcy5oYXNoJiYoYSs9dGhpcy5oYXNoKSxhfSxhJiZ0aGlzLnNldChhLnRvU3RyaW5nKCkpfWIuaHR0cHVybD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGMoYSl9fSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKTs7bW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cubGliLmh0dHB1cmw7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vQGFsaS9saWItY2FsbGFwcC9+L0BhbGkvbGliLWh0dHB1cmwvYnVpbGQvaHR0cHVybC5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMzJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSAmJiAod2luZG93ID0ge2N0cmw6IHt9LCBsaWI6IHt9fSk7IXdpbmRvdy5jdHJsICYmICh3aW5kb3cuY3RybCA9IHt9KTshd2luZG93LmxpYiAmJiAod2luZG93LmxpYiA9IHt9KTshZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7YT1hLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpLGI9Yi50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtmb3IodmFyIGM9MDtjPGEubGVuZ3RofHxjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9cGFyc2VJbnQoYVtjXSwxMCksZT1wYXJzZUludChiW2NdLDEwKTtpZih3aW5kb3cuaXNOYU4oZCkmJihkPTApLHdpbmRvdy5pc05hTihlKSYmKGU9MCksZT5kKXJldHVybi0xO2lmKGQ+ZSlyZXR1cm4gMX1yZXR1cm4gMH12YXIgZD1hLlByb21pc2UsZT1hLmRvY3VtZW50LGY9YS5uYXZpZ2F0b3IudXNlckFnZW50LGc9L1dpbmRvd3NcXHNQaG9uZVxccyg/Ok9TXFxzKT9bXFxkXFwuXSsvaS50ZXN0KGYpfHwvV2luZG93c1xcc05UXFxzW1xcZFxcLl0rL2kudGVzdChmKSxoPWcmJmEuV2luZFZhbmVfV2luX1ByaXZhdGUmJmEuV2luZFZhbmVfV2luX1ByaXZhdGUuY2FsbCxpPS9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChmKSxqPS9BbmRyb2lkL2kudGVzdChmKSxrPWYubWF0Y2goL1dpbmRWYW5lW1xcL1xcc10oXFxkK1suX11cXGQrWy5fXVxcZCspLyksbD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LG09Yi53aW5kdmFuZT1hLldpbmRWYW5lfHwoYS5XaW5kVmFuZT17fSksbj0oYS5XaW5kVmFuZV9OYXRpdmUsMSksbz1bXSxwPTMscT1cImh5YnJpZFwiLHI9XCJ3dl9oeWJyaWRcIixzPVwiaWZyYW1lX1wiLHQ9XCJzdWNfXCIsdT1cImVycl9cIix2PVwiZGVmZXJfXCIsdz1cInBhcmFtX1wiLHg9XCJjaHVua19cIix5PTZlNSx6PTZlNSxBPTZlNDtrPWs/KGtbMV18fFwiMC4wLjBcIikucmVwbGFjZSgvXFxfL2csXCIuXCIpOlwiMC4wLjBcIjt2YXIgQj17aXNBdmFpbGFibGU6MT09PWMoayxcIjBcIiksY2FsbDpmdW5jdGlvbihhLGIsYyxlLGYsZyl7dmFyIGgsaTtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0mJihnPWFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdKSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiYoZT1udWxsKSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmJiYoZj1udWxsKSxkJiYoaT17fSxpLnByb21pc2U9bmV3IGQoZnVuY3Rpb24oYSxiKXtpLnJlc29sdmU9YSxpLnJlamVjdD1ifSkpLGg9Zz4wP3NldFRpbWVvdXQoZnVuY3Rpb24oKXtCLm9uRmFpbHVyZShoLHtyZXQ6XCJIWV9USU1FT1VUXCJ9KX0sZyk6Qy5nZXRTaWQoKSxDLnJlZ2lzdGVyQ2FsbChoLGUsZixpKSxDLnJlZ2lzdGVyR0MoaCxnKSxCLmlzQXZhaWxhYmxlP0MuY2FsbE1ldGhvZChhLGIsYyxoKTpCLm9uRmFpbHVyZShoLHtyZXQ6XCJIWV9OT1RfSU5fV0lORFZBTkVcIn0pLGk/aS5wcm9taXNlOnZvaWQgMH0sZmlyZUV2ZW50OmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1lLmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKTtkLmluaXRFdmVudChhLCExLCEwKSxkLnBhcmFtPUMucGFyc2VEYXRhKGJ8fEMuZ2V0RGF0YShjKSksZS5kaXNwYXRjaEV2ZW50KGQpfSxnZXRQYXJhbTpmdW5jdGlvbihhKXtyZXR1cm4gQy5nZXRQYXJhbShhKX0sc2V0RGF0YTpmdW5jdGlvbihhLGIpe0Muc2V0RGF0YShhLGIpfSxvblN1Y2Nlc3M6ZnVuY3Rpb24oYSxiKXtDLm9uQ29tcGxldGUoYSxiLFwic3VjY2Vzc1wiKX0sb25GYWlsdXJlOmZ1bmN0aW9uKGEsYil7Qy5vbkNvbXBsZXRlKGEsYixcImZhaWx1cmVcIil9fSxDPXtwYXJhbXM6e30sY2h1bmtzOnt9LGNhbGxzOnt9LGdldFNpZDpmdW5jdGlvbigpe3JldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKDE8PDUwKSkrXCJcIituKyt9LGJ1aWxkUGFyYW06ZnVuY3Rpb24oYSl7cmV0dXJuIGEmJlwib2JqZWN0XCI9PXR5cGVvZiBhP0pTT04uc3RyaW5naWZ5KGEpOmF8fFwiXCJ9LGdldFBhcmFtOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnBhcmFtc1t3K2FdfHxcIlwifSxzZXRQYXJhbTpmdW5jdGlvbihhLGIpe3RoaXMucGFyYW1zW3crYV09Yn0scGFyc2VEYXRhOmZ1bmN0aW9uKGEpe3ZhciBiO2lmKGEmJlwic3RyaW5nXCI9PXR5cGVvZiBhKXRyeXtiPUpTT04ucGFyc2UoYSl9Y2F0Y2goYyl7Yj17cmV0OltcIldWX0VSUjo6UEFSQU1fUEFSU0VfRVJST1JcIl19fWVsc2UgYj1hfHx7fTtyZXR1cm4gYn0sc2V0RGF0YTpmdW5jdGlvbigpe3RoaXMuY2h1bmtzW3grc2lkXT10aGlzLmNodW5rc1t4K3NpZF18fFtdLHRoaXMuY2h1bmtzW3grc2lkXS5wdXNoKGNodW5rKX0sZ2V0RGF0YTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5jaHVua3NbeCthXT90aGlzLmNodW5rc1t4K2FdLmpvaW4oXCJcIik6XCJcIn0scmVnaXN0ZXJDYWxsOmZ1bmN0aW9uKGEsYixjLGQpe2ImJih0aGlzLmNhbGxzW3QrYV09YiksYyYmKHRoaXMuY2FsbHNbdSthXT1jKSxkJiYodGhpcy5jYWxsc1t2K2FdPWQpfSx1bnJlZ2lzdGVyQ2FsbDpmdW5jdGlvbihhKXt2YXIgYj10K2EsYz11K2EsZD12K2EsZT17fTtyZXR1cm4gdGhpcy5jYWxsc1tiXSYmKGUuc3VjY2Vzcz10aGlzLmNhbGxzW2JdLGRlbGV0ZSB0aGlzLmNhbGxzW2JdKSx0aGlzLmNhbGxzW2NdJiYoZS5mYWlsdXJlPXRoaXMuY2FsbHNbY10sZGVsZXRlIHRoaXMuY2FsbHNbY10pLHRoaXMuY2FsbHNbZF0mJihlLmRlZmVycmVkPXRoaXMuY2FsbHNbZF0sZGVsZXRlIHRoaXMuY2FsbHNbZF0pLGV9LHVzZUlmcmFtZTpmdW5jdGlvbihhLGIpe3ZhciBjPXMrYSxkPW8ucG9wKCk7ZHx8KGQ9ZS5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpLGQuc2V0QXR0cmlidXRlKFwiZnJhbWVib3JkZXJcIixcIjBcIiksZC5zdHlsZS5jc3NUZXh0PVwid2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6MDtkaXNwbGF5Om5vbmU7XCIpLGQuc2V0QXR0cmlidXRlKFwiaWRcIixjKSxkLnNldEF0dHJpYnV0ZShcInNyY1wiLGIpLGQucGFyZW50Tm9kZXx8c2V0VGltZW91dChmdW5jdGlvbigpe2UuYm9keS5hcHBlbmRDaGlsZChkKX0sNSl9LHJldHJpZXZlSWZyYW1lOmZ1bmN0aW9uKGEpe3ZhciBiPXMrYSxjPWUucXVlcnlTZWxlY3RvcihcIiNcIitiKTtvLmxlbmd0aD49cD9lLmJvZHkucmVtb3ZlQ2hpbGQoYyk6by5wdXNoKGMpfSxjYWxsTWV0aG9kOmZ1bmN0aW9uKGIsYyxkLGUpe2lmKGQ9Qy5idWlsZFBhcmFtKGQpLGcpaD9hLldpbmRWYW5lX1dpbl9Qcml2YXRlLmNhbGwoYixjLGUsZCk6dGhpcy5vbkNvbXBsZXRlKGUse3JldDpcIkhZX05PX0hBTkRMRVJfT05fV1BcIn0sXCJmYWlsdXJlXCIpO2Vsc2V7dmFyIGY9cStcIjovL1wiK2IrXCI6XCIrZStcIi9cIitjK1wiP1wiK2Q7aWYoaSl0aGlzLnNldFBhcmFtKGUsZCksdGhpcy51c2VJZnJhbWUoZSxmKTtlbHNlIGlmKGope3ZhciBrPXIrXCI6XCI7d2luZG93LnByb21wdChmLGspfWVsc2UgdGhpcy5vbkNvbXBsZXRlKGUse3JldDpcIkhZX05PVF9TVVBQT1JUX0RFVklDRVwifSxcImZhaWx1cmVcIil9fSxyZWdpc3RlckdDOmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxkPU1hdGgubWF4KGJ8fDAseSksZT1NYXRoLm1heChifHwwLEEpLGY9TWF0aC5tYXgoYnx8MCx6KTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy51bnJlZ2lzdGVyQ2FsbChhKX0sZCksaT9zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5wYXJhbXNbdythXSYmZGVsZXRlIGMucGFyYW1zW3crYV19LGUpOmomJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtjLmNodW5rc1t4K2FdJiZkZWxldGUgYy5jaHVua3NbeCthXX0sZil9LG9uQ29tcGxldGU6ZnVuY3Rpb24oYSxiLGMpe2NsZWFyVGltZW91dChhKTt2YXIgZD10aGlzLnVucmVnaXN0ZXJDYWxsKGEpLGU9ZC5zdWNjZXNzLGY9ZC5mYWlsdXJlLGc9ZC5kZWZlcnJlZDtiPWI/Yjp0aGlzLmdldERhdGEoYSksYj10aGlzLnBhcnNlRGF0YShiKTt2YXIgaD1iLnJldDtcInN0cmluZ1wiPT10eXBlb2YgaCYmKGI9Yi52YWx1ZXx8YixiLnJldHx8KGIucmV0PVtoXSkpLFwic3VjY2Vzc1wiPT09Yz8oZSYmZShiKSxnJiZnLnJlc29sdmUoYikpOlwiZmFpbHVyZVwiPT09YyYmKGYmJmYoYiksZyYmZy5yZWplY3QoYikpLGk/KHRoaXMucmV0cmlldmVJZnJhbWUoYSksdGhpcy5wYXJhbXNbdythXSYmZGVsZXRlIHRoaXMucGFyYW1zW3crYV0pOmomJnRoaXMuY2h1bmtzW3grYV0mJmRlbGV0ZSB0aGlzLmNodW5rc1t4K2FdfX07Zm9yKHZhciBEIGluIEIpbC5jYWxsKG0sRCl8fChtW0RdPUJbRF0pfSh3aW5kb3csd2luZG93LmxpYnx8KHdpbmRvdy5saWI9e30pKTs7bW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cubGliWyd3aW5kdmFuZSddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0BhbGkvbGliLXdpbmR2YW5lL2J1aWxkL3dpbmR2YW5lLmNvbW1vbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEzM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIHBhZ2VJbmZvID0ge1xuXG4gIHNldFRpdGxlOiBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICB0aXRsZSA9IHRpdGxlIHx8ICdXZWV4IEhUTUw1J1xuICAgIHRyeSB7XG4gICAgICB0aXRsZSA9IGRlY29kZVVSSUNvbXBvbmVudCh0aXRsZSlcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGVcbiAgICBpZiAobGliLmVudi50YW9iYW9BcHBcbiAgICAgICAgJiYgbGliLmVudi50YW9iYW9BcHAuYXBwbmFtZSA9PSAnVEInXG4gICAgICAgICYmIGxpYi53aW5kdmFuZSkge1xuICAgICAgbGliLndpbmR2YW5lLmNhbGwoJ1dlYkFwcEludGVyZmFjZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICwnc2V0Q3VzdG9tUGFnZVRpdGxlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgLHsgdGl0bGU6IHRpdGxlIH0pXG4gICAgfVxuICB9LFxuXG4gIHNldFNwbTogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYSkge1xuICAgICAgdmFyIG1ldGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJkYXRhLXNwbVwiXScpXG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgbWV0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKVxuICAgICAgICBtZXRhLnNldEF0dHJpYnV0ZSgnbmFtZScsICdkYXRhLXNwbScpXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobWV0YSlcbiAgICAgIH1cbiAgICAgIG1ldGEuc2V0QXR0cmlidXRlKCdjb250ZW50JywgYSlcbiAgICB9XG5cbiAgICBpZiAoYikge1xuICAgICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3BtJywgYilcbiAgICB9XG4gIH1cbn1cblxucGFnZUluZm8uX21ldGEgPSB7XG4gIHBhZ2VJbmZvOiBbe1xuICAgIG5hbWU6ICdzZXRUaXRsZScsXG4gICAgYXJnczogWydzdHJpbmcnXVxuICB9LCB7XG4gICAgbmFtZTogJ3NldFNwbScsXG4gICAgYXJnczogWydzdHJpbmcnLCAnc3RyaW5nJ11cbiAgfV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYWdlSW5mb1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXBpL3BhZ2VJbmZvLmpzXG4gKiogbW9kdWxlIGlkID0gMTM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgd2VleCA9IHJlcXVpcmUoJ3dlZXgtaHRtbDUnKVxudmFyIGV4dGVuZCA9IHdlZXgudXRpbHMuZXh0ZW5kXG5cbi8vIHJlcXVpcmUoJ2VudmQnKVxucmVxdWlyZSgnQGFsaS9saWItd2luZHZhbmUnKVxucmVxdWlyZSgnQGFsaS9saWItbG9naW4nKVxucmVxdWlyZSgnQGFsaS9saWItbXRvcCcpXG5cbnZhciBzdHJlYW0gPSB7XG4gIC8qKlxuICAgKiBzZW5kTXRvcFxuICAgKiBAcGFyYW0gIHtvYmp9ICAgY29uZmlnXG4gICAqICAgc3RyaW5nIGFwaSDor7fmsYLnmoQgQVBJIOWQjeensOOAgihvcHRpb25hbDogYXBpTmFtZSlcbiAgICogICBzdHJpbmcgZWNvZGUgKOWPr+mAiSnmmK/lkKbkvb/nlKggZWNvZGUg562+5ZCN77yM6ZyA6KaB5LiO5pyN5Yqh56uvIEFQSSDnuqblrprvvIxcbiAgICogICAgICcxJyDooajnpLrkvb/nlKjvvIwnMCcg6KGo56S65LiN5L2/55So44CC6buY6K6k5Li6ICcwJ+OAglxuICAgKiAgIHN0cmluZyBpc0h0dHBzICjlj6/pgIkp5piv5ZCm5L2/55SoIEh0dHBz77yMJzEnIOihqOekuuS9v+eUqO+8jCcwJyDooajnpLrkuI1cbiAgICogICAgIOS9v+eUqOOAgum7mOiupOS4uiAnMCfjgIJcbiAgICogICBzdHJpbmcgaXNTZWMgKOWPr+mAiSnmmK/lkKbkvb/nlKggV1VB77yM77yI5piv5ZCm6LWw6buR5Yyj5a2Q5Yqg562+77yM5piv5bqV5bGC5Yaz5a6aXG4gICAqICAgICDnmoTvvInvvIwnMScg6KGo56S65L2/55So77yMJzAnIOihqOekuuS4jeS9v+eUqOOAgum7mOiupOS4uiAnMCfjgIJcbiAgICogICBvYmplY3QgcGFyYW0gKOWPr+mAiSnor7fmsYLnmoTlj4LmlbDvvIxKU09OIOWvueixoeOAglxuICAgKiAgIHN0cmluZyAocG9zdCko5Y+v6YCJKeaYr+WQpuS9v+eUqCBQT1NUIOaWueW8j+ivt+axgu+8jCcxJyDooajnpLrkvb/nlKjvvIwnMCcg6KGoXG4gICAqICAgICDnpLrkuI3kvb/nlKjjgILpu5jorqTkuLogJzAn44CCXG4gICAqICAgaW50IHRpbWVyICjlj6/pgIkp5Y+R6YCB572R57uc6K+35rGC55qE6LaF5pe25pe26Ze077yI5q+r56eS77yJ77yM5aaC5p6c5Zyo5oyH5a6a5pe26Ze05YaFXG4gICAqICAgICDnvZHnu5zor7fmsYLmsqHmnInlm57mnaXvvIzliJnoh6rliqjotbDnvJPlrZjvvJvlpoLmnpzmsqHmnInnvJPlrZjvvIzliJnov5Tlm57otoXml7bplJnor6/jgIItMVxuICAgKiAgICAg5oiW5LiN5Lyg6KGo56S65LiN6K6+572u6LaF5pe277yM5oC75piv5Lya562J5b6F572R57uc6K+35rGC44CCXG4gICAqICAgc3RyaW5nIHYgKOWPr+mAiSlBUEkg54mI5pys5Y+377yM6buY6K6k5Li6ICcqJ+OAgihvcHRpb25hbDogYXBpVmVyc2lvbilcbiAgICogICBzdHJpbmcgc2Vzc2lvbk9wdGlvbiAo5Y+v6YCJKeWmguaenOivt+axgueahCBBUEkg6ZyA6KaB55m75b2V77yM5piv5ZCm5ouJ6LW355m7XG4gICAqICAgICDlvZXnlYzpnaLjgIInQXV0b0xvZ2luT25seScg6KGo56S65Y+q5YGa6Ieq5Yqo55m75b2V77yMXG4gICAqICAgICAnQXV0b0xvZ2luQW5kTWFudWFsTG9naW4nIOWBmuiHquWKqOeZu+W9le+8jOeZu+W9leWksei0peWImeaLiei1t+eZu+W9leeVjOmdou+8jFxuICAgKiAgICAg6buY6K6k5Li6J0F1dG9Mb2dpbk9ubHkn77yI5omL5reYIGlPUyA1LjIuOCDmiJbmm7Tpq5jvvIxBbmRyb2lkIOW5s+WPsFxuICAgKiAgICAg5oC75piv5YWB6K645ouJ6LW355m75b2V55WM6Z2i77yJXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2FsbGJhY2tJZFxuICAgKi9cbiAgc2VuZE10b3A6IGZ1bmN0aW9uIChjb25maWcsIGNhbGxiYWNrSWQpIHtcblxuICAgIHZhciByZXFCb2R5LCBuZWVkTG9naW5cbiAgICB2YXIgc2VsZiA9IHRoaXNcblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWcpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ210b3Ag6K+35rGC5Y+C5pWw6ZSZ6K+vLCDor7flpITnkIYhJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0JyB8fCAoIWNvbmZpZy5hcGkgJiYgIWNvbmZpZy5hcGlOYW1lKSkge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignbXRvcCDor7fmsYLlj4LmlbDkuI3lhagsIOivt+WkhOeQhiEnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG5cbiAgICByZXFCb2R5ID0gZXh0ZW5kKHt9LCBjb25maWcpXG5cbiAgICAvLyDmlbTnkIbor7fmsYLlj4LmlbBcbiAgICByZXFCb2R5LmFwaSA9IHJlcUJvZHkuYXBpIHx8IHJlcUJvZHkuYXBpTmFtZVxuICAgIHJlcUJvZHkudiA9IHJlcUJvZHkudiB8fCByZXFCb2R5LmFwaVZlcnNpb25cbiAgICBuZWVkTG9naW4gPSB0eXBlb2YgcmVxQm9keS5uZWVkTG9naW4gPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICA/IHJlcUJvZHkubmVlZExvZ2luXG4gICAgICAgICAgICAgIDogcmVxQm9keS5zZXNzaW9uT3B0aW9uID09PSAnQXV0b0xvZ2luQW5kTWFudWFsTG9naW4nXG4gICAgcmVxQm9keS5kYXRhID0gcmVxQm9keS5wYXJhbSB8fCByZXFCb2R5LnJlcXVlc3RQYXJhbXNcbiAgICByZXFCb2R5LmVjb2RlID0gcmVxQm9keS5lY29kZSA/IHBhcnNlSW50KHJlcUJvZHkuZWNvZGUpIDogMFxuICAgIGRlbGV0ZSByZXFCb2R5LmFwaU5hbWVcbiAgICBkZWxldGUgcmVxQm9keS5hcGlWZXJzaW9uXG4gICAgZGVsZXRlIHJlcUJvZHkubmVlZExvZ2luXG4gICAgZGVsZXRlIHJlcUJvZHkuaXNIdHRwc1xuICAgIGRlbGV0ZSByZXFCb2R5LnBvc3RcbiAgICBkZWxldGUgcmVxQm9keS5zZXNzaW9uT3B0aW9uXG4gICAgZGVsZXRlIHJlcUJvZHkucGFyYW1cbiAgICBkZWxldGUgcmVxQm9keS5yZXF1ZXN0UGFyYW1zXG5cbiAgICAvLyDlnKjnuq9INeeOr+Wig++8jOS4lOaciSBlY29kZSDml7bvvIzopoHliqAgdWEg5Y+C5pWw55So5LqO5a6J5YWo5qCh6aqMXG4gICAgdmFyIGFwcG5hbWUgPSBsaWIuZW52LmFsaWFwcCAmJiBsaWIuZW52LmFsaWFwcC5hcHBuYW1lXG4gICAgdmFyIGlzVEJUTSA9IGFwcG5hbWUgPT09ICdUQicgfHwgYXBwbmFtZSA9PT0gJ1RNJ1xuICAgIGlmIChyZXFCb2R5LmVjb2RlXG4gICAgICAgICYmICFpc1RCVE1cbiAgICAgICAgJiYgZ2xvYmFsWydVQV9PcHQnXVxuICAgICAgICAmJiAodHlwZW9mIGdsb2JhbC5nZXRVQSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICkge1xuICAgICAgcmVxQm9keS5kYXRhLnVhID0gZ2V0VUEoKVxuICAgIH1cblxuICAgIC8vIOWPquacieWcqCBhY2RzIOS4lCDlrqLmiLfnq6/niYjmnKzovr7liLDml7Yo5Y+q5pyJIFRCJjUuNCDmiJYgVE0mNS4xMCDkuYvlkI7miY3mnIkgYWNkcyDmj5Lku7Yp77yM5omN5Lya55yf5q2j55qE5Y+RIGFjZHNcbiAgICB2YXIgYWxpYXBwID0gbGliLmVudi5hbGlhcHBcbiAgICB2YXIgYXBwbmFtZSA9IGFsaWFwcCAmJiBhbGlhcHAuYXBwbmFtZVxuICAgIHZhciB2ZXJzaW9uID0gYWxpYXBwICYmIGFsaWFwcC52ZXJzaW9uXG4gICAgdmFyIHJlYWxSZXF1ZXN0VHlwZSA9XG4gICAgICAgIHJlcUJvZHkucmVxdWVzdFR5cGUgPT09ICdhY2RzJyAmJiBhbGlhcHAgJiZcbiAgICAgICAgKChhcHBuYW1lID09PSAnVEInICYmIHZlcnNpb24uZ3RlKCc1LjQnKSkgfHxcbiAgICAgICAgKGFwcG5hbWUgPT09ICdUTScgJiYgdmVyc2lvbi5ndGUoJzUuMTAnKSkpID9cbiAgICAgICAgJ2FjZHMnIDogJ210b3AnXG5cbiAgICAvLyDljIXoo4Xlm57osIPlh73mlbBcbiAgICB2YXIgcmVxQ2IgPSBmdW5jdGlvbiAocmVzcCkge1xuICAgICAgLy8gdmFyIG0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICAvLyBtLmVyckNvZGUgPSByZXNwLnJldFR5cGVcbiAgICAgIC8vIG0uZXJyTXNnID0gcmVzcC5yZXRcbiAgICAgIC8vIG0uZGF0YSA9IHJlc3AuZGF0YVxuXG4gICAgICAvLyDlpoLmnpzmmK8gYWNkcyDlm6DkuLrniYjmnKzkuI3lpJ/pmY3liLDkuoZoNe+8jOWImemcgOimgSBtb2NrIGFjZHMg55qE6L+U5Zue77yM5Zug5Li6IGpzLWZyYW1ld29yayDmoLnmja4g5LiN5ZCM55qE6K+35rGC5oq55bmz5LqG5beu5byCXG4gICAgICBpZiAocmVxQm9keS5yZXF1ZXN0VHlwZSA9PT0gJ2FjZHMnICYmIHJlYWxSZXF1ZXN0VHlwZSA9PT0gJ210b3AnKSB7XG4gICAgICAgIHJlc3AgPSByZXNwLmRhdGFcbiAgICAgIH1cblxuICAgICAgLy8gcmVzcCA9IEpTT04uc3RyaW5naWZ5KHJlc3ApXG4gICAgICBzZWxmLnNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwgcmVzcClcbiAgICB9XG5cbiAgICAvLyDlj5HpgIHor7fmsYJcbiAgICBpZiAocmVhbFJlcXVlc3RUeXBlID09PSAnYWNkcycpIHtcbiAgICAgIGxpYi53aW5kdmFuZS5jYWxsKCdIQ1dWUGx1Z2luJywgJ2dldENhdGVncmlkJywge30sIGZ1bmN0aW9uIChyZXQpIHtcbiAgICAgICAgLy8gRklYRUQ6IHJldC5yZXN1bHQg5piv5LiA5LiqIHN0cmluZ2lmeSDlkI7nmoQgSlNPTlxuICAgICAgICAvLyDlnZHvvJrlvZPnrKzkuIDmrKHpgJrov4fmraTmj5Lku7borr/pl64gYWNkcyDmlbDmja7ml7ZcbiAgICAgICAgLy8g5ZyoIEFuZHJvaWQgSHlicmlkIOS4rei/lOWbnueahOaYryByZXQ6IHtyZXN1bHQ6ICd9XG4gICAgICAgIC8vIOWcqCBpT1MgSHlicmlkIOS4rei/lOWbnueahOaYryByZXQ6IHtyZXN1bHQ6ICd7fSd9XG4gICAgICAgIHJldCA9IEpTT04ucGFyc2UocmV0LnJlc3VsdCB8fCAne30nKVxuICAgICAgICByZXFDYihyZXQpXG4gICAgICB9LCByZXFDYilcbiAgICB9XG4gICAgLy8g5aaC5p6c6ZyA6KaB55m75b2V77yM5LiU5Zyo57qvIEg1IOeOr+Wig++8jOS9v+eUqCBsb2dpblJlcXVlc3RcbiAgICBlbHNlIGlmIChuZWVkTG9naW4gJiYgIWFsaWFwcCkge1xuICAgICAgbGliLm10b3AubG9naW5SZXF1ZXN0KHJlcUJvZHkpLnRoZW4ocmVxQ2IsIHJlcUNiKVxuICAgIH1cbiAgICAvLyDlnKggSHlicmlkIOS4i++8jHdpbmR2YW5lIOS8muWIpOaWreacqueZu+W9leaLiei1t+eZu+W9leeVjOmdou+8jOebtOaOpeWPkeivt+axguWNs+WPr1xuICAgIGVsc2Uge1xuICAgICAgbGliLm10b3AucmVxdWVzdChyZXFCb2R5KS50aGVuKHJlcUNiLCByZXFDYilcbiAgICB9XG4gIH1cblxufVxuXG5zdHJlYW0uX21ldGEgPSB7XG4gIHN0cmVhbTogW3tcbiAgICBuYW1lOiAnc2VuZE10b3AnLFxuICAgIGFyZ3M6IFsnb2JqZWN0JywgJ2Z1bmN0aW9uJ11cbiAgfV1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJlYW1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXBpL3N0cmVhbS5qc1xuICoqIG1vZHVsZSBpZCA9IDEzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpICYmICh3aW5kb3cgPSB7Y3RybDoge30sIGxpYjoge319KTshd2luZG93LmN0cmwgJiYgKHdpbmRvdy5jdHJsID0ge30pOyF3aW5kb3cubGliICYmICh3aW5kb3cubGliID0ge30pOyFmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXt2YXIgYj1uZXcgUmVnRXhwKFwiKD86Xnw7XFxcXHMqKVwiK2ErXCJcXFxcPShbXjtdKykoPzo7XFxcXHMqfCQpXCIpLmV4ZWModi5jb29raWUpO3JldHVybiBiP2JbMV06Y31mdW5jdGlvbiBlKGEpe3JldHVybiBhLnByZXZlbnREZWZhdWx0KCksITF9ZnVuY3Rpb24gZihiLGMpe3ZhciBkPXRoaXMsZj1hLmRwcnx8MSxnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksaD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksaT1NYXRoLm1heChoLndpZHRoLHdpbmRvdy5pbm5lcldpZHRoKS9mLGo9TWF0aC5tYXgoaC5oZWlnaHQsd2luZG93LmlubmVySGVpZ2h0KS9mO2cuc3R5bGUuY3NzVGV4dD1bXCItd2Via2l0LXRyYW5zZm9ybTpzY2FsZShcIitmK1wiKSB0cmFuc2xhdGVaKDApXCIsXCItbXMtdHJhbnNmb3JtOnNjYWxlKFwiK2YrXCIpIHRyYW5zbGF0ZVooMClcIixcInRyYW5zZm9ybTpzY2FsZShcIitmK1wiKSB0cmFuc2xhdGVaKDApXCIsXCItd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46MCAwXCIsXCItbXMtdHJhbnNmb3JtLW9yaWdpbjowIDBcIixcInRyYW5zZm9ybS1vcmlnaW46MCAwXCIsXCJ3aWR0aDpcIitpK1wicHhcIixcImhlaWdodDpcIitqK1wicHhcIixcInotaW5kZXg6OTk5OTk5XCIsXCJwb3NpdGlvbjphYnNvbHV0ZVwiLFwibGVmdDowXCIsXCJ0b3A6MHB4XCIsXCJiYWNrZ3JvdW5kOiNGRkZcIixcImRpc3BsYXk6bm9uZVwiXS5qb2luKFwiO1wiKTt2YXIgaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2suc3R5bGUuY3NzVGV4dD1bXCJ3aWR0aDoxMDAlXCIsXCJoZWlnaHQ6NTJweFwiLFwiYmFja2dyb3VuZDojRUVFXCIsXCJsaW5lLWhlaWdodDo1MnB4XCIsXCJ0ZXh0LWFsaWduOmxlZnRcIixcImJveC1zaXppbmc6Ym9yZGVyLWJveFwiLFwicGFkZGluZy1sZWZ0OjIwcHhcIixcInBvc2l0aW9uOmFic29sdXRlXCIsXCJsZWZ0OjBcIixcInRvcDowXCIsXCJmb250LXNpemU6MTZweFwiLFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFwiY29sb3I6IzMzM1wiXS5qb2luKFwiO1wiKSxrLmlubmVyVGV4dD1iO3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2wuc3R5bGUuY3NzVGV4dD1bXCJkaXNwbGF5OmJsb2NrXCIsXCJwb3NpdGlvbjphYnNvbHV0ZVwiLFwicmlnaHQ6MFwiLFwidG9wOjBcIixcImhlaWdodDo1MnB4XCIsXCJsaW5lLWhlaWdodDo1MnB4XCIsXCJwYWRkaW5nOjAgMjBweFwiLFwiY29sb3I6Izk5OVwiXS5qb2luKFwiO1wiKSxsLmlubmVyVGV4dD1cIuWFs+mXrVwiO3ZhciBtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7bS5zdHlsZS5jc3NUZXh0PVtcIndpZHRoOjEwMCVcIixcImhlaWdodDoxMDAlXCIsXCJib3JkZXI6MFwiLFwib3ZlcmZsb3c6aGlkZGVuXCJdLmpvaW4oXCI7XCIpLGsuYXBwZW5kQ2hpbGQobCksZy5hcHBlbmRDaGlsZChrKSxnLmFwcGVuZENoaWxkKG0pLHYuYm9keS5hcHBlbmRDaGlsZChnKSxtLnNyYz1jLGwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsZnVuY3Rpb24oKXtkLmhpZGUoKTt2YXIgYT12LmNyZWF0ZUV2ZW50KFwiSFRNTEV2ZW50c1wiKTthLmluaXRFdmVudChcImNsb3NlXCIsITEsITEpLGcuZGlzcGF0Y2hFdmVudChhKX0sITEpLHRoaXMuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbigpe2cuYWRkRXZlbnRMaXN0ZW5lci5hcHBseShnLGFyZ3VtZW50cyl9LHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbigpe2cucmVtb3ZlRXZlbnRMaXN0ZW5lci5hcHBseShnLGFyZ3VtZW50cyl9LHRoaXMuc2hvdz1mdW5jdGlvbigpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIixlLCExKSxnLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHdpbmRvdy5zY3JvbGxUbygwLDApfSx0aGlzLmhpZGU9ZnVuY3Rpb24oKXtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsZSksd2luZG93LnNjcm9sbFRvKDAsLWgudG9wKSx2LmJvZHkucmVtb3ZlQ2hpbGQoZyl9fWZ1bmN0aW9uIGcoYSl7aWYoIWF8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGF8fCFiLm10b3Ape3ZhciBkPXRoaXMuZ2V0VXNlck5pY2soKTtyZXR1cm4hIWR9Yi5tdG9wLnJlcXVlc3Qoe2FwaTpcIm10b3AudXNlci5nZXRVc2VyU2ltcGxlXCIsdjpcIjEuMFwiLGRhdGE6e2lzU2VjOjB9LEg1UmVxdWVzdDohMH0sZnVuY3Rpb24oZCl7ZC5yZXRUeXBlPT09Yi5tdG9wLlJFU1BPTlNFX1RZUEUuU1VDQ0VTUz9hKCEwLGQpOmQucmV0VHlwZT09PWIubXRvcC5SRVNQT05TRV9UWVBFLlNFU1NJT05fRVhQSVJFRD9hKCExLGQpOmEoYyxkKX0pfWZ1bmN0aW9uIGgoYSl7dmFyIGI7cmV0dXJuIHUmJihiPXt9LGIucHJvbWlzZT1uZXcgdShmdW5jdGlvbihhLGMpe2IucmVzb2x2ZT1hLGIucmVqZWN0PWN9KSksdGhpcy5pc0xvZ2luKGZ1bmN0aW9uKGMsZCl7YSYmYShjLGQpLGM9PT0hMD9iJiZiLnJlc29sdmUoZCk6YiYmYi5yZWplY3QoZCl9KSxiP2IucHJvbWlzZTp2b2lkIDB9ZnVuY3Rpb24gaShhKXtpZighYXx8XCJmdW5jdGlvblwiIT10eXBlb2YgYSl7dmFyIGI9XCJcIixlPWQoXCJfd190Yl9uaWNrXCIpLGY9ZChcIl9ua19cIil8fGQoXCJzbmtcIiksZz1kKFwic25cIik7cmV0dXJuIGUmJmUubGVuZ3RoPjAmJlwibnVsbFwiIT1lP2I9ZGVjb2RlVVJJQ29tcG9uZW50KGUpOmYmJmYubGVuZ3RoPjAmJlwibnVsbFwiIT1mP2I9dW5lc2NhcGUodW5lc2NhcGUoZikucmVwbGFjZSgvXFxcXHUvZyxcIiV1XCIpKTpnJiZnLmxlbmd0aD4wJiZcIm51bGxcIiE9ZyYmKGI9ZGVjb2RlVVJJQ29tcG9uZW50KGcpKSxiPWIucmVwbGFjZSgvXFw8L2csXCImbHQ7XCIpLnJlcGxhY2UoL1xcPi9nLFwiJmd0O1wiKX10aGlzLmlzTG9naW4oZnVuY3Rpb24oYixkKXthKGI9PT0hMCYmZCYmZC5kYXRhJiZkLmRhdGEubmljaz9kLmRhdGEubmljazpiPT09ITE/XCJcIjpjKX0pfWZ1bmN0aW9uIGooYSl7dmFyIGI7cmV0dXJuIHUmJihiPXt9LGIucHJvbWlzZT1uZXcgdShmdW5jdGlvbihhLGMpe2IucmVzb2x2ZT1hLGIucmVqZWN0PWN9KSksdGhpcy5nZXRVc2VyTmljayhmdW5jdGlvbihjKXthJiZhKGMpLGM/YiYmYi5yZXNvbHZlKGMpOmImJmIucmVqZWN0KCl9KSxiP2IucHJvbWlzZTp2b2lkIDB9ZnVuY3Rpb24gayhhLGIpe3ZhciBjPVwiLy9cIitHK1wiLlwiK0guc3ViRG9tYWluK1wiLlwiK0UrXCIvXCIrSFsoYXx8XCJsb2dpblwiKStcIk5hbWVcIl07aWYoYil7dmFyIGQ9W107Zm9yKHZhciBlIGluIGIpZC5wdXNoKGUrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGJbZV0pKTtjKz1cIj9cIitkLmpvaW4oXCImXCIpfXJldHVybiBjfWZ1bmN0aW9uIGwoYSxiKXtpZihiKWxvY2F0aW9uLnJlcGxhY2UoYSk7ZWxzZXt2YXIgYz12LmNyZWF0ZUVsZW1lbnQoXCJhXCIpLGQ9di5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIik7Yy5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLGMuaHJlZj1hLHYuYm9keS5hcHBlbmRDaGlsZChjKSxkLmluaXRFdmVudChcImNsaWNrXCIsITEsITApLGMuZGlzcGF0Y2hFdmVudChkKX19ZnVuY3Rpb24gbShiLGMsZCl7ZnVuY3Rpb24gZShiKXtqLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLGUpLGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixnKSxkKFwiQ0FOQ0VMXCIpfWZ1bmN0aW9uIGcoYil7dmFyIGM9Yi5kYXRhfHx7fTtjJiZcImNoaWxkXCI9PT1jLnR5cGUmJmMuY29udGVudC5pbmRleE9mKFwiU1VDQ0VTU1wiKT4tMT8oai5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIixlKSxhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZyksai5oaWRlKCksZChcIlNVQ0NFU1NcIikpOmQoXCJGQUlMVVJFXCIpfXZhciBoPWxvY2F0aW9uLnByb3RvY29sK1wiLy9oNS5cIitILnN1YkRvbWFpbitcIi50YW9iYW8uY29tL1wiKyhcIndhcHRlc3RcIj09PUguc3ViRG9tYWluP1wic3JjXCI6XCJvdGhlclwiKStcIi9cIitiK1wiZW5kLmh0bWw/b3JpZ2luPVwiK2VuY29kZVVSSUNvbXBvbmVudChsb2NhdGlvbi5wcm90b2NvbCtcIi8vXCIrbG9jYXRpb24uaG9zdG5hbWUpLGk9ayhiLHt0dGlkOlwiaDVAaWZyYW1lXCIsdHBsX3JlZGlyZWN0X3VybDpofSksaj1uZXcgZihjLnRpdGxlfHxcIuaCqOmcgOimgeeZu+W9leaJjeiDvee7p+e7reiuv+mXrlwiLGkpO2ouYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsZSwhMSksYS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGcsITEpLGouc2hvdygpfWZ1bmN0aW9uIG4oYixjLGQpe3ZhciBlPWsoYix7d3ZMb2dpbkNhbGxiYWNrOlwid3ZMb2dpbkNhbGxiYWNrXCJ9KTthLnd2TG9naW5DYWxsYmFjaz1mdW5jdGlvbihiKXtkZWxldGUgYS53dkxvZ2luQ2FsbGJhY2ssZChiLmluZGV4T2YoXCI6U1VDQ0VTU1wiKT4tMT9cIlNVQ0NFU1NcIjpiLmluZGV4T2YoXCI6Q0FOQ0VMXCIpPi0xP1wiQ0FOQ0VMXCI6XCJGQUlMVVJFXCIpfSxsKGUpfWZ1bmN0aW9uIG8oYSxiLGMpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGI/KGM9YixiPW51bGwpOlwic3RyaW5nXCI9PXR5cGVvZiBiJiYoYj17cmVkaXJlY3RVcmw6Yn0pLGI9Ynx8e30sYyYmQSluKGEsYixjKTtlbHNlIGlmKGMmJiF6JiZcImxvZ2luXCI9PT1hKW0oYSxiLGMpO2Vsc2V7dmFyIGQ9ayhhLHt0cGxfcmVkaXJlY3RfdXJsOmIucmVkaXJlY3RVcmx8fGxvY2F0aW9uLmhyZWZ9KTtsKGQsYi5yZXBsYWNlKX19ZnVuY3Rpb24gcChhLGIsYyl7dmFyIGQ7cmV0dXJuIHUmJihkPXt9LGQucHJvbWlzZT1uZXcgdShmdW5jdGlvbihhLGIpe2QucmVzb2x2ZT1hLGQucmVqZWN0PWJ9KSksbyhhLGIsZnVuY3Rpb24oYSl7YyYmYyhhKSxcIlNVQ0NFU1NcIj09PWE/ZCYmZC5yZXNvbHZlKGEpOmQmJmQucmVqZWN0KGEpfSksZD9kLnByb21pc2U6dm9pZCAwfWZ1bmN0aW9uIHEoYSl7byhcImxvZ2luXCIsYSl9ZnVuY3Rpb24gcihhKXtyZXR1cm4gcChcImxvZ2luXCIsYSl9ZnVuY3Rpb24gcyhhKXtvKFwibG9nb3V0XCIsYSl9ZnVuY3Rpb24gdChhKXtyZXR1cm4gcChcImxvZ291dFwiLGEpfXZhciB1PWEuUHJvbWlzZSx2PWEuZG9jdW1lbnQsdz1hLm5hdmlnYXRvci51c2VyQWdlbnQseD1sb2NhdGlvbi5ob3N0bmFtZSx5PShhLmxvY2F0aW9uLnNlYXJjaCx3Lm1hdGNoKC9XaW5kVmFuZVtcXC9cXHNdKFtcXGRcXC5cXF9dKykvKSksej13Lm1hdGNoKC9BbGlBcHBcXCgoW15cXC9dKylcXC8oW1xcZFxcLlxcX10rKVxcKS9pKSxBPSEhKHomJlwiVEJcIj09PXpbMV0mJnkmJnBhcnNlRmxvYXQoeVsxXSk+NS4yKSxCPVtcInRhb2Jhby5uZXRcIixcInRhb2Jhby5jb21cIl0sQz1uZXcgUmVnRXhwKFwiKFteLl0qPylcXFxcLj8oKD86XCIrQi5qb2luKFwiKXwoPzpcIikucmVwbGFjZSgvXFwuL2csXCJcXFxcLlwiKStcIikpXCIsXCJpXCIpLEQ9eC5tYXRjaChDKXx8W10sRT1mdW5jdGlvbigpe3ZhciBhPURbMl18fFwidGFvYmFvLmNvbVwiO3JldHVybiBhLm1hdGNoKC9cXC4/dGFvYmFvXFwubmV0JC8pP1widGFvYmFvLm5ldFwiOlwidGFvYmFvLmNvbVwifSgpLEY9ZnVuY3Rpb24oKXt2YXIgYT1FLGI9RFsxXXx8XCJtXCI7cmV0dXJuXCJ0YW9iYW8ubmV0XCI9PT1hJiYoYj1cIndhcHRlc3RcIiksYn0oKSxHPVwibG9naW5cIjtiLmxvZ2luPWIubG9naW58fHt9O3ZhciBIPXtsb2dpbk5hbWU6XCJsb2dpbi5odG1cIixsb2dvdXROYW1lOlwibG9nb3V0Lmh0bVwiLHN1YkRvbWFpbjpGfTtiLmxvZ2luLmNvbmZpZz1ILGIubG9naW4uaXNMb2dpbj1nLGIubG9naW4uaXNMb2dpbkFzeW5jPWgsYi5sb2dpbi5nZXRVc2VyTmljaz1pLGIubG9naW4uZ2V0VXNlck5pY2tBc3luYz1qLGIubG9naW4uZ2VuZXJhdGVVcmw9ayxiLmxvZ2luLmdvTG9naW49cSxiLmxvZ2luLmdvTG9naW5Bc3luYz1yLGIubG9naW4uZ29Mb2dvdXQ9cyxiLmxvZ2luLmdvTG9nb3V0QXN5bmM9dH0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSk7O21vZHVsZS5leHBvcnRzID0gd2luZG93LmxpYi5sb2dpbjtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYWxpL2xpYi1sb2dpbi9idWlsZC9sb2dpbi5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSAmJiAod2luZG93ID0ge2N0cmw6IHt9LCBsaWI6IHt9fSk7IXdpbmRvdy5jdHJsICYmICh3aW5kb3cuY3RybCA9IHt9KTshd2luZG93LmxpYiAmJiAod2luZG93LmxpYiA9IHt9KTshZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7dmFyIGE9e30sYj1uZXcgbShmdW5jdGlvbihiLGMpe2EucmVzb2x2ZT1iLGEucmVqZWN0PWN9KTtyZXR1cm4gYS5wcm9taXNlPWIsYX1mdW5jdGlvbiBkKGEsYil7Zm9yKHZhciBjIGluIGIpdm9pZCAwPT09YVtjXSYmKGFbY109YltjXSk7cmV0dXJuIGF9ZnVuY3Rpb24gZShhKXt2YXIgYj1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF18fGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXXx8ZG9jdW1lbnQuZmlyc3RFbGVtZW50Q2hpbGR8fGRvY3VtZW50O2IuYXBwZW5kQ2hpbGQoYSl9ZnVuY3Rpb24gZihhKXt2YXIgYj1bXTtmb3IodmFyIGMgaW4gYSlhW2NdJiZiLnB1c2goYytcIj1cIitlbmNvZGVVUklDb21wb25lbnQoYVtjXSkpO3JldHVybiBiLmpvaW4oXCImXCIpfWZ1bmN0aW9uIGcoYSl7ZnVuY3Rpb24gYihhLGIpe3JldHVybiBhPDxifGE+Pj4zMi1ifWZ1bmN0aW9uIGMoYSxiKXt2YXIgYyxkLGUsZixnO3JldHVybiBlPTIxNDc0ODM2NDgmYSxmPTIxNDc0ODM2NDgmYixjPTEwNzM3NDE4MjQmYSxkPTEwNzM3NDE4MjQmYixnPSgxMDczNzQxODIzJmEpKygxMDczNzQxODIzJmIpLGMmZD8yMTQ3NDgzNjQ4XmdeZV5mOmN8ZD8xMDczNzQxODI0Jmc/MzIyMTIyNTQ3Ml5nXmVeZjoxMDczNzQxODI0XmdeZV5mOmdeZV5mfWZ1bmN0aW9uIGQoYSxiLGMpe3JldHVybiBhJmJ8fmEmY31mdW5jdGlvbiBlKGEsYixjKXtyZXR1cm4gYSZjfGImfmN9ZnVuY3Rpb24gZihhLGIsYyl7cmV0dXJuIGFeYl5jfWZ1bmN0aW9uIGcoYSxiLGMpe3JldHVybiBiXihhfH5jKX1mdW5jdGlvbiBoKGEsZSxmLGcsaCxpLGope3JldHVybiBhPWMoYSxjKGMoZChlLGYsZyksaCksaikpLGMoYihhLGkpLGUpfWZ1bmN0aW9uIGkoYSxkLGYsZyxoLGksail7cmV0dXJuIGE9YyhhLGMoYyhlKGQsZixnKSxoKSxqKSksYyhiKGEsaSksZCl9ZnVuY3Rpb24gaihhLGQsZSxnLGgsaSxqKXtyZXR1cm4gYT1jKGEsYyhjKGYoZCxlLGcpLGgpLGopKSxjKGIoYSxpKSxkKX1mdW5jdGlvbiBrKGEsZCxlLGYsaCxpLGope3JldHVybiBhPWMoYSxjKGMoZyhkLGUsZiksaCksaikpLGMoYihhLGkpLGQpfWZ1bmN0aW9uIGwoYSl7Zm9yKHZhciBiLGM9YS5sZW5ndGgsZD1jKzgsZT0oZC1kJTY0KS82NCxmPTE2KihlKzEpLGc9bmV3IEFycmF5KGYtMSksaD0wLGk9MDtjPmk7KWI9KGktaSU0KS80LGg9aSU0KjgsZ1tiXT1nW2JdfGEuY2hhckNvZGVBdChpKTw8aCxpKys7cmV0dXJuIGI9KGktaSU0KS80LGg9aSU0KjgsZ1tiXT1nW2JdfDEyODw8aCxnW2YtMl09Yzw8MyxnW2YtMV09Yz4+PjI5LGd9ZnVuY3Rpb24gbShhKXt2YXIgYixjLGQ9XCJcIixlPVwiXCI7Zm9yKGM9MDszPj1jO2MrKyliPWE+Pj44KmMmMjU1LGU9XCIwXCIrYi50b1N0cmluZygxNiksZCs9ZS5zdWJzdHIoZS5sZW5ndGgtMiwyKTtyZXR1cm4gZH1mdW5jdGlvbiBuKGEpe2E9YS5yZXBsYWNlKC9cXHJcXG4vZyxcIlxcblwiKTtmb3IodmFyIGI9XCJcIixjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWEuY2hhckNvZGVBdChjKTsxMjg+ZD9iKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGQpOmQ+MTI3JiYyMDQ4PmQ/KGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoZD4+NnwxOTIpLGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNjMmZHwxMjgpKTooYis9U3RyaW5nLmZyb21DaGFyQ29kZShkPj4xMnwyMjQpLGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoZD4+NiY2M3wxMjgpLGIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNjMmZHwxMjgpKX1yZXR1cm4gYn12YXIgbyxwLHEscixzLHQsdSx2LHcseD1bXSx5PTcsej0xMixBPTE3LEI9MjIsQz01LEQ9OSxFPTE0LEY9MjAsRz00LEg9MTEsST0xNixKPTIzLEs9NixMPTEwLE09MTUsTj0yMTtmb3IoYT1uKGEpLHg9bChhKSx0PTE3MzI1ODQxOTMsdT00MDIzMjMzNDE3LHY9MjU2MjM4MzEwMix3PTI3MTczMzg3OCxvPTA7bzx4Lmxlbmd0aDtvKz0xNilwPXQscT11LHI9dixzPXcsdD1oKHQsdSx2LHcseFtvKzBdLHksMzYxNDA5MDM2MCksdz1oKHcsdCx1LHYseFtvKzFdLHosMzkwNTQwMjcxMCksdj1oKHYsdyx0LHUseFtvKzJdLEEsNjA2MTA1ODE5KSx1PWgodSx2LHcsdCx4W28rM10sQiwzMjUwNDQxOTY2KSx0PWgodCx1LHYsdyx4W28rNF0seSw0MTE4NTQ4Mzk5KSx3PWgodyx0LHUsdix4W28rNV0seiwxMjAwMDgwNDI2KSx2PWgodix3LHQsdSx4W28rNl0sQSwyODIxNzM1OTU1KSx1PWgodSx2LHcsdCx4W28rN10sQiw0MjQ5MjYxMzEzKSx0PWgodCx1LHYsdyx4W28rOF0seSwxNzcwMDM1NDE2KSx3PWgodyx0LHUsdix4W28rOV0seiwyMzM2NTUyODc5KSx2PWgodix3LHQsdSx4W28rMTBdLEEsNDI5NDkyNTIzMyksdT1oKHUsdix3LHQseFtvKzExXSxCLDIzMDQ1NjMxMzQpLHQ9aCh0LHUsdix3LHhbbysxMl0seSwxODA0NjAzNjgyKSx3PWgodyx0LHUsdix4W28rMTNdLHosNDI1NDYyNjE5NSksdj1oKHYsdyx0LHUseFtvKzE0XSxBLDI3OTI5NjUwMDYpLHU9aCh1LHYsdyx0LHhbbysxNV0sQiwxMjM2NTM1MzI5KSx0PWkodCx1LHYsdyx4W28rMV0sQyw0MTI5MTcwNzg2KSx3PWkodyx0LHUsdix4W28rNl0sRCwzMjI1NDY1NjY0KSx2PWkodix3LHQsdSx4W28rMTFdLEUsNjQzNzE3NzEzKSx1PWkodSx2LHcsdCx4W28rMF0sRiwzOTIxMDY5OTk0KSx0PWkodCx1LHYsdyx4W28rNV0sQywzNTkzNDA4NjA1KSx3PWkodyx0LHUsdix4W28rMTBdLEQsMzgwMTYwODMpLHY9aSh2LHcsdCx1LHhbbysxNV0sRSwzNjM0NDg4OTYxKSx1PWkodSx2LHcsdCx4W28rNF0sRiwzODg5NDI5NDQ4KSx0PWkodCx1LHYsdyx4W28rOV0sQyw1Njg0NDY0MzgpLHc9aSh3LHQsdSx2LHhbbysxNF0sRCwzMjc1MTYzNjA2KSx2PWkodix3LHQsdSx4W28rM10sRSw0MTA3NjAzMzM1KSx1PWkodSx2LHcsdCx4W28rOF0sRiwxMTYzNTMxNTAxKSx0PWkodCx1LHYsdyx4W28rMTNdLEMsMjg1MDI4NTgyOSksdz1pKHcsdCx1LHYseFtvKzJdLEQsNDI0MzU2MzUxMiksdj1pKHYsdyx0LHUseFtvKzddLEUsMTczNTMyODQ3MyksdT1pKHUsdix3LHQseFtvKzEyXSxGLDIzNjgzNTk1NjIpLHQ9aih0LHUsdix3LHhbbys1XSxHLDQyOTQ1ODg3MzgpLHc9aih3LHQsdSx2LHhbbys4XSxILDIyNzIzOTI4MzMpLHY9aih2LHcsdCx1LHhbbysxMV0sSSwxODM5MDMwNTYyKSx1PWoodSx2LHcsdCx4W28rMTRdLEosNDI1OTY1Nzc0MCksdD1qKHQsdSx2LHcseFtvKzFdLEcsMjc2Mzk3NTIzNiksdz1qKHcsdCx1LHYseFtvKzRdLEgsMTI3Mjg5MzM1Myksdj1qKHYsdyx0LHUseFtvKzddLEksNDEzOTQ2OTY2NCksdT1qKHUsdix3LHQseFtvKzEwXSxKLDMyMDAyMzY2NTYpLHQ9aih0LHUsdix3LHhbbysxM10sRyw2ODEyNzkxNzQpLHc9aih3LHQsdSx2LHhbbyswXSxILDM5MzY0MzAwNzQpLHY9aih2LHcsdCx1LHhbbyszXSxJLDM1NzI0NDUzMTcpLHU9aih1LHYsdyx0LHhbbys2XSxKLDc2MDI5MTg5KSx0PWoodCx1LHYsdyx4W28rOV0sRywzNjU0NjAyODA5KSx3PWoodyx0LHUsdix4W28rMTJdLEgsMzg3MzE1MTQ2MSksdj1qKHYsdyx0LHUseFtvKzE1XSxJLDUzMDc0MjUyMCksdT1qKHUsdix3LHQseFtvKzJdLEosMzI5OTYyODY0NSksdD1rKHQsdSx2LHcseFtvKzBdLEssNDA5NjMzNjQ1Miksdz1rKHcsdCx1LHYseFtvKzddLEwsMTEyNjg5MTQxNSksdj1rKHYsdyx0LHUseFtvKzE0XSxNLDI4Nzg2MTIzOTEpLHU9ayh1LHYsdyx0LHhbbys1XSxOLDQyMzc1MzMyNDEpLHQ9ayh0LHUsdix3LHhbbysxMl0sSywxNzAwNDg1NTcxKSx3PWsodyx0LHUsdix4W28rM10sTCwyMzk5OTgwNjkwKSx2PWsodix3LHQsdSx4W28rMTBdLE0sNDI5MzkxNTc3MyksdT1rKHUsdix3LHQseFtvKzFdLE4sMjI0MDA0NDQ5NyksdD1rKHQsdSx2LHcseFtvKzhdLEssMTg3MzMxMzM1OSksdz1rKHcsdCx1LHYseFtvKzE1XSxMLDQyNjQzNTU1NTIpLHY9ayh2LHcsdCx1LHhbbys2XSxNLDI3MzQ3Njg5MTYpLHU9ayh1LHYsdyx0LHhbbysxM10sTiwxMzA5MTUxNjQ5KSx0PWsodCx1LHYsdyx4W28rNF0sSyw0MTQ5NDQ0MjI2KSx3PWsodyx0LHUsdix4W28rMTFdLEwsMzE3NDc1NjkxNyksdj1rKHYsdyx0LHUseFtvKzJdLE0sNzE4Nzg3MjU5KSx1PWsodSx2LHcsdCx4W28rOV0sTiwzOTUxNDgxNzQ1KSx0PWModCxwKSx1PWModSxxKSx2PWModixyKSx3PWModyxzKTt2YXIgTz1tKHQpK20odSkrbSh2KSttKHcpO3JldHVybiBPLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gaChhKXt2YXIgYj1uZXcgUmVnRXhwKFwiKD86Xnw7XFxcXHMqKVwiK2ErXCJcXFxcPShbXjtdKykoPzo7XFxcXHMqfCQpXCIpLmV4ZWMoZG9jdW1lbnQuY29va2llKTtyZXR1cm4gYj9iWzFdOnZvaWQgMH1mdW5jdGlvbiBpKGEsYixjKXt2YXIgZD1uZXcgRGF0ZTtkLnNldFRpbWUoZC5nZXRUaW1lKCktODY0ZTUpO3ZhciBlPVwiL1wiO2RvYy5jb29raWU9YStcIj07cGF0aD1cIitlK1wiO2RvbWFpbj0uXCIrYitcIjtleHBpcmVzPVwiK2QudG9HTVRTdHJpbmcoKSxkb2MuY29va2llPWErXCI9O3BhdGg9XCIrZStcIjtkb21haW49LlwiK2MrXCIuXCIrYitcIjtleHBpcmVzPVwiK2QudG9HTVRTdHJpbmcoKX1mdW5jdGlvbiBqKCl7dmFyIGI9YS5sb2NhdGlvbi5ob3N0bmFtZSxjPVtcInRhb2Jhby5uZXRcIixcInRhb2Jhby5jb21cIixcInRtYWxsLmNvbVwiLFwidG1hbGwuaGtcIixcImV0YW8uY29tXCJdLGQ9bmV3IFJlZ0V4cChcIihbXi5dKj8pXFxcXC4/KCg/OlwiK2Muam9pbihcIil8KD86XCIpLnJlcGxhY2UoL1xcLi9nLFwiXFxcXC5cIikrXCIpKVwiLFwiaVwiKSxlPWIubWF0Y2goZCl8fFtdLGY9ZVsyXXx8XCJ0YW9iYW8uY29tXCIsZz1lWzFdfHxcIm1cIjtcInRhb2Jhby5uZXRcIiE9PWZ8fFwieFwiIT09ZyYmXCJ3YXB0ZXN0XCIhPT1nJiZcImRhaWx5XCIhPT1nP1widGFvYmFvLm5ldFwiPT09ZiYmXCJkZW1vXCI9PT1nP2c9XCJkZW1vXCI6XCJ3YXB0ZXN0XCIhPT1nJiZcIndhcGFcIiE9PWcmJlwibVwiIT09ZyYmKGc9XCJtXCIpOmc9XCJ3YXB0ZXN0XCI7dmFyIGg9XCJldGFvLmNvbVwiPT09Zj9cImFwaWVcIjpcImFwaVwiO3IubWFpbkRvbWFpbj1mLHIuc3ViRG9tYWluPWcsci5wcmVmaXg9aH1mdW5jdGlvbiBrKCl7dmFyIGI9YS5uYXZpZ2F0b3IudXNlckFnZW50LGM9Yi5tYXRjaCgvV2luZFZhbmVbXFwvXFxzXShbXFxkXFwuXFxfXSspLyk7YyYmKHIuV2luZFZhbmVWZXJzaW9uPWNbMV0pO3ZhciBkPWIubWF0Y2goL0FsaUFwcFxcKChbXlxcL10rKVxcLyhbXFxkXFwuXFxfXSspXFwpL2kpO2QmJihyLkFsaUFwcE5hbWU9ZFsxXSxyLkFsaUFwcFZlcnNpb249ZFsyXSl9ZnVuY3Rpb24gbChhKXt0aGlzLmlkPSsrdSx0aGlzLnBhcmFtcz1kKGF8fHt9LHt2OlwiKlwiLGRhdGE6e30sdHlwZTpcImdldFwiLGRhdGFUeXBlOlwianNvbnBcIn0pLHRoaXMucGFyYW1zLnR5cGU9dGhpcy5wYXJhbXMudHlwZS50b0xvd2VyQ2FzZSgpLFwib2JqZWN0XCI9PXR5cGVvZiB0aGlzLnBhcmFtcy5kYXRhJiYodGhpcy5wYXJhbXMuZGF0YT1KU09OLnN0cmluZ2lmeSh0aGlzLnBhcmFtcy5kYXRhKSksdGhpcy5taWRkbGV3YXJlcz1zLnNsaWNlKDApfXZhciBtPWEuUHJvbWlzZTtpZighbSl7dmFyIG49XCLlvZPliY3mtY/op4jlmajkuI3mlK/mjIFQcm9taXNl77yM6K+35Y+C6ICD5paH5qGj77yIaHR0cDovL2dpdGxhYi5hbGliYWJhLWluYy5jb20vbXRiL2xpYi1lczZwb2x5ZmlsbC90cmVlL21hc3Rlcu+8ieS4reeahOino+WGs+aWueahiFwiO3JldHVybiBiLm10b3A9e0VSUk9SOm59LHZvaWQgY29uc29sZS5lcnJvcihuKX12YXIgbz1tLnJlc29sdmUoKSxwPWEubG9jYWxTdG9yYWdlO2lmKHApdHJ5e3Auc2V0SXRlbShcIkBwcml2YXRlXCIsXCJmYWxzZVwiKX1jYXRjaChxKXtwPSExfXZhciByPXt1c2VBbGlwYXlKU0JyaWRnZTohMX0scz1bXSx0PXtFUlJPUjotMSxTVUNDRVNTOjAsVE9LRU5fRVhQSVJFRDoxLFNFU1NJT05fRVhQSVJFRDoyfTtqKCksaygpO3ZhciB1PTA7bC5wcm90b3R5cGUudXNlPWZ1bmN0aW9uKGEpe2lmKCFhKXRocm93IG5ldyBFcnJvcihcIm1pZGRsZXdhcmUgaXMgdW5kZWZpbmVkXCIpO3JldHVybiB0aGlzLm1pZGRsZXdhcmVzLnB1c2goYSksdGhpc30sbC5wcm90b3R5cGUuX19wcm9jZXNzUmVxdWVzdE1ldGhvZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnBhcmFtcyxjPXRoaXMub3B0aW9ucztcImdldFwiPT09Yi50eXBlJiZcImpzb25wXCI9PT1iLmRhdGFUeXBlP2MuZ2V0SlNPTlA9ITA6XCJnZXRcIj09PWIudHlwZSYmXCJqc29uXCI9PT1iLmRhdGFUeXBlP2MuZ2V0SlNPTj0hMDpcInBvc3RcIj09PWIudHlwZSYmKGMucG9zdEpTT049ITApLGEoKX0sbC5wcm90b3R5cGUuX19wcm9jZXNzUmVxdWVzdFR5cGU9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcyxkPXRoaXMub3B0aW9ucztpZihyLkg1UmVxdWVzdD09PSEwJiYoZC5INVJlcXVlc3Q9ITApLHIuV2luZFZhbmVSZXF1ZXN0PT09ITAmJihkLldpbmRWYW5lUmVxdWVzdD0hMCksZC5INVJlcXVlc3Q9PT0hMSYmZC5XaW5kVmFuZVJlcXVlc3Q9PT0hMCl7aWYoIWIud2luZHZhbmV8fHBhcnNlRmxvYXQoZC5XaW5kVmFuZVZlcnNpb24pPDUuNCl0aHJvdyBuZXcgRXJyb3IoXCJXSU5EVkFORV9OT1RfRk9VTkQ6Oue8uuWwkVdpbmRWYW5l546v5aKDXCIpfWVsc2UgZC5INVJlcXVlc3Q9PT0hMD9kLldpbmRWYW5lUmVxdWVzdD0hMTpcInVuZGVmaW5lZFwiPT10eXBlb2YgZC5XaW5kVmFuZVJlcXVlc3QmJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBkLkg1UmVxdWVzdCYmKGIud2luZHZhbmUmJnBhcnNlRmxvYXQoZC5XaW5kVmFuZVZlcnNpb24pPj01LjQ/ZC5XaW5kVmFuZVJlcXVlc3Q9ITA6ZC5INVJlcXVlc3Q9ITApO2EoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGE9ZC5yZXRKc29uLnJldDtyZXR1cm4gYSBpbnN0YW5jZW9mIEFycmF5JiYoYT1hLmpvaW4oXCIsXCIpKSxkLldpbmRWYW5lUmVxdWVzdD09PSEwJiYoIWF8fGEuaW5kZXhPZihcIkhZX0ZBSUxFRFwiKT4tMXx8YS5pbmRleE9mKFwiSFlfTk9fSEFORExFUlwiKT4tMXx8YS5pbmRleE9mKFwiSFlfQ0xPU0VEXCIpPi0xfHxhLmluZGV4T2YoXCJIWV9FWENFUFRJT05cIik+LTF8fGEuaW5kZXhPZihcIkhZX05PX1BFUk1JU1NJT05cIik+LTEpPyhyLkg1UmVxdWVzdD0hMCxjLl9fc2VxdWVuY2UoW2MuX19wcm9jZXNzUmVxdWVzdFR5cGUsYy5fX3Byb2Nlc3NUb2tlbixjLl9fcHJvY2Vzc1JlcXVlc3RVcmwsYy5fX3Byb2Nlc3NVbml0UHJlZml4LGMubWlkZGxld2FyZXMsYy5fX3Byb2Nlc3NSZXF1ZXN0XSkpOnZvaWQgMH0pfTt2YXIgdj1cIl9tX2g1X3RrXCIsdz1cIl9tX2g1X3RrX2VuY1wiO2wucHJvdG90eXBlLl9fZ2V0VG9rZW5Gcm9tQWxpcGF5PWZ1bmN0aW9uKCl7dmFyIGI9YygpLGQ9dGhpcy5vcHRpb25zLGU9KGEubmF2aWdhdG9yLnVzZXJBZ2VudCwhIWxvY2F0aW9uLnByb3RvY29sLm1hdGNoKC9eaHR0cHM/XFw6JC8pKSxmPVwiQVBcIj09PWQuQWxpQXBwTmFtZSYmcGFyc2VGbG9hdChkLkFsaUFwcFZlcnNpb24pPj04LjI7cmV0dXJuIGQudXNlQWxpcGF5SlNCcmlkZ2U9PT0hMCYmIWUmJmYmJmEuQWxpcGF5SlNCcmlkZ2UmJmEuQWxpcGF5SlNCcmlkZ2UuY2FsbD9hLkFsaXBheUpTQnJpZGdlLmNhbGwoXCJnZXRNdG9wVG9rZW5cIixmdW5jdGlvbihhKXthJiZhLnRva2VuJiYoZC50b2tlbj1hLnRva2VuKSxiLnJlc29sdmUoKX0sZnVuY3Rpb24oKXtiLnJlc29sdmUoKX0pOmIucmVzb2x2ZSgpLGIucHJvbWlzZX0sbC5wcm90b3R5cGUuX19nZXRUb2tlbkZyb21Db29raWU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnM7cmV0dXJuIGEudG9rZW49YS50b2tlbnx8aCh2KSxhLnRva2VuJiYoYS50b2tlbj1hLnRva2VuLnNwbGl0KFwiX1wiKVswXSksbS5yZXNvbHZlKCl9LGwucHJvdG90eXBlLl9fcHJvY2Vzc1Rva2VuPWZ1bmN0aW9uKGEpe3t2YXIgYj10aGlzLGM9dGhpcy5vcHRpb25zO3RoaXMucGFyYW1zfXJldHVybiBjLnRva2VuJiZkZWxldGUgYy50b2tlbixjLldpbmRWYW5lUmVxdWVzdCE9PSEwP28udGhlbihmdW5jdGlvbigpe3JldHVybiBiLl9fZ2V0VG9rZW5Gcm9tQWxpcGF5KCl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGIuX19nZXRUb2tlbkZyb21Db29raWUoKX0pLnRoZW4oYSkudGhlbihmdW5jdGlvbigpe3ZhciBhPWMucmV0SnNvbixkPWEucmV0O2lmKGQgaW5zdGFuY2VvZiBBcnJheSYmKGQ9ZC5qb2luKFwiLFwiKSksZC5pbmRleE9mKFwiVE9LRU5fRU1QVFlcIik+LTF8fGQuaW5kZXhPZihcIlRPS0VOX0VYT0lSRURcIik+LTEpe2lmKGMubWF4UmV0cnlUaW1lcz1jLm1heFJldHJ5VGltZXN8fDUsYy5mYWlsVGltZXM9Yy5mYWlsVGltZXN8fDAsYy5INVJlcXVlc3QmJisrYy5mYWlsVGltZXM8Yy5tYXhSZXRyeVRpbWVzKXJldHVybiBiLl9fc2VxdWVuY2UoW2IuX19wcm9jZXNzVG9rZW4sYi5fX3Byb2Nlc3NSZXF1ZXN0VXJsLGIuX19wcm9jZXNzVW5pdFByZWZpeCxiLm1pZGRsZXdhcmVzLGIuX19wcm9jZXNzUmVxdWVzdF0pO21heFJldHJ5VGltZXM+MCYmKGkodixjLm1haW5Eb21haW4sYy5zdWJEb21haW4pLGkodyxjLm1haW5Eb21haW4sYy5zdWJEb21haW4pKSxhLnJldFR5cGU9dC5UT0tFTl9FWFBJUkVEfX0pOnZvaWQgYSgpfSxsLnByb3RvdHlwZS5fX3Byb2Nlc3NSZXF1ZXN0VXJsPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMucGFyYW1zLGM9dGhpcy5vcHRpb25zO2lmKGMuSDVSZXF1ZXN0PT09ITApe3ZhciBkPVwiLy9cIisoYy5wcmVmaXg/Yy5wcmVmaXgrXCIuXCI6XCJcIikrKGMuc3ViRG9tYWluP2Muc3ViRG9tYWluK1wiLlwiOlwiXCIpK2MubWFpbkRvbWFpbitcIi9oNS9cIitiLmFwaS50b0xvd2VyQ2FzZSgpK1wiL1wiK2Iudi50b0xvd2VyQ2FzZSgpK1wiL1wiLGU9Yi5hcHBLZXl8fChcIndhcHRlc3RcIj09PWMuc3ViRG9tYWluP1wiNDI3MlwiOlwiMTI1NzQ0NzhcIiksZj0obmV3IERhdGUpLmdldFRpbWUoKSxoPWcoYy50b2tlbitcIiZcIitmK1wiJlwiK2UrXCImXCIrYi5kYXRhKSxpPXthcHBLZXk6ZSx0OmYsc2lnbjpofSxqPXtkYXRhOmIuZGF0YSx1YTpiLnVhfTtPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe1widW5kZWZpbmVkXCI9PXR5cGVvZiBpW2FdJiZcInVuZGVmaW5lZFwiPT10eXBlb2YgalthXSYmKGlbYV09YlthXSl9KSxjLmdldEpTT05QP2kudHlwZT1cImpzb25wXCI6KGMuZ2V0SlNPTnx8Yy5wb3N0SlNPTikmJihpLnR5cGU9XCJvcmlnaW5hbGpzb25cIiksYy5xdWVyeXN0cmluZz1pLGMucG9zdGRhdGE9aixjLnBhdGg9ZH1hKCl9LGwucHJvdG90eXBlLl9fcHJvY2Vzc1VuaXRQcmVmaXg9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcy5wYXJhbXMsZD10aGlzLm9wdGlvbnM7aWYocCYmZC5INVJlcXVlc3Q9PT0hMCl7dmFyIGY9Yy5hcGksZz0hMSxpPWgoXCJfbV91c2VyX3VuaXRpbmZvX1wiKSxqPXAuZ2V0SXRlbShcInVuaXRpbmZvXCIpO2kmJmkuc3BsaXQoXCJ8XCIpWzBdLmluZGV4T2YoXCJjZW50ZXJcIik8MCYmaiYmai5pbmRleE9mKGYudG9Mb3dlckNhc2UoKSk+PTAmJihnPWkuc3BsaXQoXCJ8XCIpWzFdKSxnJiZkLnBhdGgmJihkLnBhdGg9ZC5wYXRoLnJlcGxhY2UoL15cXC9cXC8vLFwiLy9cIitnK1wiLlwiKSksYigpLnRoZW4oZnVuY3Rpb24oKXtpZihwKXt2YXIgYj1oKFwiX21fdW5pdGFwaV92X1wiKSxjPXAuZ2V0SXRlbShcInVuaXRpbmZvXCIpO2lmKGIpe3ZhciBmPWM/SlNPTi5wYXJzZShjKTp7fTtpZighY3x8YiE9PWYudmVyc2lvbil7dmFyIGc9ITEsaT1cIi8vaDUuXCIrZC5zdWJEb21haW4rXCIudGFvYmFvLmNvbS9qcy9tdG9wL3VuaXQvXCIrYitcIi91bml0QXBpLmpzXCIsaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2ouc3JjPWk7dmFyIGs9ZnVuY3Rpb24oKXtnfHwoZz0hMCxqLm9ubG9hZD1qLm9uZXJyb3I9bnVsbCxqLnBhcmVudE5vZGUmJmoucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChqKSl9O2oub25lcnJvcj1mdW5jdGlvbigpe2soKX0sYS5qc29ucF91bml0YXBpfHwoYS5qc29ucF91bml0YXBpPWZ1bmN0aW9uKGEpe2soKSxwLnNldEl0ZW0oXCJ1bml0aW5mb1wiLEpTT04uc3RyaW5naWZ5KGEpKX0pLGUoail9fX19KX1lbHNlIGIoKX07dmFyIHg9MDtsLnByb3RvdHlwZS5fX3JlcXVlc3RKU09OUD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe2lmKGsmJmNsZWFyVGltZW91dChrKSxsLnBhcmVudE5vZGUmJmwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsKSxcIlRJTUVPVVRcIj09PWEpd2luZG93W2pdPWZ1bmN0aW9uKCl7d2luZG93W2pdPXZvaWQgMDt0cnl7ZGVsZXRlIHdpbmRvd1tqXX1jYXRjaChhKXt9fTtlbHNle3dpbmRvd1tqXT12b2lkIDA7dHJ5e2RlbGV0ZSB3aW5kb3dbal19Y2F0Y2goYil7fX19dmFyIGQ9YygpLGc9dGhpcy5wYXJhbXMsaD10aGlzLm9wdGlvbnMsaT1nLnRpbWVvdXR8fDJlNCxqPVwibXRvcGpzb25wXCIrICsreCxrPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtiKFwiVElNRU9VVFwiKSxhKFwiVElNRU9VVDo65o6l5Y+j6LaF5pe2XCIpfSxpKTtoLnF1ZXJ5c3RyaW5nLmNhbGxiYWNrPWo7dmFyIGw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtyZXR1cm4gbC5zcmM9aC5wYXRoK1wiP1wiK2YoaC5xdWVyeXN0cmluZykrXCImXCIrZihoLnBvc3RkYXRhKSxsLmFzeW5jPSEwLGwub25lcnJvcj1mdW5jdGlvbigpe2IoXCJBQk9SVFwiKSxhKFwiQUJPUlQ6OuaOpeWPo+W8guW4uOmAgOWHulwiKX0sd2luZG93W2pdPWZ1bmN0aW9uKCl7aC5yZXN1bHRzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYigpLGQucmVzb2x2ZSgpfSxlKGwpLGQucHJvbWlzZX0sbC5wcm90b3R5cGUuX19yZXF1ZXN0SlNPTj1mdW5jdGlvbihiKXtmdW5jdGlvbiBkKGEpe2smJmNsZWFyVGltZW91dChrKSxcIlRJTUVPVVRcIj09PWEmJmkuYWJvcnQoKX12YXIgZT1jKCksZz10aGlzLnBhcmFtcyxoPXRoaXMub3B0aW9ucyxpPW5ldyBhLlhNTEh0dHBSZXF1ZXN0LGo9Zy50aW1lb3V0fHwyZTQsaz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZChcIlRJTUVPVVRcIiksYihcIlRJTUVPVVQ6OuaOpeWPo+i2heaXtlwiKX0saik7aS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZig0PT1pLnJlYWR5U3RhdGUpe3ZhciBhLGMsZj1pLnN0YXR1cztpZihmPj0yMDAmJjMwMD5mfHwzMDQ9PWYpe2QoKSxhPWkucmVzcG9uc2VUZXh0LGM9aS5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKXx8XCJcIjt0cnl7YT0vXlxccyokLy50ZXN0KGEpP3t9OkpTT04ucGFyc2UoYSksYS5yZXNwb25zZUhlYWRlcnM9YyxoLnJlc3VsdHM9W2FdLGUucmVzb2x2ZSgpfWNhdGNoKGcpe2IoXCJQQVJTRV9KU09OX0VSUk9SOjrop6PmnpBKU09O5aSx6LSlXCIpfX1lbHNlIGQoXCJBQk9SVFwiKSxiKFwiQUJPUlQ6OuaOpeWPo+W8guW4uOmAgOWHulwiKX19O3ZhciBsLG0sbj1oLnBhdGgrXCI/XCIrZihoLnF1ZXJ5c3RyaW5nKTtpZihoLmdldEpTT04/KGw9XCJHRVRcIixuKz1cIiZcIitmKGgucG9zdGRhdGEpKTpoLnBvc3RKU09OJiYobD1cIlBPU1RcIixtPWYoaC5wb3N0ZGF0YSkpLGkub3BlbihsLG4sITApLGkud2l0aENyZWRlbnRpYWxzPSEwLGkuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLFwiYXBwbGljYXRpb24vanNvblwiKSxpLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIixcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSxnLmhlYWRlcnMpZm9yKHZhciBvIGluIGcuaGVhZGVycylpLnNldFJlcXVlc3RIZWFkZXIobyxnLmhlYWRlcnNbb10pO3JldHVybiBpLnNlbmQobSksZS5wcm9taXNlfSxsLnByb3RvdHlwZS5fX3JlcXVlc3RXaW5kVmFuZT1mdW5jdGlvbihhKXtmdW5jdGlvbiBkKGEpe2oucmVzdWx0cz1bYV0saC5yZXNvbHZlKCl9dmFyIGUsZixnLGg9YygpLGk9dGhpcy5wYXJhbXMsaj10aGlzLm9wdGlvbnMsaz1pLmRhdGEsbD1pLmFwaSxtPWkudixuPWoucG9zdEpTT04/MTowLG89ai5nZXRKU09OfHxqLnBvc3RKU09OP1wib3JnaW5hbGpzb25cIjpcIlwiLHA9XCJodHRwc1wiPT09bG9jYXRpb24ucHJvdG9jb2w/MTowLHE9aS5pc1NlY3x8MCxyPWkuc2Vzc2lvbk9wdGlvbnx8XCJBdXRvTG9naW5Pbmx5XCI7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGkuZWNvZGUpdGhyb3cgbmV3IEVycm9yKFwiVU5FWENFUFRfUEFSQU1fRUNPREU6Oue8uuWwkWVjb2Rl5Y+C5pWwXCIpO3JldHVybiBlPXBhcnNlSW50KGkuZWNvZGUpLGc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGkudGltZXI/cGFyc2VJbnQoaS50aW1lcik6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGkudGltZW91dD9wYXJzZUludChpLnRpbWVvdXQpOjJlNCxmPTIqZyxiLndpbmR2YW5lLmNhbGwoXCJNdG9wV1ZQbHVnaW5cIixcInNlbmRcIix7YXBpOmwsdjptLHBvc3Q6U3RyaW5nKG4pLHR5cGU6byxpc0h0dHBzOlN0cmluZyhwKSxlY29kZTpTdHJpbmcoZSksaXNTZWM6U3RyaW5nKHEpLHBhcmFtOkpTT04ucGFyc2UoayksdGltZXI6ZyxzZXNzaW9uT3B0aW9uOnJ9LGQsZCxmKSxoLnByb21pc2V9LGwucHJvdG90eXBlLl9fcHJvY2Vzc1JlcXVlc3Q9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO3JldHVybiBvLnRoZW4oZnVuY3Rpb24oKXt2YXIgYT1jLm9wdGlvbnM7aWYoYS5INVJlcXVlc3QmJmEuZ2V0SlNPTlApcmV0dXJuIGMuX19yZXF1ZXN0SlNPTlAoYik7aWYoYS5INVJlcXVlc3QmJihhLmdldEpTT058fGEucG9zdEpTT04pKXJldHVybiBjLl9fcmVxdWVzdEpTT04oYik7aWYoYS5XaW5kVmFuZVJlcXVlc3QpcmV0dXJuIGMuX19yZXF1ZXN0V2luZFZhbmUoYik7dGhyb3cgbmV3IEVycm9yKFwiVU5FWENFUFRfUkVRVUVTVDo66ZSZ6K+v55qE6K+35rGC57G75Z6LXCIpfSkudGhlbihhKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGE9Yy5vcHRpb25zLGI9KGMucGFyYW1zLGEucmVzdWx0c1swXSksZD1iJiZiLnJldHx8W107Yi5yZXQ9ZCxkIGluc3RhbmNlb2YgQXJyYXkmJihkPWQuam9pbihcIixcIikpLGQuaW5kZXhPZihcIlNVQ0NFU1NcIik+LTE/Yi5yZXRUeXBlPXQuU1VDQ0VTUzpiLnJldFR5cGU9dC5FUlJPUixhLnJldEpzb249Yn0pfSxsLnByb3RvdHlwZS5fX3NlcXVlbmNlPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7aWYoYSBpbnN0YW5jZW9mIEFycmF5KWEuZm9yRWFjaChiKTtlbHNle3ZhciBnLGg9YygpLGk9YygpO2UucHVzaChmdW5jdGlvbigpe3JldHVybiBoPWMoKSxnPWEuY2FsbChkLGZ1bmN0aW9uKGEpe3JldHVybiBoLnJlc29sdmUoYSksaS5wcm9taXNlfSxmdW5jdGlvbihhKXtyZXR1cm4gaC5yZWplY3QoYSksaS5wcm9taXNlfSksZyYmKGc9Z1tcImNhdGNoXCJdKGZ1bmN0aW9uKGEpe2gucmVqZWN0KGEpfSkpLGgucHJvbWlzZX0pLGYucHVzaChmdW5jdGlvbihhKXtyZXR1cm4gaS5yZXNvbHZlKGEpLGd9KX19dmFyIGQ9dGhpcyxlPVtdLGY9W107YS5mb3JFYWNoKGIpO2Zvcih2YXIgZyxoPW87Zz1lLnNoaWZ0KCk7KWg9aC50aGVuKGcpO2Zvcig7Zz1mLnBvcCgpOyloPWgudGhlbihnKTtyZXR1cm4gaH07dmFyIHk9ZnVuY3Rpb24oYSl7YSgpfSx6PWZ1bmN0aW9uKGEpe2EoKX07bC5wcm90b3R5cGUucmVxdWVzdD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3RoaXMub3B0aW9ucz1kKGF8fHt9LHIpO3ZhciBjPW0ucmVzb2x2ZShbeSx6XSkudGhlbihmdW5jdGlvbihhKXt2YXIgYz1hWzBdLGQ9YVsxXTtyZXR1cm4gYi5fX3NlcXVlbmNlKFtjLGIuX19wcm9jZXNzUmVxdWVzdE1ldGhvZCxiLl9fcHJvY2Vzc1JlcXVlc3RUeXBlLGIuX19wcm9jZXNzVG9rZW4sYi5fX3Byb2Nlc3NSZXF1ZXN0VXJsLGIuX19wcm9jZXNzVW5pdFByZWZpeCxiLm1pZGRsZXdhcmVzLGIuX19wcm9jZXNzUmVxdWVzdCxkXSl9KS50aGVuKGZ1bmN0aW9uKCl7dmFyIGE9Yi5vcHRpb25zLnJldEpzb247cmV0dXJuIGEucmV0VHlwZSE9PXQuU1VDQ0VTUz9tLnJlamVjdChhKTpiLm9wdGlvbnMuc3VjY2Vzc0NhbGxiYWNrP3ZvaWQgYi5vcHRpb25zLnN1Y2Nlc3NDYWxsYmFjayhhKTptLnJlc29sdmUoYSl9KVtcImNhdGNoXCJdKGZ1bmN0aW9uKGEpe3ZhciBjO3JldHVybiBhIGluc3RhbmNlb2YgRXJyb3I/KGNvbnNvbGUuZXJyb3IoYS5zdGFjayksYz17cmV0OlthLm1lc3NhZ2VdLHN0YWNrOlthLnN0YWNrXSxyZXRKc29uOnQuRVJST1J9KTpjPVwic3RyaW5nXCI9PXR5cGVvZiBhP3tyZXQ6W2FdLHJldEpzb246dC5FUlJPUn06dm9pZCAwIT09YT9hOmIub3B0aW9ucy5yZXRKc29uLGIub3B0aW9ucy5mYWlsdXJlQ2FsbGJhY2s/dm9pZCBiLm9wdGlvbnMuZmFpbHVyZUNhbGxiYWNrKGMpOm0ucmVqZWN0KGMpfSk7cmV0dXJuIHk9ZnVuY3Rpb24oYSl7Yy50aGVuKGEpW1wiY2F0Y2hcIl0oYSl9LGN9LGIubXRvcD1mdW5jdGlvbihhKXtyZXR1cm4gbmV3IGwoYSl9LGIubXRvcC5yZXF1ZXN0PWZ1bmN0aW9uKGEsYixjKXt2YXIgZD17SDVSZXF1ZXN0OmEuSDVSZXF1ZXN0LFdpbmRWYW5lUmVxdWVzdDphLldpbmRWYW5lUmVxdWVzdCxMb2dpblJlcXVlc3Q6YS5Mb2dpblJlcXVlc3QsQW50aUNyZWVwOmEuQW50aUNyZWVwLEFudGlGbG9vZDphLkFudGlGbG9vZCxzdWNjZXNzQ2FsbGJhY2s6YixmYWlsdXJlQ2FsbGJhY2s6Y3x8Yn07cmV0dXJuIG5ldyBsKGEpLnJlcXVlc3QoZCl9LGIubXRvcC5INVJlcXVlc3Q9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPXtINVJlcXVlc3Q6ITAsc3VjY2Vzc0NhbGxiYWNrOmIsZmFpbHVyZUNhbGxiYWNrOmN8fGJ9O3JldHVybiBuZXcgbChhKS5yZXF1ZXN0KGQpfSxiLm10b3AubWlkZGxld2FyZXM9cyxiLm10b3AuY29uZmlnPXIsYi5tdG9wLlJFU1BPTlNFX1RZUEU9dCxiLm10b3AuQ0xBU1M9bH0od2luZG93LHdpbmRvdy5saWJ8fCh3aW5kb3cubGliPXt9KSksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBhLnByZXZlbnREZWZhdWx0KCksITF9ZnVuY3Rpb24gZChiLGQpe3ZhciBlPXRoaXMsZj1hLmRwcnx8MSxnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksaD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksaT1NYXRoLm1heChoLndpZHRoLHdpbmRvdy5pbm5lcldpZHRoKS9mLGo9TWF0aC5tYXgoaC5oZWlnaHQsd2luZG93LmlubmVySGVpZ2h0KS9mO2cuc3R5bGUuY3NzVGV4dD1bXCItd2Via2l0LXRyYW5zZm9ybTpzY2FsZShcIitmK1wiKSB0cmFuc2xhdGVaKDApXCIsXCItbXMtdHJhbnNmb3JtOnNjYWxlKFwiK2YrXCIpIHRyYW5zbGF0ZVooMClcIixcInRyYW5zZm9ybTpzY2FsZShcIitmK1wiKSB0cmFuc2xhdGVaKDApXCIsXCItd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46MCAwXCIsXCItbXMtdHJhbnNmb3JtLW9yaWdpbjowIDBcIixcInRyYW5zZm9ybS1vcmlnaW46MCAwXCIsXCJ3aWR0aDpcIitpK1wicHhcIixcImhlaWdodDpcIitqK1wicHhcIixcInotaW5kZXg6OTk5OTk5XCIsXCJwb3NpdGlvbjphYnNvbHV0ZVwiLFwibGVmdDowXCIsXCJ0b3A6MHB4XCIsXCJiYWNrZ3JvdW5kOiNGRkZcIixcImRpc3BsYXk6bm9uZVwiXS5qb2luKFwiO1wiKTt2YXIgaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2suc3R5bGUuY3NzVGV4dD1bXCJ3aWR0aDoxMDAlXCIsXCJoZWlnaHQ6NTJweFwiLFwiYmFja2dyb3VuZDojRUVFXCIsXCJsaW5lLWhlaWdodDo1MnB4XCIsXCJ0ZXh0LWFsaWduOmxlZnRcIixcImJveC1zaXppbmc6Ym9yZGVyLWJveFwiLFwicGFkZGluZy1sZWZ0OjIwcHhcIixcInBvc2l0aW9uOmFic29sdXRlXCIsXCJsZWZ0OjBcIixcInRvcDowXCIsXCJmb250LXNpemU6MTZweFwiLFwiZm9udC13ZWlnaHQ6Ym9sZFwiLFwiY29sb3I6IzMzM1wiXS5qb2luKFwiO1wiKSxrLmlubmVyVGV4dD1iO3ZhciBsPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO2wuc3R5bGUuY3NzVGV4dD1bXCJkaXNwbGF5OmJsb2NrXCIsXCJwb3NpdGlvbjphYnNvbHV0ZVwiLFwicmlnaHQ6MFwiLFwidG9wOjBcIixcImhlaWdodDo1MnB4XCIsXCJsaW5lLWhlaWdodDo1MnB4XCIsXCJwYWRkaW5nOjAgMjBweFwiLFwiY29sb3I6Izk5OVwiXS5qb2luKFwiO1wiKSxsLmlubmVyVGV4dD1cIuWFs+mXrVwiO3ZhciBtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7bS5zdHlsZS5jc3NUZXh0PVtcIndpZHRoOjEwMCVcIixcImhlaWdodDoxMDAlXCIsXCJib3JkZXI6MFwiLFwib3ZlcmZsb3c6aGlkZGVuXCJdLmpvaW4oXCI7XCIpLGsuYXBwZW5kQ2hpbGQobCksZy5hcHBlbmRDaGlsZChrKSxnLmFwcGVuZENoaWxkKG0pLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZyksbS5zcmM9ZCxsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLGZ1bmN0aW9uKCl7ZS5oaWRlKCk7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpO2EuaW5pdEV2ZW50KFwiY2xvc2VcIiwhMSwhMSksZy5kaXNwYXRjaEV2ZW50KGEpfSwhMSksdGhpcy5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKCl7Zy5hZGRFdmVudExpc3RlbmVyLmFwcGx5KGcsYXJndW1lbnRzKX0sdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKCl7Zy5yZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KGcsYXJndW1lbnRzKX0sdGhpcy5zaG93PWZ1bmN0aW9uKCl7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLGMsITEpLGcuc3R5bGUuZGlzcGxheT1cImJsb2NrXCIsd2luZG93LnNjcm9sbFRvKDAsMCl9LHRoaXMuaGlkZT1mdW5jdGlvbigpe2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIixjKSx3aW5kb3cuc2Nyb2xsVG8oMCwtaC50b3ApLGcucGFyZW50Tm9kZSYmZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGcpfX1mdW5jdGlvbiBlKGEpe3t2YXIgYz10aGlzLGQ9dGhpcy5vcHRpb25zO3RoaXMucGFyYW1zfXJldHVybiBhKCkudGhlbihmdW5jdGlvbigpe3ZhciBhPWQucmV0SnNvbixlPWEucmV0O2lmKGUgaW5zdGFuY2VvZiBBcnJheSYmKGU9ZS5qb2luKFwiLFwiKSksKGUuaW5kZXhPZihcIlNFU1NJT05fRVhQSVJFRFwiKT4tMXx8ZS5pbmRleE9mKFwiU0lEX0lOVkFMSURcIik+LTF8fGUuaW5kZXhPZihcIkFVVEhfUkVKRUNUXCIpPi0xfHxlLmluZGV4T2YoXCJORUVEX0xPR0lOXCIpPi0xKSYmKGEucmV0VHlwZT1rLlNFU1NJT05fRVhQSVJFRCwhZC5XaW5kVmFuZVJlcXVlc3QmJihqLkxvZ2luUmVxdWVzdD09PSEwfHxkLkxvZ2luUmVxdWVzdD09PSEwKSkpe2lmKCFiLmxvZ2luKXRocm93IG5ldyBFcnJvcihcIkxPR0lOX05PVF9GT1VORDo657y65bCRbGliLmxvZ2luXCIpO3JldHVybiBiLmxvZ2luLmdvTG9naW5Bc3luYygpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGMuX19zZXF1ZW5jZShbYy5fX3Byb2Nlc3NUb2tlbixjLl9fcHJvY2Vzc1JlcXVlc3RVcmwsYy5fX3Byb2Nlc3NVbml0UHJlZml4LGMubWlkZGxld2FyZXMsYy5fX3Byb2Nlc3NSZXF1ZXN0XSl9KVtcImNhdGNoXCJdKGZ1bmN0aW9uKGEpe3Rocm93IG5ldyBFcnJvcihcIkNBTkNFTFwiPT09YT9cIkxPR0lOX0NBTkNFTDo655So5oi35Y+W5raI55m75b2VXCI6XCJMT0dJTl9GQUlMVVJFOjrnlKjmiLfnmbvlvZXlpLHotKVcIil9KX19KX1mdW5jdGlvbiBmKGEpe3t2YXIgYj10aGlzLm9wdGlvbnM7dGhpcy5wYXJhbXN9cmV0dXJuIGIuQWxpQXBwTmFtZXx8Yi5BbGlBcHBWZXJzaW9ufHxqLkFudGlGbG9vZCE9PSEwJiZiLkFudGlGbG9vZCE9PSEwP3ZvaWQgYSgpOmEoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGE9Yi5yZXRKc29uLGM9YS5yZXQ7YyBpbnN0YW5jZW9mIEFycmF5JiYoYz1jLmpvaW4oXCIsXCIpKSxjLmluZGV4T2YoXCJGQUlMX1NZU19VU0VSX1ZBTElEQVRFXCIpPi0xJiZhLmRhdGEudXJsJiYobG9jYXRpb24uaHJlZj1hLmRhdGEudXJsKX0pfWZ1bmN0aW9uIGcoYil7dmFyIGM9dGhpcyxlPXRoaXMub3B0aW9ucyxmPXRoaXMucGFyYW1zO3JldHVybiBlLkFsaUFwcE5hbWV8fGUuQWxpQXBwVmVyc2lvbnx8ai5BbnRpQ3JlZXAhPT0hMCYmZS5BbnRpQ3JlZXAhPT0hMD92b2lkIGIoKTpiKCkudGhlbihmdW5jdGlvbigpe3ZhciBiPWUucmV0SnNvbixnPWIucmV0O3JldHVybiBnIGluc3RhbmNlb2YgQXJyYXkmJihnPWcuam9pbihcIixcIikpLGcuaW5kZXhPZihcIlJHVjU4N19FUlJPUjo6U01cIik+LTEmJmIuZGF0YS51cmw/bmV3IGgoZnVuY3Rpb24oZSxnKXtmdW5jdGlvbiBoKCl7ay5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xvc2VcIixoKSxhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsaSksZyhcIlVTRVJfSU5QVVRfQ0FOQ0VMOjrnlKjmiLflj5bmtojovpPlhaVcIil9ZnVuY3Rpb24gaShiKXtrLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLGgpLGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixpKSxrLmhpZGUoKTt2YXIgZDt0cnl7ZD1KU09OLnBhcnNlKGIuZGF0YSl8fHt9fWNhdGNoKGope31pZihkJiZcImNoaWxkXCI9PT1kLnR5cGUpe3ZhciBsO3RyeXtsPUpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KGQuY29udGVudCkpLFwic3RyaW5nXCI9PXR5cGVvZiBsJiYobD1KU09OLnBhcnNlKGwpKTtmb3IodmFyIG0gaW4gbClmW21dPWxbbV07Yy5fX3NlcXVlbmNlKFtjLl9fcHJvY2Vzc1Rva2VuLGMuX19wcm9jZXNzUmVxdWVzdFVybCxjLl9fcHJvY2Vzc1VuaXRQcmVmaXgsYy5taWRkbGV3YXJlcyxjLl9fcHJvY2Vzc1JlcXVlc3RdKS50aGVuKGUpfWNhdGNoKGope2coXCJVU0VSX0lOUFVUX0ZBSUxVUkU6OueUqOaIt+i+k+WFpeWksei0pVwiKX19ZWxzZSBlKCl9dmFyIGo9Yi5kYXRhLnVybCxrPW5ldyBkKFwiXCIsaik7ay5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIixpLCExKSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsaSwhMSksay5zaG93KCl9KTp2b2lkIDB9KX12YXIgaD1hLlByb21pc2UsaT1iLm10b3AuQ0xBU1Msaj1iLm10b3AuY29uZmlnLGs9Yi5tdG9wLlJFU1BPTlNFX1RZUEU7Yi5tdG9wLm1pZGRsZXdhcmVzLnB1c2goZSksYi5tdG9wLmxvZ2luUmVxdWVzdD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9e0xvZ2luUmVxdWVzdDohMCxINVJlcXVlc3Q6ITAsc3VjY2Vzc0NhbGxiYWNrOmIsZmFpbHVyZUNhbGxiYWNrOmN8fGJ9O3JldHVybiBuZXcgaShhKS5yZXF1ZXN0KGQpfSxiLm10b3AuYW50aUZsb29kUmVxdWVzdD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9e0FudGlGbG9vZDohMCxzdWNjZXNzQ2FsbGJhY2s6YixmYWlsdXJlQ2FsbGJhY2s6Y3x8Yn07cmV0dXJuIG5ldyBpKGEpLnJlcXVlc3QoZCl9LGIubXRvcC5taWRkbGV3YXJlcy5wdXNoKGYpLGIubXRvcC5hbnRpQ3JlZXBSZXF1ZXN0PWZ1bmN0aW9uKGEsYixjKXt2YXIgZD17QW50aUNyZWVwOiEwLHN1Y2Nlc3NDYWxsYmFjazpiLGZhaWx1cmVDYWxsYmFjazpjfHxifTtyZXR1cm4gbmV3IGkoYSkucmVxdWVzdChkKX0sYi5tdG9wLm1pZGRsZXdhcmVzLnB1c2goZyl9KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpOzttb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5saWIubXRvcDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYWxpL2xpYi1tdG9wL2J1aWxkL210b3AuY29tbW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG4vLyByZXF1aXJlKCdlbnZkJylcbnJlcXVpcmUoJ0BhbGkvbGliLXdpbmR2YW5lJylcbnJlcXVpcmUoJ0BhbGkvbGliLWxvZ2luJylcbnJlcXVpcmUoJ0BhbGkvbGliLW10b3AnKVxuXG52YXIgdXNlciA9IHtcbiAgLyoqXG4gICAqIGdldCBjdXJyZW50IHVzZXIgaW5mby5cbiAgICogICByZXNwb25zZSBmb3JtYXQ6IHsnaXNMb2dpbic6J3RydWUnLCd1c2VySWQnOid1c2VyaWQnLCduaWNrJzonamIn772dXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2FsbGxiYWNrSWRcbiAgICovXG4gIGdldFVzZXJJbmZvOiBmdW5jdGlvbiAoY2FsbGJhY2tJZCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBwZXJmb3JtQ2IgPSBmdW5jdGlvbiAoaXNMb2dpbiwgaW5mbykge1xuICAgICAgc2VsZi5zZW5kZXIucGVyZm9ybUNhbGxiYWNrKGNhbGxiYWNrSWQsIHtcbiAgICAgICAgaXNMb2dpbjogaXNMb2dpbiArICcnLFxuICAgICAgICB1c2VySWQ6IGluZm8udXNlck51bUlkLFxuICAgICAgICBuaWNrOiBpbmZvLm5pY2tcbiAgICAgIH0pXG4gICAgfVxuICAgIGxpYi5sb2dpbi5pc0xvZ2luQXN5bmMoZnVuY3Rpb24gKHJlcywgaW5mbykge1xuICAgICAgdmFyIGRhdGEgPSBpbmZvID8gaW5mby5kYXRhIHx8IHt9IDoge31cbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgcGVyZm9ybUNiKHRydWUsIGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJmb3JtQ2IoZmFsc2UsIGRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxsYmFja+i/lOWbnuWPguaVsO+8mnN0YXR1c++8mnN0cmluZ++8m2luZm/vvJpqc29uTWFwXG4gICAqIOWPguaVsOWAvO+8mueZu+W9leeKtuaAgVN1Y2Nlc3PjgIFmYWlsdXJlIOeUqOaIt+S/oeaBr++9myd1c2VyaWQnOid1c2VySWQnLCduaWNrJzonamIn772dXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY2FsbGJhY2tcbiAgICovXG4gIGxvZ2luOiBmdW5jdGlvbiAoY2FsbGJhY2tJZCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIGxpYi5sb2dpbi5nb0xvZ2luQXN5bmMoKS50aGVuKGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgIHZhciBwZXJmb3JtQ2IgPSBmdW5jdGlvbiAoc3RhdHVzLCBpbmZvKSB7XG4gICAgICAgIHNlbGYuc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgaW5mbzogaW5mb1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYgKChzdGF0dXMgKyAnJykubWF0Y2goL3N1Y2Nlc3MvaSkpIHtcbiAgICAgICAgbGliLmxvZ2luLmlzTG9naW5Bc3luYyhmdW5jdGlvbiAocmVzLCBpbmZvKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBpbmZvID8gaW5mby5kYXRhIHx8IHt9IDogaW5mb1xuICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIHBlcmZvcm1DYignc3VjY2VzcycsIHsgdXNlcmlkOiBkYXRhLnVzZXJOdW1JZCwgbmljazogZGF0YS5uaWNrIH0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1DYignZmFpbHVyZScpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyZm9ybUNiKCdmYWlsdXJlJylcbiAgICAgIH1cbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgIH0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIGxvZ291dCAocmVzcG9uc2U6IHsgc3RhdHVz77yac3RyaW5nIH0pXG4gICAqIOWPguaVsOWAvHN1Y2Nlc3PjgIFmYWlsdXJlXG4gICAqL1xuICBsb2dvdXQ6IGZ1bmN0aW9uIChjYWxsYmFja0lkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgbGliLmxvZ2luLmdvTG9nb3V0QXN5bmMoZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgaWYgKChzdGF0dXMgKyAnJykubWF0Y2goL3N1Y2Nlc3MvaSkpIHtcbiAgICAgICAgc3RhdHVzID0gJ3N1Y2Nlc3MnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXMgPSAnZmFpbHVyZSdcbiAgICAgIH1cbiAgICAgIHNlbGYuc2VuZGVyLnBlcmZvcm1DYWxsYmFjayhjYWxsYmFja0lkLCB7XG4gICAgICAgIHN0YXR1czogc3RhdHVzXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxufVxuXG51c2VyLl9tZXRhID0ge1xuICB1c2VyOiBbe1xuICAgIG5hbWU6ICdnZXRVc2VySW5mbycsXG4gICAgYXJnczogWydmdW5jdGlvbiddXG4gIH0sIHtcbiAgICBuYW1lOiAnbG9naW4nLFxuICAgIGFyZ3M6IFsnZnVuY3Rpb24nXVxuICB9LCB7XG4gICAgbmFtZTogJ2xvZ291dCcsXG4gICAgYXJnczogWydmdW5jdGlvbiddXG4gIH1dXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXNlclxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXBpL3VzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIHJlZjogJ2h0dHA6Ly9naXRsYWIuYWxpYmFiYS1pbmMuY29tL2FwbHVzL2FwbHVzX3RlY2huaWNhbF9tYW51YWwnXG4vLyArICcvcmF3L21hc3Rlci9fYm9vay9hcGx1cy9jZG4uaHRtbCdcbnZhciB1c2VyVHJhY2sgPSB7XG4gIC8qKlxuICAgKiBjb21taXQg5Z+L54K5XG4gICAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSDln4vngrnnsbvlnos6IGVudGVyLCBjbGljaywgZXhwb3NlLCB1cGRhdGVOZXh0UHJvcFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUg6aG16Z2i5ZCN56ewXG4gICAqIEBwYXJhbSAge3N0cmluZ30gY3RybE5hbWUg5o6n5Lu25ZCN56ewOiDku6V1dOWumuS5ieeahOexu+Wei+S4uuagh+WHhiBCdXR0b24gVGV4dCBJbWFnZVxuICAgKiBAcGFyYW0gIHtvYmp9IHBhcmFtIOmhtemdouWPguaVsCjnm5HmjqflubPlj7DmmL7npLopXG4gICAqL1xuICBjb21taXQ6IGZ1bmN0aW9uICh0eXBlLCBwYWdlTmFtZSwgY3RybE5hbWUsIHBhcmFtKSB7XG4gICAgLy8g5aSE55CGIHBhcmFtc1xuICAgIHZhciBnb2tleSA9ICcnXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXJhbSkuc2xpY2UoOCwgLTEpID09PSAnT2JqZWN0Jykge1xuICAgICAgZ29rZXkgPSBPYmplY3Qua2V5cyhwYXJhbSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGl0ZW0sIGluZGV4LCBhcnJheSkge1xuICAgICAgICB2YXIga2V5ID0gaXRlbVxuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQucGFyYW1baXRlbV1cbiAgICAgICAgcmVzdWx0LnJlc3VsdC5wdXNoKGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSwgeyBwYXJhbTogcGFyYW0sIHJlc3VsdDogW10gfSlcbiAgICAgIGdva2V5ID0gZ29rZXkucmVzdWx0LmpvaW4oJyYnKVxuICAgIH1cblxuICAgIC8vIOacieWPr+iDvemhtemdouayoeaciSBnb2xkbG9nIOaWueazle+8jOmcgOimgSB0cnlcbiAgICB0cnkge1xuICAgICAgLy8gZW50ZXIgMjAwMVxuICAgICAgaWYgKHR5cGUgPT09ICdlbnRlcicpIHtcbiAgICAgICAgLy8g5aaC5p6c5pivIDIwMDEg5LqL5Lu277yM6ZyA6KaB5Yik5pat5piv5ZCm5pyJIHdhaXRpbmcg5qCH6K+G77yM5aaC5p6c5rKh5pyJ55qE6K+dIHNwbS5qcyDlt7Lnu4/lj5Hlh7rkuoYgMjAwMe+8jOS4jeW6lOivpeWGjeWPkVxuICAgICAgICB2YXIgbWV0YSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImFwbHVzLXdhaXRpbmdcIl0nKVxuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgIGdvbGRsb2cubGF1bmNoKHBhcmFtcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8g54K55Ye75Z+L54K5XG4gICAgICAvLyBlbHNlIGlmICh0eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAvLyAgLy8gVE9ET1xuICAgICAgLy8gIC8vZ29sZGxvZy5yZWNvcmQoYXBwbmFtZSwgXCJcIiwgZ29rZXksIFwiXCIpXG4gICAgICAvLyB9XG4gICAgICAvLyAvLyDmm53lhYnln4vngrlcbiAgICAgIC8vIGVsc2UgaWYgKHR5cGUgPT09ICdleHBvc2UnKSB7XG4gICAgICAvLyAgLy8gVE9ET1xuICAgICAgLy8gIC8vZ29sZGxvZy5yZWNvcmQoYXBwbmFtZSwgXCJcIiwgZ29rZXksIFwiXCIpXG4gICAgICAvLyB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICB9XG4gIH1cbn1cblxudXNlclRyYWNrLl9tZXRhID0ge1xuICB1c2VyVHJhY2s6IFt7XG4gICAgbmFtZTogJ2NvbW1pdCcsXG4gICAgYXJnczogWydzdHJpbmcnLCAnc3RyaW5nJywgJ3N0cmluZycsICdvYmplY3QnXVxuICB9XVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZXJUcmFja1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXBpL3VzZXJUcmFjay5qc1xuICoqIG1vZHVsZSBpZCA9IDEzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIHdpbmR2YW5lID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtvYmp9IGNvbmZpZ1xuICAgKiAgICAgICAgIGNsYXNzXG4gICAqICAgICAgICAgbWV0aG9kXG4gICAqICAgICAgICAgZGF0YVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGNhbGxiYWNrSWQgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgY2FsbDogZnVuY3Rpb24gKGNvbmZpZywgY2FsbGJhY2tJZCkge1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgICB2YXIgY2IgPSBmdW5jdGlvbiAocmVzcCkge1xuXG4gICAgICBzZWxmLnNlbmRlci5wZXJmb3JtQ2FsbGJhY2soY2FsbGJhY2tJZCwgcmVzcClcblxuICAgIH1cblxuICAgIGlmIChsaWIud2luZHZhbmUpIHtcblxuICAgICAgbGliLndpbmR2YW5lLmNhbGwoY29uZmlnLmNsYXNzLCBjb25maWcubWV0aG9kLCBjb25maWcuZGF0YSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgIGNiKHJlcylcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCd3aW5kdmFuZSBjYWxsIGVycm9yOiAnLCBlcnIpXG4gICAgICAgICAgY2IoZXJyKVxuICAgICAgICB9KVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2xpYi53aW5kdmFuZSBub3QgZm91bmQuJylcbiAgICB9XG4gIH1cbn1cblxud2luZHZhbmUuX21ldGEgPSB7XG4gIHdpbmR2YW5lOiBbe1xuICAgIG5hbWU6ICdjYWxsJyxcbiAgICBhcmdzOiBbJ29iamVjdCcsICdmdW5jdGlvbiddXG4gIH1dXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luZHZhbmVcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvYXBpL3dpbmR2YW5lLmpzXG4gKiogbW9kdWxlIGlkID0gMTQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsInZhciBJbWFnZSA9IHJlcXVpcmUoJy4vaW1hZ2UnKVxudmFyIFNsaWRlciA9IHJlcXVpcmUoJy4vc2xpZGVyJylcblxudmFyIGNvbXBvbmVudHMgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIChXZWV4KSB7XG4gICAgV2VleC5yZWdpc3RlckNvbXBvbmVudCgnaW1hZ2UnLCBJbWFnZSlcbiAgICBXZWV4LnJlZ2lzdGVyQ29tcG9uZW50KCdzbGlkZXInLCBTbGlkZXIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb25lbnRzXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9jb21wb25lbnRzL2luZGV4LmpzXG4gKiogbW9kdWxlIGlkID0gMTQxXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgd2VleCA9IHJlcXVpcmUoJ3dlZXgtaHRtbDUnKVxudmFyIENvbXBvbmVudCA9IHdlZXguQ29tcG9uZW50XG52YXIgTGF6eUxvYWQgPSByZXF1aXJlKCcuLi9sYXp5TG9hZCcpXG5cbnJlcXVpcmUoJy4uL3N0eWxlcy9pbWFnZS5jc3MnKVxuXG52YXIgREVGQVVMVF9TSVpFID0gMjAwXG52YXIgUkVTSVpFX01PREVTID0gWydzdHJldGNoJywgJ2NvdmVyJywgJ2NvbnRhaW4nXVxudmFyIERFRkFVTFRfUkVTSVpFX01PREUgPSAnc3RyZXRjaCdcblxudmFyIFFVQUxJVElFUyA9IHtcbiAgbG93OiBbXG4gICAge1xuICAgICAgbmFtZTogJ2RhdGEtcS1ub3JtYWwnLFxuICAgICAgdmFsdWU6ICdxNTAnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2RhdGEtcS13ZWFrJyxcbiAgICAgIHZhbHVlOiAncTUwJ1xuICAgIH1cbiAgXSxcbiAgbm9ybWFsOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2RhdGEtcS1ub3JtYWwnLFxuICAgICAgdmFsdWU6ICdxNzUnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2RhdGEtcS13ZWFrJyxcbiAgICAgIHZhbHVlOiAncTUwJ1xuICAgIH1cbiAgXSxcbiAgaGlnaDogW1xuICAgIHtcbiAgICAgIG5hbWU6ICdkYXRhLXEtbm9ybWFsJyxcbiAgICAgIHZhbHVlOiAncTkwJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdkYXRhLXEtd2VhaycsXG4gICAgICB2YWx1ZTogJ3E3NSdcbiAgICB9XG4gIF0sXG4gIG9yaWdpbmFsOiBbXG4gICAge1xuICAgICAgbmFtZTogJ2RhdGEtcS1ub3JtYWwnLFxuICAgICAgdmFsdWU6ICdvcmlnaW5hbCdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZGF0YS1xLXdlYWsnLFxuICAgICAgdmFsdWU6ICdvcmlnaW5hbCdcbiAgICB9XG4gIF1cbn1cbnZhciBTSEFQUkVOID0ge1xuICBzaGFycGVuOiAnczE1MCcsXG4gIHVuc2hhcnBlbjogJ29yaWdpbmFsJ1xufVxuXG4vKipcbiAqIHJlc2l6ZT1jb3Zlcnxjb250YWlufHN0cmV0Y2ggZGVmYXVsdDpzdHJldGNoXG4gKiBzcmM9dXJsXG4gKiBxdWFsaXR5PW5vcm1hbChxNzUpfGxvdyhxNTApfGhpZ2gocTkwKXxvcmlnaW4gZGVmYXVsdDpsb3dcbiAqIHNoYXJwZW49dW5zaGFycGVufHNoYXJwZW4oczE1MCkgZGVmYXVsdDp1bnNoYXJwZW5cbiAqL1xuZnVuY3Rpb24gSW1hZ2UgKGRhdGEpIHtcbiAgdmFyIHF1YWxpdHksIHNoYXJwZW4sIG9yaWdpblxuICB2YXIgYXR0ciA9IGRhdGEuYXR0clxuICBpZiAoYXR0cikge1xuICAgIHF1YWxpdHkgPSBhdHRyLnF1YWxpdHkgfHwgYXR0ci5pbWFnZVF1YWxpdHlcbiAgICBzaGFycGVuID0gYXR0ci5zaGFycGVuIHx8IGF0dHIuaW1hZ2VTaGFycGVuXG4gICAgb3JpZ2luID0gYXR0ci5vcmlnaW4gfHwgYXR0ci5kYXRhT3JpZ2luXG4gIH1cbiAgdGhpcy5xdWFsaXR5ID0gUVVBTElUSUVTW3F1YWxpdHldXG4gIHRoaXMuc2hhcnBlbiA9IFNIQVBSRU5bc2hhcnBlbl1cbiAgdGhpcy5vcmlnaW4gPSBvcmlnaW4gJiYgb3JpZ2luICE9PSAnZmFsc2UnID8gdHJ1ZSA6IGZhbHNlXG4gIENvbXBvbmVudC5jYWxsKHRoaXMsIGRhdGEpXG59XG5cbkltYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSlcblxuSW1hZ2UucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBub2RlLmNsYXNzTGlzdC5hZGQoJ3dlZXgtaW1nJylcbiAgLy8gaWYgJ3F1YWxpdHknLydzaGFycGVuJyBpcyBub3Qgc3BlY2lmaWVkIGl0IHdpbGxcbiAgLy8gdXNlIGRlZmF1bHQgY29uZmlnIG9mIGxpYi5pbWcgd2hpY2ggaXMgc2V0IGluIGxhenlsb2FkLmpzXG4gIGlmICh0aGlzLnF1YWxpdHkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMucXVhbGl0eS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gdGhpcy5xdWFsaXR5W2ldXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpXG4gICAgfVxuICB9XG4gIGlmICh0aGlzLnNoYXJwZW4pIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1zaGFycGVuJywgdGhpcy5zaGFycGVuKVxuICB9XG4gIG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsJywgdGhpcy5vcmlnaW4gPyAndHJ1ZScgOiAnZmFsc2UnKVxuICByZXR1cm4gbm9kZVxufVxuXG5JbWFnZS5wcm90b3R5cGUuc3R5bGUgPSB3ZWV4LnV0aWxzLmV4dGVuZChcbiAgICBPYmplY3QuY3JlYXRlKENvbXBvbmVudC5wcm90b3R5cGUuc3R5bGUpLCB7XG4gIHdpZHRoOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpICogdGhpcy5kYXRhLnNjYWxlXG4gICAgaWYgKHZhbCA8IDAgfHwgdmFsICE9PSB2YWwpIHtcbiAgICAgIHZhbCA9IERFRkFVTFRfU0laRVxuICAgIH1cbiAgICB0aGlzLm5vZGUuc3R5bGUud2lkdGggPSB2YWwgKyAncHgnXG4gICAgdmFyIF9kcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb1xuICAgIGlmICh3aW5kb3cuZHByID09PSAxICYmIF9kcHIgIT09IDEpIHtcbiAgICAgIHZhbCA9IHZhbCAqIF9kcHJcbiAgICB9XG4gICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS13aWR0aCcsIHZhbClcbiAgfSxcblxuICBoZWlnaHQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YWwgPSBwYXJzZUZsb2F0KHZhbCkgKiB0aGlzLmRhdGEuc2NhbGVcbiAgICBpZiAodmFsIDwgMCB8fCB2YWwgIT09IHZhbCkge1xuICAgICAgdmFsID0gREVGQVVMVF9TSVpFXG4gICAgfVxuICAgIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSB2YWwgKyAncHgnXG4gICAgdmFyIF9kcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb1xuICAgIGlmICh3aW5kb3cuZHByID09PSAxICYmIF9kcHIgIT09IDEpIHtcbiAgICAgIHZhbCA9IHZhbCAqIF9kcHJcbiAgICB9XG4gICAgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1oZWlnaHQnLCB2YWwpXG4gIH1cbn0pXG5cbkltYWdlLnByb3RvdHlwZS5hdHRyID0ge1xuICBzcmM6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoIXRoaXMuc3JjKSB7XG4gICAgICB0aGlzLnNyYyA9IGxpYi5pbWcuZGVmYXVsdFNyY1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJyArIHRoaXMuc3JjICsgJyknXG4gICAgfVxuICAgIExhenlMb2FkLm1ha2VJbWFnZUxhenkodGhpcy5ub2RlLCB2YWwpXG4gIH0sXG5cbiAgcmVzaXplOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgaWYgKFJFU0laRV9NT0RFUy5pbmRleE9mKHZhbCkgPT09IC0xKSB7XG4gICAgICB2YWwgPSAnc3RyZXRjaCdcbiAgICB9XG4gICAgdGhpcy5ub2RlLnN0eWxlLmJhY2tncm91bmRTaXplID0gdmFsID09PSAnc3RyZXRjaCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzEwMCUgMTAwJSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsXG4gIH1cbn1cblxuSW1hZ2UucHJvdG90eXBlLmNsZWFyQXR0ciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zcmMgPSAnJ1xuICB0aGlzLm5vZGUuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJydcbn1cblxuSW1hZ2UucHJvdG90eXBlLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgLy8gZG8gbm90aGluZ1xuICByZXR1cm5cbn1cblxuSW1hZ2UucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChjaGlsZCwgYmVmb3JlKSB7XG4gIC8vIGRvIG5vdGhpbmdcbiAgcmV0dXJuXG59XG5cbkltYWdlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAvLyBkbyBub3RoaW5nXG4gIHJldHVyblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9pbWFnZS5qc1xuICoqIG1vZHVsZSBpZCA9IDE0MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxucmVxdWlyZSgnLi9pbWdQcm9jZXNzb3InKVxuXG52YXIgREVGQVVMVF9ERVNJR05fV0lEVEggPSA3NTBcblxudmFyIGxhenlsb2FkVGltZXJcbnZhciBpc0NvbmZpZ1NldHVwID0gZmFsc2VcblxudmFyIExhenlMb2FkID0ge1xuXG4gIG1ha2VJbWFnZUxhenk6IGZ1bmN0aW9uIChpbWFnZSwgc3JjKSB7XG5cbiAgICBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ2ltZy1zcmMnKVxuICAgIGltYWdlLnJlbW92ZUF0dHJpYnV0ZSgnaS1sYXp5LXNyYycpXG4gICAgaW1hZ2Uuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJydcbiAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ2ltZy1zcmMnLCBzcmMpXG4gICAgLy8gc2hvdWxkIHJlcGxhY2UgJ3NyYycgd2l0aCAnaW1nLXNyYycuIGJ1dCBmb3Igbm93IGxpYi5pbWcuZmlyZSBpc1xuICAgIC8vIG5vdCB3b3JraW5nIGZvciB0aGUgc2l0dWF0aW9uIHRoYXQgdGhlIGFwcGVhciBldmVudCBoYXMgYmVlblxuICAgIC8vIGFscmVhZHkgdHJpZ2dlcmVkLlxuICAgIHRoaXMuZmlyZSgpXG4gIH0sXG5cbiAgLy8gVE9ETzogbWFrZSBpdCBhIGRlY2VudCBpbXBsXG4gIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyB3aGVuIGFsbCBpbWFnZSBhcmUgYXBwZW5kZWRcbiAgLy8ganVzdCB1c2Ugc2V0VGltZW91dCB0byBkbyBkZWxheSBsYXp5bG9hZFxuICAvL1xuICAvLyAtLSBhY3R1YWxseSBldmVyeXRpbWUgd2UgYWRkIGEgZWxlbWVudCBvciB1cGRhdGUgc3R5bGVzLFxuICAvLyB0aGUgY29tcG9uZW50IG1hbmFnZXIgd2lsbCBjYWxsIHN0YXJ0SWZOZWVkIHRvIGZpcmVcbiAgLy8gbGF6eWxvYWQgb25jZSBhZ2FpbiBpbiB0aGUgaGFuZGxlQXBwZW5kIGZ1bmN0aW9uLiBzbyB0aGVyZVxuICAvLyBpcyBubyB3YXkgdGhhdCBhbnkgaW1hZ2UgZWxlbWVudCBjYW4gbWlzcyBpdC4gU2VlIHNvdXJjZVxuICAvLyBjb2RlIGluIGNvbXBvbmVudE1hbmdhZ2VyLmpzLlxuICBzdGFydElmTmVlZGVkOiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgaWYgKGNvbXBvbmVudC5kYXRhLnR5cGUgPT09ICdpbWFnZScpIHtcbiAgICAgIGlmICghbGF6eWxvYWRUaW1lcikge1xuICAgICAgICBsYXp5bG9hZFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGliLmltZy5maXJlKClcbiAgICAgICAgICBjbGVhclRpbWVvdXQobGF6eWxvYWRUaW1lcilcbiAgICAgICAgICBsYXp5bG9hZFRpbWVyID0gbnVsbFxuICAgICAgICB9LCAxNilcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbG9hZElmTmVlZGVkOiBmdW5jdGlvbiAoZWxlbWVudFNjb3BlKSB7XG4gICAgdmFyIG5vdFByZVByb2Nlc3NlZCA9IGVsZW1lbnRTY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW1nLXNyY10nKVxuICAgIC8vIGltYWdlIGVsZW1lbnRzIHdoaWNoIGhhdmUgYXR0cmlidXRlICdpLWxhenktc3JjJyB3ZXJlIGVsZW1lbnRzXG4gICAgLy8gdGhhdCBoYWQgYmVlbiBwcmVwcm9jZXNzZWQgYnkgbGliLWltZy1jb3JlLCBidXQgbm90IGxvYWRlZCB5ZXQsIGFuZFxuICAgIC8vIG11c3QgYmUgbG9hZGVkIHdoZW4gJ2FwcGVhcicgZXZlbnRzIHdlcmUgZmlyZWQuIEl0IHR1cm5zIG91dCB0aGVcbiAgICAvLyAnYXBwZWFyJyBldmVudCB3YXMgbm90IGZpcmVkIGNvcnJlY3RseSBpbiB0aGUgY3NzLXRyYW5zbGF0ZS10cmFuc2l0aW9uXG4gICAgLy8gc2l0dWF0aW9uLCBzbyAnaS1sYXp5LXNyYycgbXVzdCBiZSBjaGVja2VkIGFuZCBsYXp5bG9hZCBtdXN0IGJlXG4gICAgLy8gZmlyZWQgbWFudWFsbHkuXG4gICAgdmFyIHByZVByb2Nlc3NlZCA9IGVsZW1lbnRTY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdbaS1sYXp5LXNyY10nKVxuICAgIGlmIChub3RQcmVQcm9jZXNzZWQubGVuZ3RoID4gMCB8fCBwcmVQcm9jZXNzZWQubGVuZ3RoID4gMCkge1xuICAgICAgbGliLmltZy5maXJlKClcbiAgICB9XG4gIH0sXG5cbiAgLy8gZmlyZSBsYXp5bG9hZC5cbiAgZmlyZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNDb25maWdTZXR1cCkge1xuICAgICAgbGliLmltZy5zZXRDb25maWcoe1xuICAgICAgICBiYXNlRHByOiAoeyA3NTA6IDIsIDExMjU6IDMgfSlbREVGQVVMVF9ERVNJR05fV0lEVEhdIHx8IDEsXG4gICAgICAgIGF1dG9TaXplOiB0cnVlLFxuICAgICAgICBkZWZhdWx0QXR0cjoge1xuICAgICAgICAgIHFOb3JtYWw6ICdxOTAnLFxuICAgICAgICAgIHFXZWFrOiAncTYwJ1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaXNDb25maWdTZXR1cCA9IHRydWVcbiAgICB9XG4gICAgbGliLmltZy5maXJlKClcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGF6eUxvYWRcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvbGF6eUxvYWQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwicmVxdWlyZSgnYXBwZWFyanMnKVxucmVxdWlyZSgnQGFsaS9saWItaW1nLWNvcmUnKVxuXG47IChmdW5jdGlvbiAod2luLCBsaWIpIHtcblxuICB2YXIgYWRhcHRlciA9IHt9XG4gIHZhciBhcHBlYXJJbnN0YW5jZVxuICB2YXIgcnVudGltZUZsYWdzID0ge31cblxuICB2YXIgY29uZmlnID0ge1xuICAgIGRlZmF1bHRBdHRyOiB7XG4gICAgICBxTm9ybWFsOiAncTUwJywgLy8g5by6572R6LSo6YePXG4gICAgICBxV2VhazogJ3EzMCcsIC8vIOW8see9kei0qOmHj1xuICAgICAgc2hhcnBlbjogJ3MxNTAnLCAvLyDplJDljJblj4LmlbBcbiAgICAgIGxhenk6IHRydWUsIC8vIOaHkuWKoOi9veW8gOWFs1xuICAgICAgd2lkdGg6IDQwMCwgLy8g5a695bqmXG4gICAgICBoZWlnaHQ6IDQwMCwgLy8g6auY5bqmXG4gICAgICB0eXBlOiAnc3F1YXJlJywgLy8g6KOB5Ymq57G75Z6LXG4gICAgICBvcmlnaW5hbDogZmFsc2UgLy8g5LuF5LuF5pS25pWbQ0RO5Z+f5ZCNLCDkuI3mt7vliqDku7vkvZXotKjph4/mjqfliLblkI7nvIBcbiAgICB9LFxuICAgIC8vIOWQr+eUqOiHquWKqOWwuuWvuDog6Iul5pyq6YCa6L+H5YWD57SgYXR0aWJ1dGXmjIflrprlpKflsI8sIOWImeiOt+WPluWdkeS9jeWkp+WwjztcbiAgICAvLyDnpoHnlKjoh6rliqjlsLrlr7g6IOiLpeacqumAmui/h+WFg+e0oGF0dGlidXRl5oyH5a6a5aSn5bCPLCDliJnph4fnlKhkZWZhdWx0QXR0cuS4reaMh+WumueahOWkp+WwjztcbiAgICBhdXRvU2l6ZTogdHJ1ZSxcbiAgICBkYXRhU3JjOiAnaW1nLXNyYycsIC8vIOaMh+WumuWbvueJh+WcsOWdgOeahGF0dHJpYnV0ZeWQjSwg5YW85YGabGF6eS1jbGFzc+eahOS9nOeUqFxuICAgIGxhenlIZWlnaHQ6IDAsIC8vIOS7peatpOmrmOW6puaPkOWJjeinpuWPkeaHkuWKoOi9vVxuICAgIGxhenlXaWR0aDogMCwgLy8g5Lul5q2k5a695bqm5o+Q5YmN6Kem5Y+R5oeS5Yqg6L29XG4gICAgYmFzZURwcjogMiwgLy8g5oyH5a6a5bC65a+455qE5Z+656GAZHByXG4gICAgaWdub3JlR2lmOiB0cnVlLCAvLyDmmK/lkKblv73nlaVnaWblm77vvIzpu5jorqTljLrliIblubbkuJTkuI3lgZrku7vkvZXlpITnkIZcbiAgICBpZ25vcmVQbmc6IGZhbHNlLCAvLyDmmK/lkKblv73nlaVwbmflm77niYdcbiAgICBmaWx0ZXJEb21haW5zOiBbXG4gICAgICAnYS50YmNkbi5jbicsXG4gICAgICAnYXNzZXRzLmFsaWNkbi5jb20nLFxuICAgICAgJ3d3Yy50YW9iYW9jZG4uY29tJyxcbiAgICAgICd3d2MuYWxpY2RuLmNvbSdcbiAgICBdIC8vIOiHquWumuS5iei/h+a7pOeahOWfn+WQjeWRveS7pO+8jOmAgueUqOS6juS4jeiDveaUtuaVm+eahOWfn+WQjXVybFxuICB9XG5cblxuICBmdW5jdGlvbiBleHRlbmRTdHJpY3QobWFpbiwgc3ViKSB7XG4gICAgdmFyIHJldCA9IHt9XG4gICAgZm9yICh2YXIgayBpbiBtYWluKSB7XG4gICAgICBpZiAobWFpbi5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICByZXRba10gPSBzdWIuaGFzT3duUHJvcGVydHkoaykgPyBzdWJba10gOiBtYWluW2tdXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZFNpbXBsZShtYWluLCBzdWIpIHtcbiAgICBmb3IgKHZhciBrIGluIHN1Yikge1xuICAgICAgaWYgKHN1Yi5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICBtYWluW2tdID0gc3ViW2tdXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYWluXG4gIH1cblxuXG4gIGZ1bmN0aW9uIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgaWYgKCEobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvV2luZFZhbmUvaSkgJiYgd2luLldpbmRWYW5lKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFdpbmRWYW5lLmNhbGwoJ1dWTmV0d29yaycsICdnZXROZXR3b3JrVHlwZScsIHt9LCBmdW5jdGlvbiAoaW5mbykge1xuICAgICAgaWYgKGluZm8gJiYgaW5mby50eXBlKSB7XG4gICAgICAgIHJ1bnRpbWVGbGFncy5pc1dpRmkgPSAoaW5mby50eXBlLnRvTG93ZXJDYXNlKCkgPT0gJ3dpZmknKVxuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uICgpIHt9KVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZWN0TGlicygpIHtcbiAgICBpZiAoIXdpbi5saWIgfHwgIXdpbi5saWIuZmxleGlibGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignbGliLWltZzog5pyq5qOA5rWL5YiwIGxpYi1mbGV4aWJsZSwgYXV0b1NpemUg54m55oCn5Y+v6IO95LiN6IO95q2j5bi45bel5L2cJylcbiAgICB9IGVsc2Uge1xuICAgICAgcnVudGltZUZsYWdzLmZsZXhpYmxlU3VwcG9ydCA9IHRydWVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRlY3RXZWJwKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgd2ViUCA9IG5ldyBJbWFnZSgpXG4gICAgICB3ZWJQLnNyYyA9ICdkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSam9BQUFCWFJVSlFWbEE0SUM0QUFBQ3lBZ0NkQVMnXG4gICAgICAgKyAnb0NBQUlBTG1rMG1rMGlJaUlpSWdCb1N5Z0FCYzZXV2dBQS92ZWZmLzBQUDhiQS8vTHdZQUFBJ1xuICAgICAgd2ViUC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh3ZWJQLmhlaWdodCA9PT0gMikge1xuICAgICAgICAgIHJ1bnRpbWVGbGFncy53ZWJwU3VwcG9ydCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNBdXRvU2l6ZShpdGVtKSB7XG4gICAgdmFyIGhlaWdodCA9IGl0ZW0ub2Zmc2V0SGVpZ2h0XG4gICAgdmFyIHdpZHRoID0gaXRlbS5vZmZzZXRXaWR0aFxuXG4gICAgaWYgKHJ1bnRpbWVGbGFncy5mbGV4aWJsZVN1cHBvcnQgJiYgd2luLmxpYi5mbGV4aWJsZS5kcHIgPT0gMSkge1xuICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogd2luLmRldmljZVBpeGVsUmF0aW9cbiAgICAgIHdpZHRoID0gd2lkdGggKiB3aW4uZGV2aWNlUGl4ZWxSYXRpb1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IE1hdGgucm91bmQod2lkdGgpLFxuICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKGhlaWdodClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVNyYyhpdGVtLCBwcm9jZXNzZWRTcmMpIHtcbiAgICBpZiAoIXByb2Nlc3NlZFNyYykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChpdGVtLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gJ0lNRycpIHtcbiAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdzcmMnLCBwcm9jZXNzZWRTcmMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW0uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyBwcm9jZXNzZWRTcmMgKyAnXCIpJ1xuICAgIH1cbiAgfVxuXG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1NyYyhpdGVtLCBvcmlnaW5hbFNyYykge1xuICAgIGlmICghb3JpZ2luYWxTcmMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcGFyYW0gPSBleHRlbmRTdHJpY3QoY29uZmlnLmRlZmF1bHRBdHRyLCBpdGVtLmRhdGFzZXQpXG4gICAgaWYgKHR5cGVvZiBwYXJhbS5vcmlnaW5hbCAhPSAnYm9vbGVhbicpIHtcbiAgICAgIHBhcmFtLm9yaWdpbmFsID0gKHBhcmFtLm9yaWdpbmFsID09ICd0cnVlJylcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5hdXRvU2l6ZSAmJiAhcGFyYW0ub3JpZ2luYWxcbiAgICAgICAgJiYgIShpdGVtLmRhdGFzZXQud2lkdGggJiYgaXRlbS5kYXRhc2V0LmhlaWdodCkpIHtcbiAgICAgIGV4dGVuZFNpbXBsZShwYXJhbSwgY2FsY0F1dG9TaXplKGl0ZW0pKVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbS5oZWlnaHQgPSBNYXRoLnJvdW5kKHBhcnNlSW50KHBhcmFtLmhlaWdodCwgMTApXG4gICAgICAgICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gLyBjb25maWcuYmFzZURwcilcbiAgICAgIHBhcmFtLndpZHRoID0gTWF0aC5yb3VuZChwYXJzZUludChwYXJhbS53aWR0aCwgMTApXG4gICAgICAgICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gLyBjb25maWcuYmFzZURwcilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJ1bnRpbWVGbGFncy5pc1dpRmkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYXJhbS5xID0gcGFyYW0ucU5vcm1hbFxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbS5xID0gcnVudGltZUZsYWdzLmlzV2lGaSA/IHBhcmFtLnFOb3JtYWwgOiBwYXJhbS5xV2Vha1xuICAgIH1cbiAgICBwYXJhbS53ZWJwU3VwcG9ydCA9IHJ1bnRpbWVGbGFncy53ZWJwU3VwcG9ydCA/IHRydWUgOiBmYWxzZVxuICAgIHBhcmFtLmlnbm9yZUdpZiA9IGNvbmZpZy5pZ25vcmVHaWZcbiAgICBwYXJhbS5pZ25vcmVQbmcgPSBjb25maWcuaWdub3JlUG5nXG4gICAgcGFyYW0uZmlsdGVyRG9tYWlucyA9IGNvbmZpZy5maWx0ZXJEb21haW5zXG5cbiAgICByZXR1cm4gbGliLmltZ2NvcmUuZ2V0TmV3VXJsKG9yaWdpbmFsU3JjLCBwYXJhbSlcbiAgfVxuXG5cblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGFwcGVhckluc3RhbmNlID0gbGliLmFwcGVhci5pbml0KHtcbiAgICAgIGNsczogJ2ltZ3RtcCcsIC8vIOWPr+mAie+8jOmcgOimgemBjeWOhueahOWFg+e0oFxuICAgICAgb25jZTogdHJ1ZSwgLy8g5Y+v6YCJ77yM5piv5ZCm5Y+q6Kem5Y+R5LiA5qyhXG4gICAgICB4OiBjb25maWcubGF6eVdpZHRoLCAvLyDlj6/pgInvvIzlrrnlmajlj7Povrnot53nprt45Lul5YaF55qE5YWD57Sg5Yqg6L2977yM6buY6K6k5Li6MFxuICAgICAgeTogY29uZmlnLmxhenlIZWlnaHQsIC8vIOWPr+mAie+8jOWuueWZqOW6lemDqOi3neemu3nku6XlhoXnmoTlhYPntKDliqDovb3vvIzpu5jorqTkuLowXG4gICAgICBvbkFwcGVhcjogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXNcbiAgICAgICAgYXBwbHlTcmMoaXRlbSwgcHJvY2Vzc1NyYyhpdGVtLCBpdGVtLmdldEF0dHJpYnV0ZSgnaS1sYXp5LXNyYycpKSlcbiAgICAgICAgaXRlbS5yZW1vdmVBdHRyaWJ1dGUoJ2ktbGF6eS1zcmMnKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHJ1bnRpbWVGbGFncy5pc1dpRmlcbiAgICAgICAgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKGlQaG9uZXxpUGFkfGlQb2QpLykpIHtcbiAgICAgIGNvbmZpZy5kZWZhdWx0QXR0ci5sYXp5ID0gZmFsc2VcbiAgICB9XG4gIH1cblxuXG4gIGFkYXB0ZXIubG9nQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKCdsaWItaW1nIENvbmZpZ1xcbicsXG4gICAgICBjb25maWcsXG4gICAgICAnXFxubGliLWltZyBSdW50aW1lXFxuJyxcbiAgICAgIHJ1bnRpbWVGbGFncylcbiAgfVxuXG4gIGFkYXB0ZXIuc2V0Q29uZmlnID0gZnVuY3Rpb24gKG5ld0NmZykge1xuICAgIGlmIChuZXdDZmcuZGVmYXVsdEF0dHIpIHtcbiAgICAgIG5ld0NmZy5kZWZhdWx0QXR0ciA9IGV4dGVuZFN0cmljdChjb25maWcuZGVmYXVsdEF0dHIsIG5ld0NmZy5kZWZhdWx0QXR0cilcbiAgICB9XG4gICAgaWYgKG5ld0NmZy5maWx0ZXJEb21haW5zKSB7XG4gICAgICBuZXdDZmcuZmlsdGVyRG9tYWlucyA9IG5ld0NmZy5maWx0ZXJEb21haW5zLmNvbmNhdChjb25maWcuZmlsdGVyRG9tYWlucylcbiAgICB9XG4gICAgY29uZmlnID0gZXh0ZW5kU3RyaWN0KGNvbmZpZywgbmV3Q2ZnKVxuICB9XG5cbiAgYWRhcHRlci5maXJlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCFhcHBlYXJJbnN0YW5jZSkge1xuICAgICAgaW5pdCgpXG4gICAgfVxuXG4gICAgdmFyIGxhYmVsID0gJ2lfJyArIERhdGUubm93KCkgJSAxMDAwMDBcbiAgICB2YXIgZG9tTGlzdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgY29uZmlnLmRhdGFTcmMgKyAnXScpXG5cbiAgICA7IFtdLmZvckVhY2guY2FsbChkb21MaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0uZGF0YXNldC5sYXp5ID09ICdmYWxzZSdcbiAgICAgICAgfHwgIWNvbmZpZy5kZWZhdWx0QXR0ci5sYXp5XG4gICAgICAgICYmIGl0ZW0uZGF0YXNldC5sYXp5ICE9ICd0cnVlJykge1xuICAgICAgICBhcHBseVNyYyhpdGVtLCBwcm9jZXNzU3JjKGl0ZW0sIGl0ZW0uZ2V0QXR0cmlidXRlKGNvbmZpZy5kYXRhU3JjKSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQobGFiZWwpXG4gICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKCdpLWxhenktc3JjJywgaXRlbS5nZXRBdHRyaWJ1dGUoY29uZmlnLmRhdGFTcmMpKVxuICAgICAgfVxuICAgICAgaXRlbS5yZW1vdmVBdHRyaWJ1dGUoY29uZmlnLmRhdGFTcmMpXG4gICAgfSlcblxuICAgIGFwcGVhckluc3RhbmNlLmJpbmQoJy4nICsgbGFiZWwpXG4gICAgYXBwZWFySW5zdGFuY2UuZmlyZSgpXG4gIH1cblxuICBhZGFwdGVyLmRlZmF1bHRTcmMgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQSdcbiAgICArICdBQkNBWUFBQUFmRmNTSkFBQUFEVWxFUVZRSW1XTmdZR0JnQUFBQUJRQUJoNkZPMUFBQUFBQkpSVTVFcmtKZ2dnPT0nXG5cbiAgbGliLmltZyA9IGFkYXB0ZXJcbiAgZXhwb3J0cy5tb2R1bGUgPSBsaWIuaW1nXG4gIGRldGVjdFdlYnAoKVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgIGRldGVjdE5ldHdvcmsoKVxuICAgIGRldGVjdExpYnMoKVxuICB9KVxuXG59KSh3aW5kb3csIHdpbmRvd1snbGliJ10gfHwgKHdpbmRvd1snbGliJ10gPSB7fSkpXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2ltZ1Byb2Nlc3Nvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE0NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCJcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93JiYod2luZG93PXtjdHJsOnt9LGxpYjp7fX0pLCF3aW5kb3cuY3RybCYmKHdpbmRvdy5jdHJsPXt9KSwhd2luZG93LmxpYiYmKHdpbmRvdy5saWI9e30pLHJlcXVpcmUoXCJAYWxpL2xpYi1odHRwdXJsXCIpLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUpe2Zvcih2YXIgaSBpbiBlKWUuaGFzT3duUHJvcGVydHkoaSkmJih0W2ldPWVbaV0pO3JldHVybiB0fWZ1bmN0aW9uIGUodCl7dmFyIGUsaT10LndpZHRoLHI9dC5oZWlnaHQsYT10LnR5cGUsbj10LmRwcnx8MjthPWF8fG87dmFyIHM9ZC5zcXVhcmU7aWYoIShpK1wiXCIpLm1hdGNoKC9eXFxkKyQvKXx8IShyK1wiXCIpLm1hdGNoKC9eXFxkKyQvKSl0aHJvdyBuZXcgRXJyb3IoXCJoZWlnaHQgb3Igd2lkdGggaXMgbm90IG51bWJlclwiKTtzd2l0Y2goZT1hPT1jP3I6aT49cj9pOnIsYSl7Y2FzZSBoOnM9ZC53aWR0aHM7YnJlYWs7Y2FzZSBjOnM9ZC5oZWlnaHRzO2JyZWFrO2Nhc2UgcDpzPWQueHpzfXZhciBsPXNbcy5sZW5ndGgtMV0sdz1zWzBdLGY9MCx1PWcuYmFzZURwcjtpZihlPXBhcnNlSW50KG4qZS91KSxlPj1sKXJldHVybiBsO2lmKHc+PWUpcmV0dXJuIHc7Zm9yKHZhciBtPXMubGVuZ3RoO20+PTA7bS0tKWlmKHNbbV08PWUpe3NbbV09PWU/Zj1lOm08cy5sZW5ndGgtMSYmKGY9c1ttKzFdKTticmVha31yZXR1cm4gZn1mdW5jdGlvbiBpKHQpe3ZhciBpPVwiXCIscj1cIlwiLGE9Zy5xLG49Zy5zaGFycGVuLGQ9KGcuZGVmYXVsdFNpemUsbykscz10LndpZHRofHxnLndpZHRoLGw9dC5oZWlnaHR8fGcuaGVpZ2h0O3N3aXRjaCh0JiZ0LnR5cGUmJnQudHlwZS5tYXRjaChuZXcgUmVnRXhwKFwiXihcIitbbyxoLGMscF0uam9pbihcInxcIikrXCIpJFwiKSkmJihkPXQudHlwZSksaT1lKHt3aWR0aDpzLGhlaWdodDpsLHR5cGU6ZH0pLGQpe2Nhc2UgbzppPWkrXCJ4XCIraTticmVhaztjYXNlIGg6aSs9XCJ4MTAwMDBcIjticmVhaztjYXNlIGM6aT1cIjEwMDAweFwiK2k7YnJlYWs7Y2FzZSBwOmk9aStcInhcIitpK1wieHpcIn1yZXR1cm4gcj1cIl9cIitpLFwib3JpZ2luYWxcIj09PWEmJihhPVwiXCIpLFwib3JpZ2luYWxcIj09PW4mJihuPVwiXCIpLHIrPWErbitcIi5qcGdcIn1mdW5jdGlvbiByKHIsbyl7dmFyIG89b3x8e307aWYodChnLG8pLCFyfHxcInN0cmluZ1wiIT10eXBlb2YgcilyZXR1cm5cIlwiO2cuZGVmYXVsdFNpemU9Zy5kZWZhdWx0U2l6ZXx8ZSh7aGVpZ2h0Om8uaGVpZ2h0LHdpZHRoOm8ud2lkdGgsZHByOm8uZHByfSk7dmFyIGg9Zy5kZWZhdWx0U2l6ZStcInhcIitnLmRlZmF1bHRTaXplLGM9Zy5xLHA9XCJfXCIraCtjK2cuc2hhcnBlbitcIi5qcGdcIjt0cnl7dmFyIHM9bmV3IGxpYi5odHRwdXJsKHIpfWNhdGNoKGwpe3JldHVybiBjb25zb2xlLmxvZyhcIltlcnJvcl13cm9uZyBpbWcgdXJsOlwiLHIpLHJ9dmFyIHc9cy5ob3N0LGY9cy5wYXRobmFtZTtpZihzLnByb3RvY29sPVwiXCIsZC5maWx0ZXJEb21haW5zPWQuZmlsdGVyRG9tYWlucy5jb25jYXQoZy5maWx0ZXJEb21haW5zKSwtMSE9ZC5maWx0ZXJEb21haW5zLmluZGV4T2YodykpcmV0dXJuL2FsaWNkbi8udGVzdCh3KXx8KHMucHJvdG9jb2w9XCJodHRwOlwiKSxzLnRvU3RyaW5nKCk7dmFyIHU9dy5tYXRjaCgvKC4rXFwuKD86YWxpY2RufHRhb2Jhb2Nkbnx0YW9iYW98bW1jZG4pXFwuY29tKS8pO2lmKHUmJnVbMF0hPWEmJihzLmhvc3Q9YSksbyYmby5vcmlnaW5hbClyZXR1cm4gcy50b1N0cmluZygpO3ZhciBtPWYubWF0Y2gobiksYj1mLm1hdGNoKC8tKFxcZCspLShcXGQrKVxcLig/OmpwZ3xwbmd8Z2lmKS8pO2lmKGIpe3ZhciB4LHY7eD1wYXJzZUludChiWzFdKTxwYXJzZUludChnLmRlZmF1bHRTaXplKT9nLmRlZmF1bHRTaXplOmJbMV0+NzYwPzc2MDpiWzFdLHY9ZSh7aGVpZ2h0Ongsd2lkdGg6eCxkcHI6by5kcHJ9KSxwPVwiX1wiK3YrXCJ4XCIrditjK2cuc2hhcnBlbitcIi5qcGdcIn1yZXR1cm4gbyYmXCJzdHJpbmdcIj09dHlwZW9mIG8/cD1pKHtzaXplOm99KTpvJiZcIm9iamVjdFwiPT10eXBlb2YgbyYmT2JqZWN0LmtleXMobykubGVuZ3RoPjAmJihwPWkobykpLC9cXC5wbmcvLnRlc3QoZikmJihwPXAucmVwbGFjZSgvKHFcXGQrKShzXFxkKykvLFwiXCIpKSwvXFwuZ2lmLy50ZXN0KGYpJiZvLmlnbm9yZUdpZj9zLnRvU3RyaW5nKCk6L1xcLnBuZy8udGVzdChmKSYmby5pZ25vcmVQbmc/cy50b1N0cmluZygpOihvLndlYnBTdXBwb3J0JiYocCs9XCJfLndlYnBcIiksbT9tWzFdfHxtWzJdfHxtWzNdfHxtWzRdP3MucGF0aG5hbWU9Zi5yZXBsYWNlKG4scCk6bVswXS5tYXRjaCgvX1xcLihqcGd8cG5nfGdpZnxqcGVmKS8pJiYocy5wYXRobmFtZSs9cCk6Zi5tYXRjaCgvX1xcLndlYnAkL2cpP3MucGF0aG5hbWU9Zi5yZXBsYWNlKC9fXFwud2VicCQvZyxwKTpzLnBhdGhuYW1lPWYrcCxzLnRvU3RyaW5nKCkpfWxpYnx8KGxpYj17fSk7dmFyIGE9XCJndy5hbGljZG4uY29tXCIsbj0vXyhcXGQreFxcZCt8Y3lcXGQraVxcZCt8c3VtfG18Yik/KHh6fHhjKT8ocVxcZCspPyhzXFxkKyk/KFxcLmpwZyk/KF9cXC53ZWJwKT8kL2ksbz1cInNxdWFyZVwiLGg9XCJ3aWR0aEZpeGVkXCIsYz1cImhlaWdodEZpeGVkXCIscD1cInh6XCIsZD17fTtkLndpZHRocz1bMTEwLDE1MCwxNzAsMjIwLDI0MCwyOTAsNDUwLDU3MCw1ODAsNjIwLDc5MF0sZC5oZWlnaHRzPVsxNzAsMjIwLDM0MCw1MDBdLGQueHpzPVs3Miw4MCw4OCw5MCwxMDAsMTEwLDEyMCwxNDUsMTYwLDE3MCwxODAsMjAwLDIzMCwyNzAsMjkwLDMxMCwzNjAsNDMwLDQ2MCw1ODAsNjQwXSxkLnNxdWFyZT1bMTYsMjAsMjQsMzAsMzIsMzYsNDAsNDgsNTAsNjAsNjQsNzAsNzIsODAsODgsOTAsMTAwLDExMCwxMjAsMTI1LDEyOCwxNDUsMTgwLDE5MCwyMDAsMjAwLDIxMCwyMjAsMjMwLDI0MCwyNTAsMjcwLDMwMCwzMTAsMzE1LDMyMCwzMzYsMzYwLDQ2OCw0OTAsNTQwLDU2MCw1ODAsNjAwLDY0MCw3MjAsNzI4LDc2MCw5NzBdLGQuZmlsdGVyRG9tYWlucz1bXCJhLnRiY2RuLmNuXCIsXCJhc3NldHMuYWxpY2RuLmNvbVwiLFwid3djLnRhb2Jhb2Nkbi5jb21cIixcInd3Yy5hbGljZG4uY29tXCIsXCJjYnUwMS5hbGljZG4uY29tXCJdO3ZhciBnPXt3aWR0aDozMjAsaGVpZ2h0OjMyMCx3ZWJwU3VwcG9ydDohMSxpZ25vcmVHaWY6ITAsaWdub3JlUG5nOiExLHNoYXJwZW46XCJzMTUwXCIscTpcInE1MFwiLGJhc2VEcHI6MixvcmlnaW5hbDohMSxmaWx0ZXJEb21haW5zOltdfSxzPXtnZXROZXdVcmw6cn07bGliLmltZ2NvcmU9cyxtb2R1bGUuZXhwb3J0cz1zfSgpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0BhbGkvbGliLWltZy1jb3JlL2J1aWxkL2ltZ2NvcmUuY29tbW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMTQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgJiYgKHdpbmRvdyA9IHtjdHJsOiB7fSwgbGliOiB7fX0pOyF3aW5kb3cuY3RybCAmJiAod2luZG93LmN0cmwgPSB7fSk7IXdpbmRvdy5saWIgJiYgKHdpbmRvdy5saWIgPSB7fSk7IWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXt2YXIgYj17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcInBhcmFtc1wiLHtzZXQ6ZnVuY3Rpb24oYSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEpe2Zvcih2YXIgYyBpbiBiKWRlbGV0ZSBiW2NdO2Zvcih2YXIgYyBpbiBhKWJbY109YVtjXX19LGdldDpmdW5jdGlvbigpe3JldHVybiBifSxlbnVtZXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJzZWFyY2hcIix7c2V0OmZ1bmN0aW9uKGEpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhKXswPT09YS5pbmRleE9mKFwiP1wiKSYmKGE9YS5zdWJzdHIoMSkpO3ZhciBjPWEuc3BsaXQoXCImXCIpO2Zvcih2YXIgZCBpbiBiKWRlbGV0ZSBiW2RdO2Zvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKXt2YXIgZj1jW2VdLnNwbGl0KFwiPVwiKTtpZih2b2lkIDAhPT1mWzFdJiYoZlsxXT1mWzFdLnRvU3RyaW5nKCkpLGZbMF0pdHJ5e2JbZGVjb2RlVVJJQ29tcG9uZW50KGZbMF0pXT1kZWNvZGVVUklDb21wb25lbnQoZlsxXSl9Y2F0Y2goZyl7YltmWzBdXT1mWzFdfX19fSxnZXQ6ZnVuY3Rpb24oKXt2YXIgYT1bXTtmb3IodmFyIGMgaW4gYilpZih2b2lkIDAhPT1iW2NdKWlmKFwiXCIhPT1iW2NdKXRyeXthLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGMpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChiW2NdKSl9Y2F0Y2goZCl7YS5wdXNoKGMrXCI9XCIrYltjXSl9ZWxzZSB0cnl7YS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjKSl9Y2F0Y2goZCl7YS5wdXNoKGMpfXJldHVybiBhLmxlbmd0aD9cIj9cIithLmpvaW4oXCImXCIpOlwiXCJ9LGVudW1lcmFibGU6ITB9KTt2YXIgYztPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImhhc2hcIix7c2V0OmZ1bmN0aW9uKGEpe1wic3RyaW5nXCI9PXR5cGVvZiBhJiYoYSYmYS5pbmRleE9mKFwiI1wiKTwwJiYoYT1cIiNcIithKSxjPWF8fFwiXCIpfSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gY30sZW51bWVyYWJsZTohMH0pLHRoaXMuc2V0PWZ1bmN0aW9uKGEpe2E9YXx8XCJcIjt2YXIgYjtpZighKGI9YS5tYXRjaChuZXcgUmVnRXhwKFwiXihbYS16MC05LV0rOik/Wy9dezJ9KD86KFteQC86P10rKSg/OjooW15ALzpdKykpP0ApPyhbXjovPyNdKykoPzpbOl0oWzAtOV0rKSk/KFsvXVtePyM7XSopPyg/Ols/XShbXiNdKikpPyhbI11bXj9dKik/JFwiLFwiaVwiKSkpKXRocm93IG5ldyBFcnJvcihcIldyb25nIHVyaSBzY2hlbWUuXCIpO3RoaXMucHJvdG9jb2w9YlsxXXx8KFwib2JqZWN0XCI9PXR5cGVvZiBsb2NhdGlvbj9sb2NhdGlvbi5wcm90b2NvbDpcIlwiKSx0aGlzLnVzZXJuYW1lPWJbMl18fFwiXCIsdGhpcy5wYXNzd29yZD1iWzNdfHxcIlwiLHRoaXMuaG9zdG5hbWU9dGhpcy5ob3N0PWJbNF0sdGhpcy5wb3J0PWJbNV18fFwiXCIsdGhpcy5wYXRobmFtZT1iWzZdfHxcIi9cIix0aGlzLnNlYXJjaD1iWzddfHxcIlwiLHRoaXMuaGFzaD1iWzhdfHxcIlwiLHRoaXMub3JpZ2luPXRoaXMucHJvdG9jb2wrXCIvL1wiK3RoaXMuaG9zdG5hbWV9LHRoaXMudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnByb3RvY29sK1wiLy9cIjtyZXR1cm4gdGhpcy51c2VybmFtZSYmKGErPXRoaXMudXNlcm5hbWUsdGhpcy5wYXNzd29yZCYmKGErPVwiOlwiK3RoaXMucGFzc3dvcmQpLGErPVwiQFwiKSxhKz10aGlzLmhvc3QsdGhpcy5wb3J0JiZcIjgwXCIhPT10aGlzLnBvcnQmJihhKz1cIjpcIit0aGlzLnBvcnQpLHRoaXMucGF0aG5hbWUmJihhKz10aGlzLnBhdGhuYW1lKSx0aGlzLnNlYXJjaCYmKGErPXRoaXMuc2VhcmNoKSx0aGlzLmhhc2gmJihhKz10aGlzLmhhc2gpLGF9LGEmJnRoaXMuc2V0KGEudG9TdHJpbmcoKSl9Yi5odHRwdXJsPWZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYyhhKX19KHdpbmRvdyx3aW5kb3cubGlifHwod2luZG93LmxpYj17fSkpOzttb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5saWIuaHR0cHVybDtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9AYWxpL2xpYi1pbWctY29yZS9+L0BhbGkvbGliLWh0dHB1cmwvYnVpbGQvaHR0cHVybC5jb21tb24uanNcbiAqKiBtb2R1bGUgaWQgPSAxNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9pbWFnZS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW1hZ2UuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vaW1hZ2UuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3N0eWxlcy9pbWFnZS5jc3NcbiAqKiBtb2R1bGUgaWQgPSAxNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIud2VleC1pbWcge1xcblxcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlIDEwMCU7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiA1MCU7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2Nzcy1sb2FkZXIhLi9zcmMvc3R5bGVzL2ltYWdlLmNzc1xuICoqIG1vZHVsZSBpZCA9IDE0OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDFcbiAqKi8iLCIndXNlIHN0cmljdCdcblxudmFyIHdlZXggPSByZXF1aXJlKCd3ZWV4LWh0bWw1JylcbnZhciB1dGlscyA9IHdlZXgudXRpbHNcbnZhciBleHRlbmQgPSB1dGlscy5leHRlbmRcbnZhciBDb21wb25lbnQgPSB3ZWV4LkNvbXBvbmVudFxudmFyIENvbXBvbmVudE1hbmFnZXIgPSB3ZWV4LkNvbXBvbmVudE1hbmFnZXJcbnJlcXVpcmUoJy4uL3N0eWxlcy9zbGlkZXIuY3NzJylcblxudmFyIERFRkFVTFRfREVTSUdOX1dJRFRIID0gNzUwXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYmFzZURwcjogKHsgNzUwOiAyLCAxMTI1OiAzIH0pW0RFRkFVTFRfREVTSUdOX1dJRFRIXSB8fCAxLFxuICBxTm9ybWFsOiAncTkwJyxcbiAgcVdlYWs6ICdxNjAnXG59XG5cbi8vIG9wdHM6XG4vLyAgLSBhdXRvUGxheVxuLy8gIC0gcGxheXN0YXR1c1xuZnVuY3Rpb24gU2xpZGVyIChkYXRhKSB7XG4gIHRoaXMuYXV0b1BsYXkgPSBmYWxzZSAgLy8gZGVmYXVsdCB2YWx1ZSBpcyBmYWxzZS5cbiAgdGhpcy5kaXJlY3Rpb24gPSAncm93JyAvLyAnY29sdW1uJyBpcyBub3QgdGVtcG9yYXJpbHkgc3VwcG9ydGVkLlxuICB0aGlzLmNoaWxkcmVuID0gW11cbiAgdGhpcy5pc1BhZ2VTaG93ID0gdHJ1ZVxuICB0aGlzLmlzRG9tUmVuZGVyaW5nID0gdHJ1ZVxuXG4gIC8vIGJpbmQgZXZlbnQgJ3BhZ2VzaG93JyBhbmQgJ3BhZ2VoaWRlJyBvbiB3aW5kb3cuXG4gIHRoaXMuX2lkbGVXaGVuUGFnZURpc2FwcGVhcigpXG4gIC8vIGJpbmQgZXZlbnQgJ3JlbmRlckJlZ2luJyBhbmQgJ3JlbmRlckVuZCcgb24gd2luZG93LlxuICB0aGlzLl9pZGxlV2hlbkRvbVJlbmRlcmluZygpXG5cbiAgQ29tcG9uZW50LmNhbGwodGhpcywgZGF0YSlcbn1cblxuU2xpZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50LnByb3RvdHlwZSlcblxuU2xpZGVyLnByb3RvdHlwZS5faWRsZVdoZW5QYWdlRGlzYXBwZWFyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpcy5pc1BhZ2VTaG93ID0gdHJ1ZVxuICAgIF90aGlzLmF1dG9QbGF5ICYmICFfdGhpcy5pc0RvbVJlbmRlcmluZyAmJiBfdGhpcy5wbGF5KClcbiAgfSlcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmlzUGFnZVNob3cgPSBmYWxzZVxuICAgIF90aGlzLnN0b3AoKVxuICB9KVxufVxuXG5TbGlkZXIucHJvdG90eXBlLl9pZGxlV2hlbkRvbVJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpc1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVuZGVyZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLmlzRG9tUmVuZGVyaW5nID0gZmFsc2VcbiAgICBfdGhpcy5hdXRvUGxheSAmJiBfdGhpcy5pc1BhZ2VTaG93ICYmIF90aGlzLnBsYXkoKVxuICB9KVxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVuZGVyYmVnaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuaXNEb21SZW5kZXJpbmcgPSB0cnVlXG4gICAgX3RoaXMuc3RvcCgpXG4gIH0pXG59XG5cblNsaWRlci5wcm90b3R5cGUuYXR0ciA9IHtcbiAgaW50ZXJ2YWw6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmludGVydmFsID0gcGFyc2VJbnQodmFsKSB8fCAzMDAwXG4gICAgaWYgKHRoaXMuY2Fycm91c2VsKSB7XG4gICAgICB0aGlzLmNhcnJvdXNlbC5wbGF5SW50ZXJ2YWwgPSB0aGlzLmludGVydmFsXG4gICAgfVxuICB9LFxuXG4gIHBsYXlzdGF0dXM6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnBsYXlzdGF0dXMgPSB2YWwgJiYgdmFsICE9PSAnZmFsc2UnID8gdHJ1ZSA6IGZhbHNlXG4gICAgdGhpcy5hdXRvUGxheSA9IHRoaXMucGxheXN0YXR1c1xuICAgIGlmICh0aGlzLmNhcnJvdXNlbCkge1xuICAgICAgaWYgKHRoaXMucGxheXN0YXR1cykge1xuICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdG9wKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gc3VwcG9ydCBwbGF5c3RhdHVzJyBhbGlhcyBhdXRvLXBsYXkgZm9yIGNvbXBhdGliaWxpdHlcbiAgYXV0b1BsYXk6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmF0dHIucGxheXN0YXR1cy5jYWxsKHRoaXMsIHZhbClcbiAgfVxufVxuXG5TbGlkZXIucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBub2RlLmNsYXNzTGlzdC5hZGQoJ3NsaWRlcicpXG4gIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnXG4gIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJ1xuICByZXR1cm4gbm9kZVxufVxuXG5TbGlkZXIucHJvdG90eXBlLl9kb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpc1xuICBfdGhpcy5jcmVhdGVDaGlsZHJlbigpXG4gIF90aGlzLm9uQXBwZW5kKClcbn1cblxuU2xpZGVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW5cbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGNoaWxkLmRhdGEucmVmID09PSBjaGlsZHJlbltpXS5yZWYpIHtcbiAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGksIDEpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5fZG9SZW5kZXIoKVxufVxuXG5TbGlkZXIucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChjaGlsZCwgYmVmb3JlKSB7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICB2YXIgY2hpbGRJbmRleCA9IC0xXG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnJlZiA9PT0gYmVmb3JlLmRhdGEucmVmKSB7XG4gICAgICBjaGlsZEluZGV4ID0gaVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgY2hpbGRyZW4uc3BsaWNlKGNoaWxkSW5kZXgsIDAsIGNoaWxkLmRhdGEpXG5cbiAgdGhpcy5fZG9SZW5kZXIoKVxuICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXVxuICB9XG59XG5cblNsaWRlci5wcm90b3R5cGUuYXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW4gfHwgKHRoaXMuZGF0YS5jaGlsZHJlbiA9IFtdKVxuICBjaGlsZHJlbi5wdXNoKGRhdGEpXG4gIHRoaXMuX2RvUmVuZGVyKClcbiAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV1cbiAgfVxufVxuXG5TbGlkZXIucHJvdG90eXBlLmNyZWF0ZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vIHJlY3JlYXRlIHNsaWRlciBjb250YWluZXIuXG4gIGlmICh0aGlzLnNsaWRlckNvbnRhaW5lcikge1xuICAgIHRoaXMubm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNsaWRlckNvbnRhaW5lcilcbiAgfVxuICBpZiAodGhpcy5pbmRpY2F0b3IpIHtcbiAgICB0aGlzLmluZGljYXRvci5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5pbmRpY2F0b3Iubm9kZSlcbiAgfVxuICB0aGlzLmNoaWxkcmVuID0gW11cblxuICB2YXIgc2xpZGVyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKVxuICBzbGlkZXJDb250YWluZXIuc3R5bGUubGlzdFN0eWxlID0gJ25vbmUnXG4gIHRoaXMubm9kZS5hcHBlbmRDaGlsZChzbGlkZXJDb250YWluZXIpXG4gIHRoaXMuc2xpZGVyQ29udGFpbmVyID0gc2xpZGVyQ29udGFpbmVyXG5cbiAgdmFyIGNvbXBvbmVudE1hbmFnZXIgPSB0aGlzLmdldENvbXBvbmVudE1hbmFnZXIoKVxuXG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuZGF0YS5jaGlsZHJlblxuICB2YXIgc2NhbGUgPSB0aGlzLmRhdGEuc2NhbGVcbiAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIHZhciBpbmRpY2F0b3JEYXRhLCB3aWR0aCwgaGVpZ2h0XG4gIHZhciBjaGlsZFdpZHRoID0gMFxuICB2YXIgY2hpbGRIZWlnaHQgPSAwXG5cbiAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZFxuICAgICAgY2hpbGRyZW5baV0uc2NhbGUgPSB0aGlzLmRhdGEuc2NhbGVcbiAgICAgIGNoaWxkcmVuW2ldLmluc3RhbmNlSWQgPSB0aGlzLmRhdGEuaW5zdGFuY2VJZFxuICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09ICdpbmRpY2F0b3InKSB7XG4gICAgICAgIGluZGljYXRvckRhdGEgPSBleHRlbmQoY2hpbGRyZW5baV0sIHtcbiAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgYW1vdW50OiBjaGlsZHJlbi5sZW5ndGggLSAxLFxuICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZCA9IGNvbXBvbmVudE1hbmFnZXIuY3JlYXRlRWxlbWVudChjaGlsZHJlbltpXSwgJ2xpJylcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKVxuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjaGlsZC5ub2RlKVxuICAgICAgICB3aWR0aCA9IGNoaWxkLmRhdGEuc3R5bGUud2lkdGggfHwgMFxuICAgICAgICBoZWlnaHQgPSBjaGlsZC5kYXRhLnN0eWxlLmhlaWdodCB8fCAwXG4gICAgICAgIHdpZHRoID4gY2hpbGRXaWR0aCAmJiAoY2hpbGRXaWR0aCA9IHdpZHRoKVxuICAgICAgICBoZWlnaHQgPiBjaGlsZEhlaWdodCAmJiAoY2hpbGRIZWlnaHQgPSBoZWlnaHQpXG4gICAgICAgIGNoaWxkLnBhcmVudFJlZiA9IHRoaXMuZGF0YS5yZWZcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYXBwZW5kIGluZGljYXRvclxuICAgIGlmIChpbmRpY2F0b3JEYXRhKSB7XG4gICAgICBpbmRpY2F0b3JEYXRhLmV4dHJhLndpZHRoID0gdGhpcy5kYXRhLnN0eWxlLndpZHRoIHx8IGNoaWxkV2lkdGhcbiAgICAgIGluZGljYXRvckRhdGEuZXh0cmEuaGVpZ2h0ID0gdGhpcy5kYXRhLnN0eWxlLmhlaWdodCB8fCBjaGlsZEhlaWdodFxuICAgICAgdGhpcy5pbmRpY2F0b3IgPSBjb21wb25lbnRNYW5hZ2VyLmNyZWF0ZUVsZW1lbnQoaW5kaWNhdG9yRGF0YSlcbiAgICAgIHRoaXMuaW5kaWNhdG9yLnBhcmVudFJlZiA9IHRoaXMuZGF0YS5yZWZcbiAgICAgIHRoaXMuaW5kaWNhdG9yLnNsaWRlciA9IHRoaXNcbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmluZGljYXRvci5ub2RlKVxuICAgIH1cblxuICAgIHNsaWRlckNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBzY2FsZSAqIHRoaXMuZGF0YS5zdHlsZS5oZWlnaHQgKyAncHgnXG4gICAgc2xpZGVyQ29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KVxuICB9XG59XG5cblNsaWRlci5wcm90b3R5cGUub25BcHBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNhcnJvdXNlbCkge1xuICAgIHRoaXMuY2Fycm91c2VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2dldFNsaWRlckNoYW5nZUhhbmRsZXIoKSlcbiAgICB0aGlzLmNhcnJvdXNlbC5zdG9wKClcbiAgICB0aGlzLmNhcnJvdXNlbCA9IG51bGxcbiAgfVxuICB0aGlzLmNhcnJvdXNlbCA9IG5ldyBsaWIuY2Fycm91c2VsKHRoaXMuc2xpZGVyQ29udGFpbmVyLCB7XG4gICAgYXV0b3BsYXk6IHRoaXMuYXV0b1BsYXksXG4gICAgdXNlR2VzdHVyZTogdHJ1ZVxuICB9KVxuXG4gIHRoaXMuY2Fycm91c2VsLnBsYXlJbnRlcnZhbCA9IHRoaXMuaW50ZXJ2YWxcbiAgdGhpcy5jYXJyb3VzZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fZ2V0U2xpZGVyQ2hhbmdlSGFuZGxlcigpKVxuXG4gIHRoaXMuY3VycmVudEluZGV4ID0gMFxuXG4gIC8vIHByZWxvYWQgYWxsIGltYWdlcyBmb3Igc2xpZGVyXG4gIC8vIGJlY2F1c2U6XG4gIC8vIDEuIGxpYi1pbWcgZG9lc24ndCBsaXN0ZW4gdG8gZXZlbnQgdHJhbnNpdGlvbmVuZFxuICAvLyAyLiBldmVuIGlmIHdlIGZpcmUgbGF6eSBsb2FkIGluIHNsaWRlcidzIGNoYW5nZSBldmVudCBoYW5kbGVyLFxuICAvLyAgICB0aGUgbmV4dCBpbWFnZSBzdGlsbCB3b24ndCBiZSBwcmVsb2FkZWQgdXRpbGwgdGhlIG1vbWVudCBpdFxuICAvLyAgICBzbGlkZXMgaW50byB0aGUgdmlldywgd2hpY2ggaXMgdG9vIGxhdGUuXG4gIGlmICh0aGlzLnByZWxvYWRJbWdzVGltZXIpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5wcmVsb2FkSW1nc1RpbWVyKVxuICB9XG4gIC8vIFRoZSB0aW1lIGp1c3QgYmVmb3JlIHRoZSBzZWNvbmQgc2xpZGUgYXBwZWFyIGFuZCBlbm91Z2hcbiAgLy8gZm9yIGFsbCBjaGlsZCBlbGVtZW50cyB0byBhcHBlbmQgaXMgb2suXG4gIHZhciBwcmVsb2FkVGltZSA9IDAuOFxuICB0aGlzLnByZWxvYWRJbWdzVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1ncyA9IHRoaXMuY2Fycm91c2VsLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLndlZXgtaW1nJylcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGltZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgaW1nID0gaW1nc1tpXVxuICAgICAgdmFyIGlMYXp5U3JjID0gaW1nLmdldEF0dHJpYnV0ZSgnaS1sYXp5LXNyYycpXG4gICAgICB2YXIgaW1nU3JjID0gaW1nLmdldEF0dHJpYnV0ZSgnaW1nLXNyYycpXG4gICAgICB2YXIgcmVhbFNyYyA9IGlMYXp5U3JjIHx8IGltZ1NyY1xuICAgICAgLy8gdHJhbnNmZXIgdGhlIGltZ1VybCB0byBhIGNkbiBzdWZmaXhlZCB1cmwuXG4gICAgICByZWFsU3JjICYmIChyZWFsU3JjID0gbGliLmltZ2NvcmUuZ2V0TmV3VXJsKHJlYWxTcmMsIHtcbiAgICAgICAgZHByOiBkZWZhdWx0cy5iYXNlRHByLFxuICAgICAgICB3ZWJwU3VwcG9ydDogdXRpbHMuZGV0ZWN0V2VicCgpLFxuICAgICAgICBpZ25vcmVHaWY6IHRydWUsXG4gICAgICAgIGlnbm9yZVBuZzogZmFsc2UsXG4gICAgICAgIHdpZHRoOiB+fmltZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtd2lkdGgnKSB8fCAzMjAsXG4gICAgICAgIGhlaWdodDogfn5pbWcuZ2V0QXR0cmlidXRlKCdkYXRhLWhlaWdodCcpIHx8IDMyMCxcbiAgICAgICAgc2hhcnBlbjogaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1zaGFycGVuJykgfHwgJ3MxNTAnLFxuICAgICAgICBxOiBpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLXEtbm9ybWFsJykgfHwgZGVmYXVsdHMucU5vcm1hbFxuICAgICAgfSkpXG4gICAgICByZWFsU3JjICYmIChpbWcuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybCgnICsgcmVhbFNyYyArICcpJylcbiAgICAgIGltZy5yZW1vdmVBdHRyaWJ1dGUoJ2ktbGF6eS1zcmMnKVxuICAgICAgaW1nLnJlbW92ZUF0dHJpYnV0ZSgnaW1nLXNyYycpXG4gICAgfVxuICB9LmJpbmQodGhpcyksIHByZWxvYWRUaW1lICogMTAwMClcblxuICAvLyBhdm9pZCBwYWdlIHNjcm9sbCB3aGVuIHBhbm5pbmdcbiAgdmFyIHBhbm5pbmcgPSBmYWxzZVxuICB0aGlzLmNhcnJvdXNlbC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhbnN0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUuaXNWZXJ0aWNhbCkge1xuICAgICAgcGFubmluZyA9IHRydWVcbiAgICB9XG4gIH0pXG4gIHRoaXMuY2Fycm91c2VsLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGFuZW5kJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUuaXNWZXJ0aWNhbCkge1xuICAgICAgcGFubmluZyA9IGZhbHNlXG4gICAgfVxuICB9KVxuXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHBhbm5pbmcpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0uYmluZCh0aGlzKSlcblxufVxuXG5TbGlkZXIucHJvdG90eXBlLl91cGRhdGVJbmRpY2F0b3JzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmluZGljYXRvciAmJiB0aGlzLmluZGljYXRvci5zZXRJbmRleCh0aGlzLmN1cnJlbnRJbmRleClcbn1cblxuU2xpZGVyLnByb3RvdHlwZS5fZ2V0U2xpZGVyQ2hhbmdlSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gIGlmICghdGhpcy5zbGlkZXJDaGFuZ2VIYW5kbGVyKSB7XG4gICAgdGhpcy5zbGlkZXJDaGFuZ2VIYW5kbGVyID0gKGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmNhcnJvdXNlbC5pdGVtcy5pbmRleFxuICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBpbmRleFxuXG4gICAgICAvLyB1cGRhdGVJbmRpY2F0b3JzXG4gICAgICB0aGlzLl91cGRhdGVJbmRpY2F0b3JzKClcblxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdjaGFuZ2UnLCB7IGluZGV4OiBpbmRleCB9KVxuICAgIH0pLmJpbmQodGhpcylcbiAgfVxuICByZXR1cm4gdGhpcy5zbGlkZXJDaGFuZ2VIYW5kbGVyXG59XG5cblNsaWRlci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYXJyb3VzZWwucGxheSgpXG59XG5cblNsaWRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jYXJyb3VzZWwuc3RvcCgpXG59XG5cblNsaWRlci5wcm90b3R5cGUuc2xpZGVUbyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICB2YXIgb2Zmc2V0ID0gaW5kZXggLSB0aGlzLmN1cnJlbnRJbmRleFxuICB0aGlzLmNhcnJvdXNlbC5pdGVtcy5zbGlkZShvZmZzZXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVyXG5cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvY29tcG9uZW50cy9zbGlkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAxXG4gKiovIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zbGlkZXIuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NsaWRlci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zbGlkZXIuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3N0eWxlcy9zbGlkZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gMTUwXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnNsaWRlciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcblxcbi5zbGlkZXIgLmluZGljYXRvci1jb250YWluZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gIGJveC1hbGlnbjogY2VudGVyO1xcbiAgLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcXG4gIGJveC1wYWNrOiBjZW50ZXI7XFxuICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBmb250LXNpemU6IDA7XFxufVxcbi5zbGlkZXIgLmluZGljYXRvci1jb250YWluZXIgLmluZGljYXRvciB7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxufVxcbi5zbGlkZXIgLmluZGljYXRvci1jb250YWluZXIucm93IHtcXG4gIC13ZWJraXQtYm94LW9yaWVudDogaG9yaXpvbnRhbDtcXG4gIGJveC1vcmllbnQ6IGhvcml6b250YWw7XFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbn1cXG4uc2xpZGVyIC5pbmRpY2F0b3ItY29udGFpbmVyLmNvbHVtbiB7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcbiAgYm94LW9yaWVudDogdmVydGljYWw7XFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9jc3MtbG9hZGVyIS4vc3JjL3N0eWxlcy9zbGlkZXIuY3NzXG4gKiogbW9kdWxlIGlkID0gMTUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMVxuICoqLyIsIi8vIEZvciBkZWJ1ZzogcmVxdWlyZSB0aGUgbGF0ZXN0IHZlcnNpb24gd2hpY2ggaXMgbm90IHB1Ymxpc2hlZFxuLy8gdG8gdGhlIG5wbSB5ZXQuXG5cbnJlcXVpcmUoJy4vcnVudGltZS1wcm94eS5qcycpXG5cbi8vIEZvciByZWxlYXNlOiByZXF1aXJlIHRoZSBucG0gcHVibGlzaGVkIHZlcnNpb24gb2YganNmcmFtZXdvcmsuXG4vLyByZXF1aXJlKCdAYWxpL3dlZXgtanNmcmFtZXdvcmsnKVxuXG5yZXF1aXJlKCdlczYtcHJvbWlzZScpXG5cbnZhciB3ZWV4ID0gcmVxdWlyZSgnLi9zcmMvYWxpd2VleCcpXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3dlZXhidW5kbGUtZGVidWcuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIi8qKlxuICogQ3JlYXRlZCBieSBnb2Rzb25nIG9uIDE2LzYvMTUuXG4gKi9cbnZhciBXZWJzb2NrZXRDbGllbnQ9cmVxdWlyZSgnLi9XZWJzb2NrZXRDbGllbnQnKTtcbnZhciB3ZWJzb2NrZXRDbGllbnQ9bmV3IFdlYnNvY2tldENsaWVudCgnd3M6Ly8nK2xvY2F0aW9uLmhvc3QrJy9kZWJ1Z1Byb3h5L25hdGl2ZScpO1xuW1xuICAgICdjcmVhdGVJbnN0YW5jZScsXG4gICAgJ3JlZnJlc2hJbnN0YW5jZScsXG4gICAgJ2Rlc3Ryb3lJbnN0YW5jZScsXG4gICAgJ3JlZ2lzdGVyQ29tcG9uZW50cycsXG4gICAgJ3JlZ2lzdGVyTW9kdWxlcycsXG4gICAgJ3JlZ2lzdGVyTWV0aG9kcycsXG4gICAgJ2dldFJvb3QnLFxuICAgICdjYWxsSlMnXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG4gICAgd2luZG93W25hbWVdPWZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHdlYnNvY2tldENsaWVudC5zZW5kKHtcbiAgICAgICAgICAgIG1ldGhvZDonV3hEZWJ1Zy5jYWxsSlMnLFxuICAgICAgICAgICAgcGFyYW1zOntcbiAgICAgICAgICAgICAgICBtZXRob2Q6bmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzOmFyZ3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59KTtcbndlYnNvY2tldENsaWVudC5vbignV3hEZWJ1Zy5jYWxsTmF0aXZlJyxmdW5jdGlvbihtZXNzYWdlKXtcbiAgICB3aW5kb3cuY2FsbE5hdGl2ZShtZXNzYWdlLnBhcmFtcy5pbnN0YW5jZSxtZXNzYWdlLnBhcmFtcy50YXNrcyxtZXNzYWdlLnBhcmFtcy5jYWxsYmFjayk7XG59KTtcbndlYnNvY2tldENsaWVudC5zZW5kKHtcbiAgICBtZXRob2Q6XCJXeERlYnVnLmluaXRKU1J1bnRpbWVcIlxufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3J1bnRpbWUtcHJveHkuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyIsIi8qKlxuICogQ3JlYXRlZCBieSBnb2Rzb25nIG9uIDE2LzYvMTQuXG4gKi9cbmNsYXNzIFdlYnNvY2tldENsaWVudCB7XG4gICAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMuY29ubmVjdCh1cmwpO1xuICAgICAgICB0aGlzLmNvbnRleHQ9e307XG4gICAgfVxuICAgIGNvbm5lY3QodXJsKXtcbiAgICAgICAgbGV0IFRoaXM9dGhpcztcbiAgICAgICAgVGhpcy5pc1NvY2tldFJlYWR5PWZhbHNlO1xuICAgICAgICBpZihUaGlzLndzKXtcbiAgICAgICAgICAgIFRoaXMud3Mub25vcGVuPW51bGw7XG4gICAgICAgICAgICBUaGlzLndzLm9ubWVzc2FnZT1udWxsO1xuICAgICAgICAgICAgVGhpcy53cy5vbmNsb3NlPW51bGw7XG4gICAgICAgICAgICBpZihUaGlzLndzLnJlYWR5U3RhdGU9PVdlYlNvY2tldC5PUEVOKXtcbiAgICAgICAgICAgICAgICBUaGlzLndzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBsZXQgd3MgPSBuZXcgV2ViU29ja2V0KHVybCk7XG4gICAgICAgIFRoaXMud3M9d3M7XG4gICAgICAgIHdzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFRoaXMuaXNTb2NrZXRSZWFkeT10cnVlO1xuICAgICAgICAgICAgVGhpcy5lbWl0KCdzb2NrZXRPcGVuZWQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gSlNPTi5wYXJzZShlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgVGhpcy5lbWl0KG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd3Mub25jbG9zZT1mdW5jdGlvbigpe1xuICAgICAgICAgICAgVGhpcy5pc1NvY2tldFJlYWR5PWZhbHNlO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIFRoaXMuY29ubmVjdCh1cmwpO1xuICAgICAgICAgICAgfSw4MDApO1xuICAgICAgICB9O1xuXG4gICAgfVxuICAgIHNlbmQoZGF0YSl7XG4gICAgICAgIGlmKHRoaXMuaXNTb2NrZXRSZWFkeSl7XG4gICAgICAgICAgICB0aGlzLndzLnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0aGlzLm9uY2UoJ3NvY2tldE9wZW5lZCcsKCk9Pnt0aGlzLndzLnNlbmQoSlNPTi5zdHJpbmdpZnkoZGF0YSkpfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2ZmKG1ldGhvZCxoYW5kbGVyKXtcbiAgICAgICAgaWYoaGFuZGxlcil7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMuX2hhbmRsZXJzW21ldGhvZF0ubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5faGFuZGxlcnNbbWV0aG9kXVtpXT09PWhhbmRsZXIpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1ttZXRob2RdLnNwbGljZShpLDEpO1xuICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1ttZXRob2RdPVtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uY2UobWV0aG9kLGhhbmRsZXIpe1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBmaXJlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgICAgICBzZWxmLm9mZihtZXRob2QsIGcpO1xuICAgICAgICAgICAgaWYgKCFmaXJlZCkge1xuICAgICAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbihtZXRob2QsIGcpO1xuICAgIH1cbiAgICBvbihtZXRob2QsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW21ldGhvZF0ucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW21ldGhvZF0gPSBbaGFuZGxlcl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZW1pdChtZXRob2QsIGFyZ3MsY29udGV4dCkge1xuICAgICAgICBsZXQgaGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVyc1ttZXRob2RdO1xuICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyPT5oYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW1pdChtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGNvbnRleHQ9e307XG4gICAgICAgIGlmICghdGhpcy5fZW1pdChtZXRob2QsIGFyZ3MsY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJyRkZWZhdWx0JywgYXJncyxjb250ZXh0KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VtaXQoJyRmaW5hbGx5JywgYXJncyxjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHM9V2Vic29ja2V0Q2xpZW50O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9XZWJzb2NrZXRDbGllbnQuanNcbiAqKiBtb2R1bGUgaWQgPSAxNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMVxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=